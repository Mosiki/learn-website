<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>加餐 谈谈Kong Ingress Controller.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <link rel="stylesheet"
              href="../../static/highlight.min.css">
        <script src="../../static/highlight.min.js"></script>
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5295275829820252"
                crossorigin="anonymous"></script>
        <script async defer data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" src="https://analyze.lianglianglee.com/umami.js"></script>
    </head>

<body>

    <div class="book-container">
        <div class="book-sidebar">
            <div class="book-brand">
                <a href="../../index.html">
                    <img src="../../static/favicon.png">
                    <span>技术文章摘抄</span>
                </a>
            </div>
            <div class="book-menu uncollapsible">
                <ul class="uncollapsible">
                    <li><a href="../../index.html" class="current-tab">首页</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li><a href="../index.html">上一级</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li>

                        
                        <a href="00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%E8%BF%8E%E9%9A%BE%E8%80%8C%E4%B8%8A%EF%BC%8C%E5%81%9A%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E7%9A%84%E5%BC%84%E6%BD%AE%E5%84%BF.md.html">00 开篇词 迎难而上，做云原生时代的弄潮儿.md</a>

                    </li>
                    <li>

                        
                        <a href="00%20%E8%AF%BE%E5%89%8D%E5%87%86%E5%A4%87%20%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5%E6%89%8D%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%BC%8F.md.html">00 课前准备 动手实践才是最好的学习方式.md</a>

                    </li>
                    <li>

                        
                        <a href="01%20%E5%88%9D%E8%AF%86%E5%AE%B9%E5%99%A8%EF%BC%9A%E4%B8%87%E4%BA%8B%E5%BC%80%E5%A4%B4%E9%9A%BE.md.html">01 初识容器：万事开头难.md</a>

                    </li>
                    <li>

                        
                        <a href="02%20%E8%A2%AB%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9A%E4%B8%80%E8%B5%B7%E6%9D%A5%E7%9C%8B%E7%9C%8B%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9C%AC%E8%B4%A8.md.html">02 被隔离的进程：一起来看看容器的本质.md</a>

                    </li>
                    <li>

                        
                        <a href="03%20%E5%AE%B9%E5%99%A8%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E4%BC%9A%E4%BA%86%E8%BF%99%E4%BA%9B%E4%BD%A0%E5%B0%B1%E6%98%AFDocker%E9%AB%98%E6%89%8B.md.html">03 容器化的应用：会了这些你就是Docker高手.md</a>

                    </li>
                    <li>

                        
                        <a href="04%20%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%AD%A3%E7%A1%AE%E3%80%81%E9%AB%98%E6%95%88%E7%9A%84Dockerfile.md.html">04 创建容器镜像：如何编写正确、高效的Dockerfile.md</a>

                    </li>
                    <li>

                        
                        <a href="05%20%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%EF%BC%9A%E8%AF%A5%E6%80%8E%E6%A0%B7%E7%94%A8%E5%A5%BDDocker%20Hub%E8%BF%99%E4%B8%AA%E5%AE%9D%E8%97%8F.md.html">05 镜像仓库：该怎样用好Docker Hub这个宝藏.md</a>

                    </li>
                    <li>

                        
                        <a href="06%20%E6%89%93%E7%A0%B4%E6%AC%A1%E5%85%83%E5%A3%81%EF%BC%9A%E5%AE%B9%E5%99%A8%E8%AF%A5%E5%A6%82%E4%BD%95%E4%B8%8E%E5%A4%96%E7%95%8C%E4%BA%92%E8%81%94%E4%BA%92%E9%80%9A.md.html">06 打破次元壁：容器该如何与外界互联互通.md</a>

                    </li>
                    <li>

                        
                        <a href="07%20%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83%EF%BC%9A%E7%8E%A9%E8%BD%ACDocker.md.html">07 实战演练：玩转Docker.md</a>

                    </li>
                    <li>

                        
                        <a href="08%20%E8%A7%86%E9%A2%91%EF%BC%9A%E5%85%A5%E9%97%A8%E7%AF%87%E5%AE%9E%E6%93%8D%E6%80%BB%E7%BB%93.md.html">08 视频：入门篇实操总结.md</a>

                    </li>
                    <li>

                        
                        <a href="09%20%E8%B5%B0%E8%BF%91%E4%BA%91%E5%8E%9F%E7%94%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%AC%E6%9C%BA%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%B7%A7%E5%AE%8C%E5%A4%87%E7%9A%84Kubernetes%E7%8E%AF%E5%A2%83.md.html">09 走近云原生：如何在本机搭建小巧完备的Kubernetes环境.md</a>

                    </li>
                    <li>

                        
                        <a href="10%20%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%EF%BC%9A%E6%8E%A2%E7%A9%B6Kubernetes%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E7%9A%84%E5%A5%A5%E7%A7%98.md.html">10 自动化的运维管理：探究Kubernetes工作机制的奥秘.md</a>

                    </li>
                    <li>

                        
                        <a href="11%20YAML%EF%BC%9AKubernetes%E4%B8%96%E7%95%8C%E9%87%8C%E7%9A%84%E9%80%9A%E7%94%A8%E8%AF%AD.md.html">11 YAML：Kubernetes世界里的通用语.md</a>

                    </li>
                    <li>

                        
                        <a href="12%20Pod%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E8%BF%99%E4%B8%AAKubernetes%E9%87%8C%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9F.md.html">12 Pod：如何理解这个Kubernetes里最核心的概念？.md</a>

                    </li>
                    <li>

                        
                        <a href="13%20Job_CronJob%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8Pod%E6%9D%A5%E5%A4%84%E7%90%86%E4%B8%9A%E5%8A%A1%EF%BC%9F.md.html">13 Job_CronJob：为什么不直接用Pod来处理业务？.md</a>

                    </li>
                    <li>

                        
                        <a href="14%20ConfigMap_Secret%EF%BC%9A%E6%80%8E%E6%A0%B7%E9%85%8D%E7%BD%AE%E3%80%81%E5%AE%9A%E5%88%B6%E6%88%91%E7%9A%84%E5%BA%94%E7%94%A8.md.html">14 ConfigMap_Secret：怎样配置、定制我的应用.md</a>

                    </li>
                    <li>

                        
                        <a href="15%20%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83%EF%BC%9A%E7%8E%A9%E8%BD%ACKubernetes%EF%BC%881%EF%BC%89.md.html">15 实战演练：玩转Kubernetes（1）.md</a>

                    </li>
                    <li>

                        
                        <a href="16%20%E8%A7%86%E9%A2%91%EF%BC%9A%E5%88%9D%E7%BA%A7%E7%AF%87%E5%AE%9E%E6%93%8D%E6%80%BB%E7%BB%93.md.html">16 视频：初级篇实操总结.md</a>

                    </li>
                    <li>

                        
                        <a href="17%20%E6%9B%B4%E7%9C%9F%E5%AE%9E%E7%9A%84%E4%BA%91%E5%8E%9F%E7%94%9F%EF%BC%9A%E5%AE%9E%E9%99%85%E6%90%AD%E5%BB%BA%E5%A4%9A%E8%8A%82%E7%82%B9%E7%9A%84Kubernetes%E9%9B%86%E7%BE%A4.md.html">17 更真实的云原生：实际搭建多节点的Kubernetes集群.md</a>

                    </li>
                    <li>

                        
                        <a href="18%20Deployment%EF%BC%9A%E8%AE%A9%E5%BA%94%E7%94%A8%E6%B0%B8%E4%B8%8D%E5%AE%95%E6%9C%BA.md.html">18 Deployment：让应用永不宕机.md</a>

                    </li>
                    <li>

                        
                        <a href="19%20Daemonset%EF%BC%9A%E5%BF%A0%E5%AE%9E%E5%8F%AF%E9%9D%A0%E7%9A%84%E7%9C%8B%E9%97%A8%E7%8B%97.md.html">19 Daemonset：忠实可靠的看门狗.md</a>

                    </li>
                    <li>

                        
                        <a href="20%20Service%EF%BC%9A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E5%BA%94%E5%AF%B9%E4%B9%8B%E9%81%93.md.html">20 Service：微服务架构的应对之道.md</a>

                    </li>
                    <li>

                        
                        <a href="21%20Ingress%EF%BC%9A%E9%9B%86%E7%BE%A4%E8%BF%9B%E5%87%BA%E6%B5%81%E9%87%8F%E7%9A%84%E6%80%BB%E7%AE%A1.md.html">21 Ingress：集群进出流量的总管.md</a>

                    </li>
                    <li>

                        
                        <a href="22%20%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83%EF%BC%9A%E7%8E%A9%E8%BD%ACKubernetes%EF%BC%882%EF%BC%89.md.html">22 实战演练：玩转Kubernetes（2）.md</a>

                    </li>
                    <li>

                        
                        <a href="23%20%E8%A7%86%E9%A2%91%EF%BC%9A%E4%B8%AD%E7%BA%A7%E7%AF%87%E5%AE%9E%E6%93%8D%E6%80%BB%E7%BB%93.md.html">23 视频：中级篇实操总结.md</a>

                    </li>
                    <li>

                        
                        <a href="24%20PersistentVolume%EF%BC%9A%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E9%9A%BE%E9%A2%98%EF%BC%9F.md.html">24 PersistentVolume：怎么解决数据持久化的难题？.md</a>

                    </li>
                    <li>

                        
                        <a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Kubernetes%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E8%AF%BE/25%20PersistentVolume%20+%20NFS%EF%BC%9A%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%EF%BC%9F.md">25 PersistentVolume + NFS：怎么使用网络共享存储？.md</a>

                    </li>
                    <li>

                        
                        <a href="26%20StatefulSet%EF%BC%9A%E6%80%8E%E4%B9%88%E7%AE%A1%E7%90%86%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9F.md.html">26 StatefulSet：怎么管理有状态的应用？.md</a>

                    </li>
                    <li>

                        
                        <a href="27%20%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%B9%B3%E6%BB%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%8D%87%E7%BA%A7%E9%99%8D%E7%BA%A7%EF%BC%9F.md.html">27 滚动更新：如何做到平滑的应用升级降级？.md</a>

                    </li>
                    <li>

                        
                        <a href="28%20%E5%BA%94%E7%94%A8%E4%BF%9D%E9%9A%9C%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9Pod%E8%BF%90%E8%A1%8C%E5%BE%97%E6%9B%B4%E5%81%A5%E5%BA%B7%EF%BC%9F.md.html">28 应用保障：如何让Pod运行得更健康？.md</a>

                    </li>
                    <li>

                        
                        <a href="29%20%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4%E5%88%86%E9%9A%94%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%EF%BC%9F.md.html">29 集群管理：如何用名字空间分隔系统资源？.md</a>

                    </li>
                    <li>

                        
                        <a href="30%20%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Metrics%20Server%E5%92%8CPrometheus%EF%BC%9F.md.html">30 系统监控：如何使用Metrics Server和Prometheus？.md</a>

                    </li>
                    <li>

                        
                        <a href="31%20%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%EF%BC%9ACNI%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F%E5%8F%88%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F.md.html">31 网络通信：CNI是怎么回事？又是怎么工作的？.md</a>

                    </li>
                    <li>

                        
                        <a href="32%20%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83%EF%BC%9A%E7%8E%A9%E8%BD%ACKubernetes%EF%BC%883%EF%BC%89.md.html">32 实战演练：玩转Kubernetes（3）.md</a>

                    </li>
                    <li>

                        
                        <a href="33%20%E8%A7%86%E9%A2%91%EF%BC%9A%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AE%9E%E6%93%8D%E6%80%BB%E7%BB%93.md.html">33 视频：高级篇实操总结.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20docker-compose%EF%BC%9A%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E5%B7%A5%E5%85%B7.md.html">加餐 docker-compose：单机环境下的容器编排工具.md</a>

                    </li>
                    <li>

                        <a class="current-tab" href="%E5%8A%A0%E9%A4%90%20%E8%B0%88%E8%B0%88Kong%20Ingress%20Controller.md.html">加餐 谈谈Kong Ingress Controller.md</a>
                        

                    </li>
                    <li>

                        
                        <a href="%E7%BB%93%E6%9D%9F%E8%AF%AD%20%E6%98%AF%E7%BB%88%E7%82%B9%EF%BC%8C%E6%9B%B4%E6%98%AF%E8%B5%B7%E7%82%B9.md.html">结束语 是终点，更是起点.md</a>

                    </li>
                </ul>

            </div>
        </div>

        <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
            <div class="sidebar-toggle-inner"></div>
        </div>

        <script>
            function add_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.add('show')
            }

            function remove_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.remove('show')
            }

            function sidebar_toggle() {
                let sidebar_toggle = document.querySelector('.sidebar-toggle')
                let sidebar = document.querySelector('.book-sidebar')
                let content = document.querySelector('.off-canvas-content')
                if (sidebar_toggle.classList.contains('extend')) { // show
                    sidebar_toggle.classList.remove('extend')
                    sidebar.classList.remove('hide')
                    content.classList.remove('extend')
                } else { // hide
                    sidebar_toggle.classList.add('extend')
                    sidebar.classList.add('hide')
                    content.classList.add('extend')
                }
            }


            function open_sidebar() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.add('show')
                overlay.classList.add('show')
            }
            function hide_canvas() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.remove('show')
                overlay.classList.remove('show')
            }

        </script>

        <div class="off-canvas-content">
            <div class="columns">
                <div class="column col-12 col-lg-12">
                    <div class="book-navbar">
                        <!-- For Responsive Layout -->
                        <header class="navbar">
                            <section class="navbar-section">
                                <a onclick="open_sidebar()">
                                    <i class="icon icon-menu"></i>
                                </a>
                            </section>
                        </header>
                    </div>
                    <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                        <div class="book-post">
                            <p id="tip" align="center"></p>
                            <div><h1>加餐 谈谈Kong Ingress Controller</h1>
<p>你好，我是Chrono。</p>
<p>课程已经完结三个多月了，还记得结课时我说的那句话吗：“是终点，更是起点”，课程的完结绝不意味着我们终止对Kubernetes的钻研，相反，不论你我，都会在这个学习的道路上持续地走下去。</p>
<p>当初开课时，我计划了很多内容，不过Kubernetes的领域实在太广，加上我日常工作比较忙，时间和精力有限，所以一些原定的知识点没有来得及展现，比较可惜，我一直想找机会做个补偿。</p>
<p>这几天开发任务略微空闲了些，我就又回到了专栏，准备使用另一个流行的工具：Kong Ingress Controller，再来讲讲对Kubernetes集群管理非常重要的Ingress。</p>
<h2>认识Kong Ingress Controller</h2>
<p>我们先快速回顾一下Ingress的知识（[第21讲]）。</p>
<p>Ingress类似Service，基于HTTP/HTTPS协议，是七层负载均衡规则的集合，但它自身没有管理能力，必须要借助Ingress Controller才能控制Kubernetes集群的进出口流量。</p>
<p>所以，基于Ingress的定义，就出现了各式各样的Ingress Controller实现。</p>
<p>我们已经见过了Nginx官方开发的Nginx Ingress Controller，但它局限于Nginx自身的能力，Ingress、Service等对象更新时必须要修改静态的配置文件，再重启进程（reload），在变动频繁的微服务系统里就会引发一些问题。</p>
<p>而今天要说的<strong>Kong Ingress Controller</strong>，则是站在了Nginx这个巨人的肩膀之上，基于OpenResty和内嵌的LuaJIT环境，实现了完全动态的路由变更，消除了reload的成本，运行更加平稳，而且还有很多额外的增强功能，非常适合那些对Kubernetes集群流量有更高、更细致管理需求的用户（<a href="https://konghq.com/solutions/build-on-kubernetes">图片来源Kong官网</a>）。</p>
<p><img src="assets/8ed5086bb73d01ccdcd83deec1b8d643.png" alt="图片" /></p>
<h2>安装Kong Ingress Controller</h2>
<p>接下来我们就来看看如何在Kubernetes集群里引入Kong Ingress Controller。</p>
<p>简单起见，这次我选择了minikube环境，版本还是1.25.2，对应的Kubernetes也是之前的1.23.3：</p>
<p><img src="assets/252d80c9a08b7ddfccceb09a63b2da53.png" alt="图片" /></p>
<p>目前Kong Ingress Controller的最新版本是2.7.0，你可以从GitHub上(<a href="https://github.com/Kong/kubernetes-ingress-controller">https://github.com/Kong/kubernetes-ingress-controller</a>)直接获取它的源码包：</p>
<pre><code>wget https://github.com/Kong/kubernetes-ingress-controller/archive/refs/tags/v2.7.0.tar.gz
</code></pre>
<p>Kong Ingress Controller安装所需的YAML文件，都存放在解压缩后的“deploy”目录里，提供“有数据库”和“无数据库”两种部署方式，这里我选择了最简单的“无数据库”方式，只需要一个 <code>all-in-one-dbless.yaml</code> 就可以完成部署工作，也就是执行这条 <code>kubectl apply</code> 命令：</p>
<pre><code>kubectl apply -f all-in-one-dbless.yaml
</code></pre>
<p><img src="assets/ee592a45c3b45c8335a2d1ae08bd73a6.png" alt="图片" /></p>
<p>我们可以再对比一下两种 Ingress Controller的安装方式。Nginx Ingress Controller是由多个分散的YAML文件组成的，需要顺序执行多次 <code>kubectl apply</code> 命令，有点麻烦；<strong>而Kong Ingress Controller则把Namespace、RBAC、Secret、CRD等对象都合并在了一个文件里，安装很方便，同时也不会发生遗忘创建资源的错误。</strong></p>
<p>安装之后，Kong Ingress Controller会创建一个新的名字空间“kong”，里面有一个默认的Ingress Controller，还有对应的Service，你可以用 <code>kubectl get</code> 来查看：</p>
<p><img src="assets/967cbd227fc4aa8202b2531b59341f9e.png" alt="图片" /></p>
<p>看这里的截图，你可能会注意到，在 <code>kubectl get pod</code> 输出的“READY”列里显示的是“2/2”，意思是这个Pod里有两个容器。</p>
<p>这也是Kong Ingress Controller与Nginx Ingress Controller在实现架构方面的一个明显不同点。</p>
<p>Kong Ingress Controller，在Pod里使用两个容器，分别运行管理进程Controller和代理进程Proxy，两个容器之间使用环回地址（Loopback）通信；而Nginx Ingress Controller则是因为要修改静态的Nginx配置文件，所以管理进程和代理进程必须在一个容器里（<a href="https://docs.konghq.com/kubernetes-ingress-controller/2.7.x/concepts/design/">图片</a>表示Kong架构设计）。</p>
<p><img src="assets/e78c0c518c6257bc5018d0df8bd536d3.png" alt="图片" /></p>
<p>两种方式并没有优劣之分，但<strong>Kong Ingress Controller分离的好处是两个容器彼此独立，可以各自升级维护，对运维更友好一点</strong>。</p>
<p>Kong Ingress Controller还创建了两个Service对象，其中的“kong-proxy”是转发流量的服务，注意它被定义成了“LoadBalancer”类型，显然是为了在生产环境里对外暴露服务，不过在我们的实验环境（无论是minikube还是kubeadm）中只能使用NodePort的形式，这里可以看到80端口被映射到了节点的32201。</p>
<p>现在让我们尝试访问一下Kong Ingress Controller，IP就用worker节点的地址，如果你和我一样用的是minikube，则可以用 <code>$(minikube ip)</code> 的形式简单获取：</p>
<pre><code>curl $(minikube ip):32201 -i
</code></pre>
<p><img src="assets/a00aea97b464f071e9bea603f5678ef5.png" alt="图片" /></p>
<p>从curl获取的响应结果可以看到， Kong Ingress Controller 2.7内部使用的Kong版本是3.0.1，因为现在我们没有为它配置任何Ingress资源，所以返回了状态码404，这是正常的。</p>
<p>我们还可以用 <code>kubectl exec</code> 命令进入Pod，查看它的内部信息：</p>
<p><img src="assets/60a4f01dd3bbb0afab4d142b1d232a32.png" alt="图片" /></p>
<p>虽然Kong Ingress Controller里有两个容器，但我们不需要特意用 <code>-c</code> 选项指定容器，它会自动进入默认的Proxy容器（另一个Controller容器里因为不包含Shell，也是无法进入查看的）。</p>
<h2>使用Kong Ingress Controller</h2>
<p>安装好了，我们看如何使用。和第21讲里的一样，我们仍然不使用默认的Ingress Controller，而是利用Ingress Class自己创建一个新的实例，这样能够更好地理解掌握Kong Ingress Controller的用法。</p>
<p>首先，定义后端应用，还是用Nginx来模拟，做法和[第20讲]里的差不多，用ConfigMap定义配置文件再加载进Nginx Pod里，然后部署Deployment和Service，比较简单，你也比较熟悉，就不列出YAML 代码了，只看一下运行命令后的截图：</p>
<p><img src="assets/a2d859927200ca449d9e50f6122e5705.png" alt="图片" /></p>
<p>显示我创建了两个Nginx Pod，Service对象的名字是ngx-svc。</p>
<p>接下来是定义Ingress Class，名字是“<strong>kong-ink</strong>”， “spec.controller”字段的值是Kong Ingress Controller的名字“<strong>ingress-controllers.konghq.com/kong</strong>”，YAML的格式可以参考[第21讲]：</p>
<pre><code>apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: kong-ink

spec:
  controller: ingress-controllers.konghq.com/kong
</code></pre>
<p>然后就是定义Ingress对象了，我们还是可以用 <code>kubectl create</code> 来生成YAML 样板文件，用 <code>--rule</code> 指定路由规则，用 <code>--class</code> 指定Ingress Class：</p>
<pre><code>kubectl create ing kong-ing --rule=&quot;kong.test/=ngx-svc:80&quot; --class=kong-ink $out
</code></pre>
<p>生成的Ingress对象大概就是下面这样，域名是“kong.test”，流量会转发到后端的ngx-svc服务：</p>
<pre><code>apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kong-ing

spec:
  ingressClassName: kong-ink

  rules:
  - host: kong.test
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: ngx-svc
            port:
              number: 80
</code></pre>
<p>最后，我们要从 <code>all-in-one-dbless.yaml</code> 这个文件中分离出Ingress Controller的定义。其实也很简单，只要搜索“Deployment”就可以了，然后把它以及相关的Service代码复制一份，另存成“kic.yml”。</p>
<p>当然了，刚复制的代码和默认的Kong Ingress Controller是完全相同的，所以我们必须要参考帮助文档做一些修改，要点我列在了这里：</p>
<ul>
<li>Deployment、Service里metadata的 name 都要重命名，比如改成 ingress-kong-dep、ingress-kong-svc。</li>
<li>spec.selector 和 template.metadata.labels 也要修改成自己的名字，一般来说和Deployment的名字一样，也就是ingress-kong-dep。</li>
<li>第一个容器是流量代理Proxy，它里面的镜像可以根据需要，改成任意支持的版本，比如Kong:2.7、Kong:2.8或者Kong:3.1。</li>
<li>第二个容器是规则管理Controller，要用环境变量“CONTROLLER_INGRESS_CLASS”指定新的Ingress Class名字 <code>kong-ink</code>，同时用“CONTROLLER_PUBLISH_SERVICE”指定Service的名字 <code>ingress-kong-svc</code>。</li>
<li>Service对象可以把类型改成NodePort，方便后续的测试。</li>
</ul>
<p>改了这些之后，一个新的Kong Ingress Controller就完成了，大概是这样，修改点我也加注释了你可以对照着看：</p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: ingress-kong-dep            # 重命名
  namespace: kong
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ingress-kong-dep        # 重命名
  template:
    metadata:
      labels:
        app: ingress-kong-dep        # 重命名
    spec:
      containers:
      - env:                       # 第一个容器， Proxy
        ...
        image: kong:3.1            # 改镜像

      - env:                       # 第二个容器，Controller
        - name: CONTROLLER_INGRESS_CLASS
          value: kong-ink                  # 改Ingress Class
        - name: CONTROLLER_PUBLISH_SERVICE
          value: kong/ingress-kong-svc     # 改Service
        ...
---

apiVersion: v1
kind: Service
metadata:
  name: ingress-kong-svc          # 重命名
  namespace: kong
spec:
  ...
  selector:
    app: ingress-kong-dep         # 重命名
  type: NodePort                  # 改类型 
</code></pre>
<p>在我们专栏的配套GitHub项目里，你也可以直接找到改好的YAML 文件。-
把这些都准备好，我们就可以来测试验证Kong Ingress Controller了：</p>
<pre><code>kubectl apply -f ngx-deploy.yml
kubectl apply -f ingress.yml
kubectl apply -f kic.yml
</code></pre>
<p><img src="assets/7a00571f1c6ffc3391bda762206e74cc.png" alt="图片" /></p>
<p>这个截图显示了这些对象的创建结果，其中，新Service对象的NodePort端口是32521。</p>
<p>下面我们就来用curl发送HTTP请求，注意，<strong>应该用“--resolve”或者“-H”参数指定Ingress里定义的域名“kong.test”</strong>，否则Kong Ingress Controller会找不到路由：</p>
<pre><code>curl $(minikube ip):32521 -H 'host: kong.test' -v
</code></pre>
<p><img src="assets/16b663f31e55015a526791c22f6bcc3d.png" alt="图片" /></p>
<p>你可以看到，Kong Ingress Controller正确应用了Ingress路由规则，返回了后端Nginx应用的响应数据，而且从响应头“Via”里还可以发现，它现在用的是Kong 3.1。</p>
<h2>扩展Kong Ingress Controller</h2>
<p>到这里，Kong Ingress Controller的基本用法你就掌握了。</p>
<p>不过，只使用Kubernetes标准的Ingress资源来管理流量，是无法发挥出Kong Ingress Controller的真正实力的，它还有很多非常好用、非常实用的增强功能。</p>
<p>我们在[第27讲]里曾经说过annotation，是Kubernetes为资源对象提供的一个方便扩展功能的手段，所以，<strong>使用annotation就可以在不修改Ingress自身定义的前提下，让Kong Ingress Controller更好地利用内部的Kong来管理流量。</strong></p>
<p>目前Kong Ingress Controller支持在Ingress和Service这两个对象上添加annotation，相关的详细文档可以参考官网（<a href="https://docs.konghq.com/kubernetes-ingress-controller/2.7.x/references/annotations/">https://docs.konghq.com/kubernetes-ingress-controller/2.7.x/references/annotations/</a>），这里我只介绍两个annotation。</p>
<p>第一个是“<strong>konghq.com/host-aliases</strong>”，它可以为Ingress规则添加额外的域名。</p>
<p>你应该知道吧，Ingress的域名里可以使用通配符 <code>*</code>，比如 <code>*.abc.com</code>，但问题在于 <code>*</code> 只能是前缀，不能是后缀，也就是说我们无法写出 <code>abc.*</code> 这样的域名，这在管理多个域名的时候就显得有点麻烦。</p>
<p>有了“konghq.com/host-aliases”，我们就可以用它来“绕过”这个限制，让Ingress轻松匹配有不同后缀的域名。</p>
<p>比如，我修改一下Ingress定义，在“metadata”里添加一个annotation，让它除了“kong.test”，还能够支持“kong.dev”“kong.ops”等域名，就是这样：</p>
<pre><code>apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kong-ing
  annotations:
    konghq.com/host-aliases: &quot;kong.dev, kong.ops&quot;  #注意这里
spec:
  ...
</code></pre>
<p>使用 <code>kubectl apply</code> 更新Ingress，再用curl来测试一下：</p>
<p><img src="assets/341506cde73d8b7a75eb6ee75ea77eyy.png" alt="图片" /></p>
<p>你就会发现Ingress已经支持了这几个新域名。</p>
<p>第二个是“<strong>konghq.com/plugins</strong>”，它可以启用Kong Ingress Controller内置的各种插件（Plugins）。</p>
<p>插件，是Kong Ingress Controller的一个特色功能，你可以理解成是“预制工件”，能够附加在流量转发的过程中，实现各种数据处理，并且这个插件机制是开放的，我们既可以使用官方插件，也可以使用第三方插件，还可以使用Lua、Go等语言编写符合自己特定需求的插件。</p>
<p>Kong公司维护了一个经过认证的插件中心（<a href="https://docs.konghq.com/hub/">https://docs.konghq.com/hub/</a>），你可以在这里找到涉及认证、安全、流控、分析、日志等多个领域大约100多个插件，今天我们看两个常用的 Response Transformer、Rate Limiting。</p>
<p><img src="assets/edc8b1307a7194935d2ccc96fb4bbe8d.png" alt="图片" /></p>
<p>Response Transformer插件实现了对响应数据的修改，能够添加、替换、删除响应头或者响应体；Rate Limiting插件就是限速，能够以时分秒等单位任意限制客户端访问的次数。</p>
<p>定义插件需要使用CRD资源，名字是“<strong>KongPlugin</strong>”，你也可以用<code>kubectl api-resources</code>、<code>kubectl explain</code> 等命令来查看它的apiVersion、kind等信息：</p>
<p><img src="assets/36a25a182b0b1b671c1336a7b0610443.png" alt="图片" /></p>
<p>下面我就给出这两个插件对象的示例定义：</p>
<pre><code>apiVersion: configuration.konghq.com/v1
kind: KongPlugin
metadata:
  name: kong-add-resp-header-plugin

plugin: response-transformer
config:
  add:
    headers:
    - Resp-New-Header:kong-kic

---

apiVersion: configuration.konghq.com/v1
kind: KongPlugin
metadata:
  name: kong-rate-limiting-plugin

plugin: rate-limiting
config:
  minute: 2
</code></pre>
<p>KongPlugin对象，因为是自定义资源，所以和标准Kubernetes对象不一样，不使用“spec”字段，而是用“<strong>plugin</strong>”来指定插件名，用“<strong>config</strong>”来指定插件的配置参数。</p>
<p>比如在这里，我就让Response Transformer插件添加一个新的响应头字段，让Rate Limiting插件限制客户端每分钟只能发两个请求。</p>
<p>定义好这两个插件之后，我们就可以在Ingress对象里用annotations来启用插件功能了：</p>
<pre><code>apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kong-ing
  annotations:
    konghq.com/plugins: |
        kong-add-resp-header-plugin,
        kong-rate-limiting-plugin
</code></pre>
<p>现在让我们应用这些插件对象，并且更新Ingress：</p>
<pre><code>kubectl apply -f crd.yml
</code></pre>
<p>再发送curl请求：</p>
<pre><code>curl $(minikube ip):32521 -H 'host: kong.test' -i
</code></pre>
<p><img src="assets/a6cc78271975de082c140a83e581b615.png" alt="图片" /></p>
<p>你就会发现响应头里多出了几个字段，其中的 <code>RateLimit-*</code> 是限速信息，而 <code>Resp-New-Header</code> 就是新加的响应头字段。</p>
<p>把curl连续执行几次，就可以看到限速插件生效了：</p>
<p><img src="assets/b2b321c8f7597c9ed151c2783af76282.png" alt="图片" /></p>
<p>Kong Ingress Controller会返回429错误，告诉你访问受限，而且会用“Retry-After”等字段来告诉你多少秒之后才能重新发请求。</p>
<h2>小结</h2>
<p>好了，今天我们学习了另一种在Kubernetes管理集群进出流量的工具：Kong Ingress Controller，小结一下要点内容：</p>
<ol>
<li>Kong Ingress Controller的底层内核仍然是Nginx，但基于OpenResty和LuaJIT，实现了对路由的完全动态管理，不需要reload。</li>
<li>使用“无数据库”的方式可以非常简单地安装Kong Ingress Controller，它是一个由两个容器组成的Pod。</li>
<li>Kong Ingress Controller支持标准的Ingress资源，但还使用了annotation和CRD提供更多的扩展增强功能，特别是插件，可以灵活地加载或者拆卸，实现复杂的流量管理策略。</li>
</ol>
<p>作为一个CNCF云原生项目，Kong Ingress Controller已经得到了广泛的应用和认可，而且在近年的发展过程中，它也开始支持新的Gateway API，等下次有机会我们再细聊吧。</p>
<h2>课下作业</h2>
<p>最后是课下作业时间，给你留两个思考题：</p>
<ol>
<li>你能否对比一下Kong Ingress Controller和Nginx Ingress Controller这两个产品，你看重的是它哪方面的表现呢？</li>
<li>你觉得插件这种机制有什么好处，能否列举一些其他领域里的类似项目？</li>
</ol>
<p>好久不见了，期待看到你的想法，我们一起讨论，留言区见。</p>
<p><img src="assets/e9c9050ebcd1d0fc001c53e1d75a37c8.jpg" alt="图片" /></p>
</div>
                        </div>
                        <div>
                            <div style="float: left">
                                <a href="%E5%8A%A0%E9%A4%90%20docker-compose%EF%BC%9A%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E5%B7%A5%E5%85%B7.md.html">上一页</a>
                            </div>
                            <div style="float: right">
                                <a href="%E7%BB%93%E6%9D%9F%E8%AF%AD%20%E6%98%AF%E7%BB%88%E7%82%B9%EF%BC%8C%E6%9B%B4%E6%98%AF%E8%B5%B7%E7%82%B9.md.html">下一页</a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="copyright"><p>© 2019 - 2023 <a href="../../cdn-cgi/l/email-protection.html#deb2b2b2e7eaefefeee99eb9b3bfb7b2f0bdb1b3" target="_blank">Liangliang Lee</a>. Powered by <a href="https://vertx.io/" target="_blank">Vert.x</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p></div>
        </div>

        <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
    </div>
<script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script defer src="https://static.cloudflareinsights.com/beacon.min.js/vb26e4fa9e5134444860be286fd8771851679335129114" integrity="sha512-M3hN/6cva/SjwrOtyXeUa5IuCT0sedyfT+jK/OV+s+D0RnzrTfwjwJHhd+wYfMm9HJSrZ1IKksOdddLuN6KOzw==" data-cf-beacon='{"rayId":"7aef6e5d4e4a97e1","version":"2023.3.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }

    hljs.initHighlightingOnLoad()

</script>

</html>
