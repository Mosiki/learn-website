<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>06 除了授权码许可类型，OAuth 2.0还支持什么授权流程？.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <link rel="stylesheet"
              href="../../static/highlight.min.css">
        <script src="../../static/highlight.min.js"></script>
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5295275829820252"
                crossorigin="anonymous"></script>
        <script async defer data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" src="https://analyze.lianglianglee.com/umami.js"></script>
    </head>

<body>

    <div class="book-container">
        <div class="book-sidebar">
            <div class="book-brand">
                <a href="../../index.html">
                    <img src="../../static/favicon.png">
                    <span>技术文章摘抄</span>
                </a>
            </div>
            <div class="book-menu uncollapsible">
                <ul class="uncollapsible">
                    <li><a href="../../index.html" class="current-tab">首页</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li><a href="../index.html">上一级</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li>

                        
                        <a href="00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6OAuth%202.0%EF%BC%9F.md.html">00 开篇词 为什么要学OAuth 2.0？.md</a>

                    </li>
                    <li>

                        
                        <a href="01%20OAuth%202.0%E6%98%AF%E8%A6%81%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F.md.html">01 OAuth 2.0是要通过什么方式解决什么问题？.md</a>

                    </li>
                    <li>

                        
                        <a href="02%20%E6%8E%88%E6%9D%83%E7%A0%81%E8%AE%B8%E5%8F%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E6%9C%89%E6%8E%88%E6%9D%83%E7%A0%81%EF%BC%9F.md.html">02 授权码许可类型中，为什么一定要有授权码？.md</a>

                    </li>
                    <li>

                        
                        <a href="03%20%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%EF%BC%9A%E6%8E%88%E6%9D%83%E7%A0%81%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%E7%9A%84%E9%A2%81%E5%8F%91%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F.md.html">03 授权服务：授权码和访问令牌的颁发流程是怎样的？.md</a>

                    </li>
                    <li>

                        
                        <a href="04%20%E5%9C%A8OAuth%202.0%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8JWT%E7%BB%93%E6%9E%84%E5%8C%96%E4%BB%A4%E7%89%8C%EF%BC%9F.md.html">04 在OAuth 2.0中，如何使用JWT结构化令牌？.md</a>

                    </li>
                    <li>

                        
                        <a href="05%20%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E3%80%81%E5%BF%AB%E9%80%9F%E5%9C%B0%E6%8E%A5%E5%85%A5OAuth%202.0%EF%BC%9F.md.html">05 如何安全、快速地接入OAuth 2.0？.md</a>

                    </li>
                    <li>

                        <a class="current-tab" href="06%20%E9%99%A4%E4%BA%86%E6%8E%88%E6%9D%83%E7%A0%81%E8%AE%B8%E5%8F%AF%E7%B1%BB%E5%9E%8B%EF%BC%8COAuth%202.0%E8%BF%98%E6%94%AF%E6%8C%81%E4%BB%80%E4%B9%88%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B%EF%BC%9F.md.html">06 除了授权码许可类型，OAuth 2.0还支持什么授权流程？.md</a>
                        

                    </li>
                    <li>

                        
                        <a href="07%20%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8App%E4%B8%AD%E4%BD%BF%E7%94%A8OAuth%202.0%EF%BC%9F.md.html">07 如何在移动App中使用OAuth 2.0？.md</a>

                    </li>
                    <li>

                        
                        <a href="08%20%E5%AE%9E%E8%B7%B5OAuth%202.0%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%93%AA%E4%BA%9B%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%EF%BC%9F.md.html">08 实践OAuth 2.0时，使用不当可能会导致哪些安全漏洞？.md</a>

                    </li>
                    <li>

                        
                        <a href="09%20%E5%AE%9E%E6%88%98%EF%BC%9A%E5%88%A9%E7%94%A8OAuth%202.0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAOpenID%20Connect%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%8D%8F%E8%AE%AE..md.html">09 实战：利用OAuth 2.0实现一个OpenID Connect用户身份认证协议..md</a>

                    </li>
                    <li>

                        
                        <a href="10%20%E4%B8%B2%E8%AE%B2%EF%BC%9AOAuth%202.0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.md.html">10 串讲：OAuth 2.0的工作流程与安全问题.md</a>

                    </li>
                    <li>

                        
                        <a href="11%20%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Spring%20Security%E6%90%AD%E5%BB%BA%E4%B8%80%E5%A5%97%E5%9F%BA%E4%BA%8EJWT%E7%9A%84OAuth%202.0%E6%9E%B6%E6%9E%84.md.html">11 实战案例：使用Spring Security搭建一套基于JWT的OAuth 2.0架构.md</a>

                    </li>
                    <li>

                        
                        <a href="12%20%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%9F%BA%E4%BA%8EOAuth%202.0_JWT%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84.md.html">12 架构案例：基于OAuth 2.0_JWT的微服务参考架构.md</a>

                    </li>
                    <li>

                        
                        <a href="13%20%E5%90%84%E5%A4%A7%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8OAuth%202.0%E7%9A%84%EF%BC%9F.md.html">13 各大开放平台是如何使用OAuth 2.0的？.md</a>

                    </li>
                    <li>

                        
                        <a href="14%20%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%9AOAuth%202.0%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%AD%94%E7%96%91.md.html">14 查漏补缺：OAuth 2.0 常见问题答疑.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%BB%93%E6%9D%9F%E8%AF%AD%20%E6%8A%8A%E5%AD%A6%E4%B9%A0%E5%BD%93%E6%88%90%E4%B8%80%E7%A7%8D%E4%B9%A0%E6%83%AF.md.html">结束语 把学习当成一种习惯.md</a>

                    </li>
                </ul>

            </div>
        </div>

        <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
            <div class="sidebar-toggle-inner"></div>
        </div>

        <script>
            function add_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.add('show')
            }

            function remove_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.remove('show')
            }

            function sidebar_toggle() {
                let sidebar_toggle = document.querySelector('.sidebar-toggle')
                let sidebar = document.querySelector('.book-sidebar')
                let content = document.querySelector('.off-canvas-content')
                if (sidebar_toggle.classList.contains('extend')) { // show
                    sidebar_toggle.classList.remove('extend')
                    sidebar.classList.remove('hide')
                    content.classList.remove('extend')
                } else { // hide
                    sidebar_toggle.classList.add('extend')
                    sidebar.classList.add('hide')
                    content.classList.add('extend')
                }
            }


            function open_sidebar() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.add('show')
                overlay.classList.add('show')
            }
            function hide_canvas() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.remove('show')
                overlay.classList.remove('show')
            }

        </script>

        <div class="off-canvas-content">
            <div class="columns">
                <div class="column col-12 col-lg-12">
                    <div class="book-navbar">
                        <!-- For Responsive Layout -->
                        <header class="navbar">
                            <section class="navbar-section">
                                <a onclick="open_sidebar()">
                                    <i class="icon icon-menu"></i>
                                </a>
                            </section>
                        </header>
                    </div>
                    <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                        <div class="book-post">
                            <p id="tip" align="center"></p>
                            <div><h1>06 除了授权码许可类型，OAuth 2.0还支持什么授权流程？</h1>
<p>　　你好，我是王新栋。</p>
<p>　　在前面几讲学习授权码许可类型的原理与工作流程时，不知道你是不是一直有这样一个疑问：授权码许可的流程最完备、最安全没错儿，但它适合所有的授权场景吗？在有些场景下使用授权码许可授权，是不是过于复杂了，是不是根本就没必要这样？</p>
<p>　　比如，小兔打单软件是京东官方开发的一款软件，那么小明在使用小兔的时候，还需要小兔再走一遍授权码许可类型的流程吗？估计你也猜到答案了，肯定是不需要了。</p>
<p>　　你还记得授权码许可流程的特点么？它通过授权码这种临时的中间值，让小明这样的用户参与进来，从而让小兔软件和京东之间建立联系，进而让小兔代表小明去访问他在京东店铺的订单数据。</p>
<p>　　现在小兔被“招安”了，是京东自家的了，是被京东充分信任的，没有“第三方软件”的概念了。同时，小明也是京东店铺的商家，也就是说软件和用户都是京东的资产。这时，显然没有必要再使用授权码许可类型进行授权了。但是呢，小兔依然要通过互联网访问订单数据的 Web API，来提供为小明打单的功能。</p>
<p>　　于是，为了保护这些场景下的 Web API，又为了让 OAuth 2.0 更好地适应现实世界的更多场景，来解决比如上述小兔软件这样的案例，OAuth 2.0 体系中还提供了资源拥有者凭据许可类型。</p>
<h2>资源拥有者凭据许可</h2>
<p>　　从“资源拥有者凭据许可”这个命名上，你可能就已经理解它的含义了。没错，资源拥有者的凭据，就是用户的凭据，就是用户名和密码。可见，这是最糟糕的一种方式。那为什么 OAuth 2.0 还支持这种许可类型，而且编入了 OAuth 2.0 的规范呢？</p>
<p>　　我们先来思考一下。正如上面我提到的，小兔此时就是京东官方出品的一款软件，小明也是京东的用户，那么小明其实是可以使用用户名和密码来直接使用小兔这款软件的。原因很简单，那就是这里不再有“第三方”的概念了。</p>
<p>　　但是呢，如果每次小兔都是拿着小明的用户名和密码来通过调用 Web API 的方式，来访问小明店铺的订单数据，甚至还有商品信息等，在调用这么多 API 的情况下，无疑增加了用户名和密码等敏感信息的攻击面。</p>
<p>　　如果是使用了 token 来代替这些“满天飞”的敏感信息，不就能很大程度上保护敏感信息数据了吗？这样，小兔软件只需要使用一次用户名和密码数据来换回一个 token，进而通过 token 来访问小明店铺的数据，以后就不会再使用用户名和密码了。</p>
<p>　　接下来，我们一起看下这种许可类型的流程，如下图所示：</p>
<p>　　<img src="assets/cd596cfd73a42449a39342f951c5cce9-20220724223100-v655z04.png" alt="" /></p>
<p>　　图1 资源拥有者凭据许可类型的流程</p>
<p>　　步骤 1：当用户访问第三方软件小兔时，会提示输入用户名和密码。索要用户名和密码，就是资源拥有者凭据许可类型的特点。</p>
<p>　　步骤 2：<strong>这里的 grant_type 的值为 password</strong>，告诉授权服务使用资源拥有者凭据许可凭据的方式去请求访问。</p>
<pre><code class="language-java">　　Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
　　params.put(&quot;grant_type&quot;,&quot;password&quot;);
　　params.put(&quot;app_id&quot;,&quot;APPIDTEST&quot;);
　　params.put(&quot;app_secret&quot;,&quot;APPSECRETTEST&quot;);
　　params.put(&quot;name&quot;,&quot;NAMETEST&quot;);
　　params.put(&quot;password&quot;,&quot;PASSWORDTEST&quot;);
　　String accessToken = HttpURLClient.doPost(oauthURl,HttpURLClient.mapToStr(params));
</code></pre>
<p>　　步骤 3：授权服务在验证用户名和密码之后，生成 access_token 的值并返回给第三方软件。</p>
<pre><code class="language-java">　　   if(&quot;password&quot;.equals(grantType)){
　　    String appSecret = request.getParameter(&quot;app_secret&quot;);
　　    String username = request.getParameter(&quot;username&quot;);
　　    String password = request.getParameter(&quot;password&quot;);
　　    if(!&quot;APPSECRETTEST&quot;.equals(appSecret)){
　　        response.getWriter().write(&quot;app_secret is not available&quot;);
　　        return;
　　    }
　　    if(!&quot;USERNAMETEST&quot;.equals(username)){
　　        response.getWriter().write(&quot;username is not available&quot;);
　　        return;
　　    }
　　    if(!&quot;PASSWORDTEST&quot;.equals(password)){
　　        response.getWriter().write(&quot;password is not available&quot;);
　　        return;
　　    }
　　    String accessToken = generateAccessToken(appId,&quot;USERTEST&quot;);
　　    response.getWriter().write(accessToken);
　　}
</code></pre>
<p>　　到了这里，你可以掌握到一个信息：如果软件是官方出品的，又要使用 OAuth 2.0 来保护我们的 Web API，那么你就可以使用小兔软件的做法，采用资源拥有者凭据许可类型。</p>
<p>　　无论是我们的架构、系统还是框架，都是致力于解决现实生产中的各种问题的。除了资源拥有者凭据许可类型外，OAuth 2.0 体系针对现实的环境还提供了客户端凭据许可和隐式许可类型。接下来，让我们继续看看这两种授权许可类型吧。</p>
<h2>客户端凭据许可</h2>
<p>　　如果没有明确的资源拥有者，换句话说就是，小兔软件访问了一个不需要用户小明授权的数据，比如获取京东 LOGO 的图片地址，这个 LOGO 信息不属于任何一个第三方用户，再比如其它类型的第三方软件来访问平台提供的省份信息，省份信息也不属于任何一个第三方用户。</p>
<p>　　此时，在授权流程中，就不再需要资源拥有者这个角色了。当然了，<strong>你也可以形象地理解为 “资源拥有者被塞进了第三方软件中” 或者 “第三方软件就是资源拥有者”</strong>。这种场景下的授权，便是客户端凭据许可，第三方软件可以直接使用注册时的 app_id 和 app_secret 来换回访问令牌 token 的值。</p>
<p>　　我们还是以小明使用小兔软件为例，来看下客户端凭据许可的整个授权流程，如下图所示：</p>
<p>　　<img src="assets/cbc8cc1e03cb1d0a2f945ffd9dbb37ff-20220724223100-xoribn9.png" alt="" /></p>
<p>　　图2 客户端凭据许可授权流程</p>
<p>　　另外一点呢，因为授权过程没有了资源拥有者小明的参与，小兔软件的后端服务可以随时发起 access_token 的请求，所以这种授权许可也不需要刷新令牌。</p>
<p>　　这样一来，客户端凭据许可类型的关键流程，就是以下两大步。</p>
<p>　　步骤 1：第三方软件小兔通过后端服务向授权服务发送请求，<strong>这里 grant_type 的值为 client_credentials</strong>，告诉授权服务要使用第三方软件凭据的方式去请求访问。</p>
<pre><code class="language-java">　　Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
　　params.put(&quot;grant_type&quot;,&quot;client_credentials&quot;);
　　params.put(&quot;app_id&quot;,&quot;APPIDTEST&quot;);
　　params.put(&quot;app_secret&quot;,&quot;APPSECRETTEST&quot;);
　　String accessToken = HttpURLClient.doPost(oauthURl,HttpURLClient.mapToStr(params));
</code></pre>
<p>　　步骤 2：在验证 app_id 和 app_secret 的合法性之后，生成 access_token 的值并返回。</p>
<pre><code class="language-java">　　String grantType = request.getParameter(&quot;grant_type&quot;);
　　String appId = request.getParameter(&quot;app_id&quot;);
　　if(!&quot;APPIDTEST&quot;.equals(appId)){
　　    response.getWriter().write(&quot;app_id is not available&quot;);
　　    return;
　　}
　　if(&quot;client_credentials&quot;.equals(grantType)){
　　    String appSecret = request.getParameter(&quot;app_secret&quot;);
　　    if(!&quot;APPSECRETTEST&quot;.equals(appSecret)){
　　        response.getWriter().write(&quot;app_secret is not available&quot;);
　　        return;
　　    }
　　    String accessToken = generateAccessToken(appId,&quot;USERTEST&quot;);
　　    response.getWriter().write(accessToken);
　　}
</code></pre>
<p>　　到这里，我们再小结下。在获取一种不属于任何一个第三方用户的数据时，并不需要类似小明这样的用户参与，此时便可以使用客户端凭据许可类型。</p>
<p>　　接下来，我们再一起看看今天要讲的最后一种授权许可类型，就是隐式许可类型。</p>
<h2>隐式许可</h2>
<p>　　让我们再想象一下，如果小明使用的小兔打单软件应用没有后端服务，就是在浏览器里面执行的，比如纯粹的 JavaScript 应用，应该如何使用 OAuth 2.0 呢？</p>
<p>　　其实，这种情况下的授权流程就可以使用隐式许可流程，可以理解为第三方软件小兔直接嵌入浏览器中了。</p>
<p>　　在这种情况下，小兔软件对于浏览器就没有任何保密的数据可以隐藏了，也不再需要应用密钥 app_secret 的值了，也不用再通过授权码 code 来换取访问令牌 access_token 的值了。因为使用授权码的目的之一，就是把浏览器和第三方软件的信息做一个隔离，确保浏览器看不到第三方软件最重要的访问令牌 access_token 的值。</p>
<p>　　因此，<strong>隐式许可授权流程的安全性会降低很多</strong>。在授权流程中，没有服务端的小兔软件相当于是嵌入到了浏览器中，访问浏览器的过程相当于接触了小兔软件的全部，因此我用虚线框来表示小兔软件，整个授权流程如下图所示：</p>
<p>　　<img src="assets/c957860d09beb8777c59978f3b9e2yy0-20220724223100-35spt0g.png" alt="" /></p>
<p>　　图3 隐式许可授权流程</p>
<p>　　接下来，我使用 Servlet 的 Get 请求来模拟这个流程，一起看看相关的示例代码。</p>
<p>　　步骤 1：用户通过浏览器访问第三方软件小兔。此时，第三方软件小兔实际上是嵌入浏览器中执行的应用程序。</p>
<p>　　步骤 2：这个流程和授权码流程类似，只是需要特别注意一点，<strong>response_type 的值变成了 token</strong>，是要告诉授权服务直接返回 access_token 的值。随着我们后续的讲解，你会发现隐式许可流程是唯一在前端通信中要求返回 access_token 的流程。对，就这么 “大胆”，但 “不安全”。</p>
<pre><code class="language-java">　　Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
　　params.put(&quot;response_type&quot;,&quot;token&quot;);
　　params.put(&quot;redirect_uri&quot;,&quot;http://localhost:8080/AppServlet-ch02&quot;);
　　params.put(&quot;app_id&quot;,&quot;APPIDTEST&quot;);
　　String toOauthUrl = URLParamsUtil.appendParams(oauthUrl,params);
　　response.sendRedirect(toOauthUrl);
</code></pre>
<p>　　步骤 3：生成 acccess_token 的值，通过前端通信返回给第三方软件小兔。</p>
<pre><code class="language-java">　　String responseType = request.getParameter(&quot;response_type&quot;);
　　String redirectUri =request.getParameter(&quot;redirect_uri&quot;);
　　String appId = request.getParameter(&quot;app_id&quot;);
　　if(!&quot;APPIDTEST&quot;.equals(appId)){
　　    return;
　　}
　　if(&quot;token&quot;.equals(responseType)){
　　    String accessToken = generateAccessToken(appId,&quot;USERTEST&quot;);
　　    Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
　　    params.put(&quot;redirect_uri&quot;,redirectUri);
　　    params.put(&quot;access_token&quot;,accessToken);
　　    String toAppUrl = URLParamsUtil.appendParams(redirectUri,params);
　　    response.sendRedirect(toAppUrl);
　　}
</code></pre>
<p>　　如果你的软件就是直接嵌入到了浏览器中运行，而且还没有服务端的参与，并且还想使用 OAuth 2.0 流程的话，也就是像上面我说的小兔这个例子，那么便可以直接使用隐式许可类型了。</p>
<h2>如何选择？</h2>
<p>　　现在，我们已经理解了 OAuth 2.0 的 4 种授权许可类型的原理与流程。那么，我们应该如何选择到底使用哪种授权许可类型呢？</p>
<p>　　这里，我给你的建议是，在对接 OAuth 2.0 的时候先考虑授权码许可类型，其次再结合现实生产环境来选择：</p>
<p>　　如果小兔软件是官方出品，那么可以直接使用资源拥有者凭据许可；</p>
<p>　　如果小兔软件就是只嵌入到浏览器端的应用且没有服务端，那就只能选择隐式许可；</p>
<p>　　如果小兔软件获取的信息不属于任何一个第三方用户，那可以直接使用客户端凭据许可类型。</p>
<h2>总结</h2>
<p>　　好了，我们马上要结束这篇文章了，在这之前呢，我们一直讲的是授权码许可类型，你已经知道了这是一种流程最完备、安全性最高的授权许可流程。不过呢，现实世界总是有各种各样的变化，OAuth 2.0 也要适应这样的变化，所以才有了我们今天讲的另外这三种许可类型。同时，关于如何来选择使用这些许可类型，我前面也给了大家一个建议。</p>
<p>　　加上前面我们讲的授权码许可类型，我们一共讲了 4 种授权许可类型，它们最显著的区别就是<strong>获取访问令牌 access_token 的方式不同</strong>。最后，我通过一张表格来对比下：</p>
<p>　　<img src="assets/3ee0ceff6c543157a51aae985756454d-20220724223100-51vactp.jpg" alt="" /></p>
<p>　　图4 OAuth 2.0的4种授权许可类型对比</p>
<p>　　除了上面这张表格所展现的 4 种授权许可类型的区别之外，我希望你还能记住以下两点。</p>
<p>　　所有的授权许可类型中，授权码许可类型的安全性是最高的。因此，只要具备使用授权码许可类型的条件，我们一定要首先授权码许可类型。</p>
<p>　　所有的授权许可类型都是为了解决现实中的实际问题，因此我们还要结合实际的生产环境，在保障安全性的前提下选择最合适的授权许可类型，比如使用客户端凭据许可类型的小兔软件就是一个案例。</p>
<p>　　我把今天用到的代码放到了 GitHub 上，你可以点击<a href="https://github.com/xindongbook/oauth2-code">这个链接</a>查看。</p>
<h2>思考题</h2>
<p>　　如果受限于应用特性所在的环境，比如在没有浏览器参与的情况下，我们应该如何选择授权许可类型呢，还可以使用授权码许可流程吗？</p>
<p>　　欢迎你在留言区分享你的观点，也欢迎你把今天的内容分享给其他朋友，我们一起交流。</p>
</div>
                        </div>
                        <div>
                            <div style="float: left">
                                <a href="05%20%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E3%80%81%E5%BF%AB%E9%80%9F%E5%9C%B0%E6%8E%A5%E5%85%A5OAuth%202.0%EF%BC%9F.md.html">上一页</a>
                            </div>
                            <div style="float: right">
                                <a href="07%20%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8App%E4%B8%AD%E4%BD%BF%E7%94%A8OAuth%202.0%EF%BC%9F.md.html">下一页</a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="copyright"><p>© 2019 - 2023 <a href="../../cdn-cgi/l/email-protection.html#402c2c2c79747171707700272d21292c6e232f2d" target="_blank">Liangliang Lee</a>. Powered by <a href="https://vertx.io/" target="_blank">Vert.x</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p></div>
        </div>

        <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
    </div>
<script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script defer src="https://static.cloudflareinsights.com/beacon.min.js/vb26e4fa9e5134444860be286fd8771851679335129114" integrity="sha512-M3hN/6cva/SjwrOtyXeUa5IuCT0sedyfT+jK/OV+s+D0RnzrTfwjwJHhd+wYfMm9HJSrZ1IKksOdddLuN6KOzw==" data-cf-beacon='{"rayId":"7aefb320bb3fce8c","version":"2023.3.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }

    hljs.initHighlightingOnLoad()

</script>

</html>
