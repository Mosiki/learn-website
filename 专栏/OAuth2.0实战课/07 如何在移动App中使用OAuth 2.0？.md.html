<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>07 如何在移动App中使用OAuth 2.0？.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <link rel="stylesheet"
              href="../../static/highlight.min.css">
        <script src="../../static/highlight.min.js"></script>
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5295275829820252"
                crossorigin="anonymous"></script>
        <script async defer data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" src="https://analyze.lianglianglee.com/umami.js"></script>
    </head>

<body>

    <div class="book-container">
        <div class="book-sidebar">
            <div class="book-brand">
                <a href="../../index.html">
                    <img src="../../static/favicon.png">
                    <span>技术文章摘抄</span>
                </a>
            </div>
            <div class="book-menu uncollapsible">
                <ul class="uncollapsible">
                    <li><a href="../../index.html" class="current-tab">首页</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li><a href="../index.html">上一级</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li>

                        
                        <a href="00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6OAuth%202.0%EF%BC%9F.md.html">00 开篇词 为什么要学OAuth 2.0？.md</a>

                    </li>
                    <li>

                        
                        <a href="01%20OAuth%202.0%E6%98%AF%E8%A6%81%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F.md.html">01 OAuth 2.0是要通过什么方式解决什么问题？.md</a>

                    </li>
                    <li>

                        
                        <a href="02%20%E6%8E%88%E6%9D%83%E7%A0%81%E8%AE%B8%E5%8F%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E6%9C%89%E6%8E%88%E6%9D%83%E7%A0%81%EF%BC%9F.md.html">02 授权码许可类型中，为什么一定要有授权码？.md</a>

                    </li>
                    <li>

                        
                        <a href="03%20%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%EF%BC%9A%E6%8E%88%E6%9D%83%E7%A0%81%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%E7%9A%84%E9%A2%81%E5%8F%91%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F.md.html">03 授权服务：授权码和访问令牌的颁发流程是怎样的？.md</a>

                    </li>
                    <li>

                        
                        <a href="04%20%E5%9C%A8OAuth%202.0%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8JWT%E7%BB%93%E6%9E%84%E5%8C%96%E4%BB%A4%E7%89%8C%EF%BC%9F.md.html">04 在OAuth 2.0中，如何使用JWT结构化令牌？.md</a>

                    </li>
                    <li>

                        
                        <a href="05%20%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E3%80%81%E5%BF%AB%E9%80%9F%E5%9C%B0%E6%8E%A5%E5%85%A5OAuth%202.0%EF%BC%9F.md.html">05 如何安全、快速地接入OAuth 2.0？.md</a>

                    </li>
                    <li>

                        
                        <a href="06%20%E9%99%A4%E4%BA%86%E6%8E%88%E6%9D%83%E7%A0%81%E8%AE%B8%E5%8F%AF%E7%B1%BB%E5%9E%8B%EF%BC%8COAuth%202.0%E8%BF%98%E6%94%AF%E6%8C%81%E4%BB%80%E4%B9%88%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B%EF%BC%9F.md.html">06 除了授权码许可类型，OAuth 2.0还支持什么授权流程？.md</a>

                    </li>
                    <li>

                        <a class="current-tab" href="07%20%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8App%E4%B8%AD%E4%BD%BF%E7%94%A8OAuth%202.0%EF%BC%9F.md.html">07 如何在移动App中使用OAuth 2.0？.md</a>
                        

                    </li>
                    <li>

                        
                        <a href="08%20%E5%AE%9E%E8%B7%B5OAuth%202.0%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%93%AA%E4%BA%9B%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%EF%BC%9F.md.html">08 实践OAuth 2.0时，使用不当可能会导致哪些安全漏洞？.md</a>

                    </li>
                    <li>

                        
                        <a href="09%20%E5%AE%9E%E6%88%98%EF%BC%9A%E5%88%A9%E7%94%A8OAuth%202.0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAOpenID%20Connect%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%8D%8F%E8%AE%AE..md.html">09 实战：利用OAuth 2.0实现一个OpenID Connect用户身份认证协议..md</a>

                    </li>
                    <li>

                        
                        <a href="10%20%E4%B8%B2%E8%AE%B2%EF%BC%9AOAuth%202.0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.md.html">10 串讲：OAuth 2.0的工作流程与安全问题.md</a>

                    </li>
                    <li>

                        
                        <a href="11%20%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Spring%20Security%E6%90%AD%E5%BB%BA%E4%B8%80%E5%A5%97%E5%9F%BA%E4%BA%8EJWT%E7%9A%84OAuth%202.0%E6%9E%B6%E6%9E%84.md.html">11 实战案例：使用Spring Security搭建一套基于JWT的OAuth 2.0架构.md</a>

                    </li>
                    <li>

                        
                        <a href="12%20%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%9F%BA%E4%BA%8EOAuth%202.0_JWT%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84.md.html">12 架构案例：基于OAuth 2.0_JWT的微服务参考架构.md</a>

                    </li>
                    <li>

                        
                        <a href="13%20%E5%90%84%E5%A4%A7%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8OAuth%202.0%E7%9A%84%EF%BC%9F.md.html">13 各大开放平台是如何使用OAuth 2.0的？.md</a>

                    </li>
                    <li>

                        
                        <a href="14%20%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%9AOAuth%202.0%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%AD%94%E7%96%91.md.html">14 查漏补缺：OAuth 2.0 常见问题答疑.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%BB%93%E6%9D%9F%E8%AF%AD%20%E6%8A%8A%E5%AD%A6%E4%B9%A0%E5%BD%93%E6%88%90%E4%B8%80%E7%A7%8D%E4%B9%A0%E6%83%AF.md.html">结束语 把学习当成一种习惯.md</a>

                    </li>
                </ul>

            </div>
        </div>

        <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
            <div class="sidebar-toggle-inner"></div>
        </div>

        <script>
            function add_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.add('show')
            }

            function remove_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.remove('show')
            }

            function sidebar_toggle() {
                let sidebar_toggle = document.querySelector('.sidebar-toggle')
                let sidebar = document.querySelector('.book-sidebar')
                let content = document.querySelector('.off-canvas-content')
                if (sidebar_toggle.classList.contains('extend')) { // show
                    sidebar_toggle.classList.remove('extend')
                    sidebar.classList.remove('hide')
                    content.classList.remove('extend')
                } else { // hide
                    sidebar_toggle.classList.add('extend')
                    sidebar.classList.add('hide')
                    content.classList.add('extend')
                }
            }


            function open_sidebar() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.add('show')
                overlay.classList.add('show')
            }
            function hide_canvas() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.remove('show')
                overlay.classList.remove('show')
            }

        </script>

        <div class="off-canvas-content">
            <div class="columns">
                <div class="column col-12 col-lg-12">
                    <div class="book-navbar">
                        <!-- For Responsive Layout -->
                        <header class="navbar">
                            <section class="navbar-section">
                                <a onclick="open_sidebar()">
                                    <i class="icon icon-menu"></i>
                                </a>
                            </section>
                        </header>
                    </div>
                    <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                        <div class="book-post">
                            <p id="tip" align="center"></p>
                            <div><h1>07 如何在移动App中使用OAuth 2.0？</h1>
<p>　　你好，我是王新栋。</p>
<p>　　在前面几讲中，我都是基于 Web 应用的场景来讲解的 OAuth 2.0。除了 Web 应用外，现实环境中还有非常多的移动 App。那么，在移动 App 中，能不能使用 OAuth 2.0 ，又该如何使用 OAuth 2.0 呢？</p>
<p>　　没错，OAuth 2.0 最初的应用场景确实是 Web 应用，但是它的伟大之处就在于，它把自己的核心协议定位成了一个框架而不是单个的协议。这样做的好处是，我们可以基于这个基本的框架协议，在一些特定的领域进行扩展。</p>
<p>　　因此，到了桌面或者移动的场景下，OAuth 2.0 的协议一样适用。考虑到授权码许可是最完备、最安全的许可类型，所以我在讲移动 App 如何使用 OAuth 2.0 的时候，依然会用授权码许可来讲解，毕竟“要用就用最好的”。</p>
<p>　　当我们开发一款移动 App 的时候，可以选择没有 Server 端的 “纯 App” 架构，比如这款 App 不需要跟自己的 Server 端通信，或者可以调用其它开放的 HTTP 接口；当然也可以选择有服务端的架构，比如这款 App 还想把用户的操作日志记录下来并保存到 Server 端的数据库中。</p>
<p>　　那总结下来呢，移动 App 可以分为两类，一类是没有 Server 端的 App 应用，一类是有 Server 端的 App 应用。</p>
<p>　　<img src="assets/4c034e019467aafae511f16055b57b99-20220724223141-dtfvaa2.png" alt="" /></p>
<p>　　图1 两类移动App</p>
<p>　　这两类 App 在使用 OAuth 2.0 时的最大区别，在于获取访问令牌的方式：</p>
<p>　　如果有 Server 端，就建议通过 Server 端和授权服务做交互来换取访问令牌；</p>
<p>　　如果没有 Server 端，那么只能通过前端通信来跟授权服务做交互，比如在上一讲中提到的隐式许可授权类型。当然，这种方式的安全性就降低了很多。</p>
<p>　　有些时候，我们可能觉得自己开发一个 App 不需要一个 Server 端。那好，就让我们先来看看没有 Server 端的 App 应用如何使用授权码许可类型。</p>
<h2>没有 Server 端的 App</h2>
<p>　　在一个没有 Server 端支持的纯 App 应用中，我们首先想到的是，如何可以像 Web 服务那样，让请求和响应“来去自如”呢。</p>
<p>　　你可能会想，我是不是可以将一个“迷你”的 Web 服务器嵌入到 App 里面去，这样不就可以像 Web 应用那样来使用 OAuth 2.0 了么？确实，这是行得通的，而且已经有 App 这样做了。</p>
<p>　　这样的 App 通过监听运行在 localhost 上的 Web 服务器 URI，就可以做到跟普通的 Web 应用一样的通信机制。但这种方式不是我们这次要讲的重点，如果你想深入了解可以去查些资料。因为当使用这种方式的时候，请求访问令牌时需要的 app_secret 就只能保存在用户本地设备上，而这并不是我们所建议的。</p>
<p>　　到这里，你应该猜到了，问题的关键在于如何保存 app_secret，因为 App 会被安装在成千上万个终端设备上，app_secret 一旦被破解，就将会造成灾难性的后果。这时，有的同学突发奇想，如果不用 app_secret，也能在授权码流程里换回访问令牌 access_token，不就可以了吗？</p>
<p>　　确实可以，但新的问题也来了。在授权码许可类型的流程中，如果没有了 app_secret 这一层的保护，那么通过授权码 code 换取访问令牌的时候，就只有授权码 code 在“冲锋陷阵”了。这时，授权码 code 一旦失窃，就会带来严重的安全问题。那么，我既不使用 app_secret，还要防止授权码 code 失窃，有什么好的方法吗？</p>
<p>　　有，OAuth 2.0 里面就有这样的指导方法。这个方法就是我们将要介绍的 PKCE 协议，全称是 Proof Key for Code Exchange by OAuth Public Clients。</p>
<p>　　在下面的流程图中，为了突出第三方软件使用 PKCE 协议时与授权服务之间的通信过程，我省略了受保护资源服务和资源拥有者的角色：</p>
<p>　　<img src="assets/66648bff2d955b3d714ce597299fbf52-20220724223141-ucv15u5.png" alt="" /></p>
<p>　　图2 使用PKCE协议的流程图</p>
<p>　　我来和你分析下这个流程中的重点。</p>
<p>　　首先，App 自己要生成一个随机的、长度在 43~128 字符之间的、参数为 <strong>code_verifier</strong> 的字符串验证码；接着，我们再利用这个 <strong>code_verifier，<strong><strong>来生成一个被称为“挑战码”的参数</strong></strong>code_challenge</strong>。</p>
<p>　　那怎么生成这个 code_challenge 的值呢？OAuth 2.0 规范里面给出了两种方法，就是看 code_challenge_method 这个参数的值：</p>
<p>　　一种 code_challenge_method=plain，此时 code_verifier 的值就是 code_challenge 的值；</p>
<p>　　另外一种 code_challenge_method=S256，就是将 code_verifier 值进行 ASCII 编码之后再进行哈希，然后再将哈希之后的值进行 BASE64-URL 编码，如下代码所示。</p>
<pre><code class="language-java">　　code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))
</code></pre>
<p>　　好了，我知道有这样两个值，也知道它们的生成方法了，但这两个值跟我们的授权码流程有什么关系呢，又怎么利用它们呢？不用着急，我们接着讲。</p>
<p>　　授权码流程简单概括起来不是有两步吗，第一步是获取授权码 code，第二步是用 app_id+app_secret+code 获取访问令牌 access_token。刚才我们的“梦想”不是设想不使用 app_secret，但同时又能保证授权码流程的安全性么？</p>
<p>　　没错。code_verifier 和 code_challenge 这两个参数，就是来帮我们实现这个“梦想”的。</p>
<p>　　在<strong>第一步获取授权码 code 的时候，我们使用 code_challenge</strong> 参数。需要注意的是，我们要同时将 code_challenge_method 参数也传过去，目的是让授权服务知道生成 code_challenge 值的方法是 plain 还是 S256。</p>
<pre><code class="language-java">　　https:
　　response_type=code&amp;
　　app_id=APP_ID&amp;
　　redirect_uri=REDIRECT_URI&amp;
　　code_challenge=CODE_CHALLENGE&amp;
　　code_challenge_method=S256
</code></pre>
<p>　　在<strong>第二步获取访问令牌的时候，我们使用 code_verifier 参数</strong>，授权服务此时会将 code_verifier 的值进行一次运算。那怎么运算呢？就是上面 code_challenge_method=S256 的这种方式。</p>
<p>　　没错，第一步请求授权码的时候，已经告诉授权服务生成 code_challenge 的方法了。所以，在第二步的过程中，授权服务将运算的值跟第一步接收到的值做比较，如果相同就颁发访问令牌。</p>
<pre><code class="language-java">　　  POST https:
　　  grant_type=authorization_code&amp;
　　  code=AUTH_CODE_HERE&amp;
　　  redirect_uri=REDIRECT_URI&amp;
　　  app_id=APP_ID&amp;
　　  code_verifier=CODE_VERIFIER
</code></pre>
<p>　　现在，你就知道了我们是如何使用 code_verifier 和 code_challenge 这两个参数的了吧。总结一下就是，换取授权码 code 的时候，我们使用 code_challenge 参数值；换取访问令牌的时候，我们使用 code_verifier 参数值。那么，有的同学会继续问了，我们为什么要这样做呢。</p>
<p>　　现在，就让我来和你分析一下。</p>
<p>　　我们的愿望是，没有 Server 端的手机 App，也可以使用授权码许可流程，对吧？app_secret 不能用，因为它只能被存在用户的设备上，我们担心被泄露。</p>
<p>　　那么，在没有了 app_secret 这层保护的前提下，即使我们的授权码 code 被截获，再加上 code_challenge 也同时被截获了，那也没有办法由 code_challenge 逆推出 code_verifier 的值。而恰恰在第二步换取访问令牌的时候，授权服务需要的就是 code_verifier 的值。因此，这也就避免了访问令牌被恶意换取的安全问题。</p>
<p>　　现在，我们可以通过 PKCE 协议的帮助，让没有 Server 端的 App 也能够安全地使用授权码许可类型进行授权了。但是，按照 OAuth 2.0 的规范建议，通过后端通信来换取访问令牌是较为安全的方式。所以呢，在这里，我想跟你探讨的是，我们真的不需要一个 Server 端吗？在做移动应用开发的时候，我们真的从设计上就决定废弃 Server 端了吗？</p>
<h2>有 Server 端的 App</h2>
<p>　　如果你开发接入过微信登录，就会在微信的官方文档上看到下面这句话：</p>
<p>　　微信 OAuth 2.0 授权登录目前支持 authorization_code 模式，适用于拥有 Server 端的应用授权。</p>
<p>　　没错，微信的 OAuth 2.0 授权登录，就是建议我们需要一个 Server 端来支持这样的授权接入。</p>
<p>　　那么，有 Server 端支持的 App 又是如何使用 OAuth 2.0 的授权码许可流程的呢？其实，在前面几讲的基础上，我们现在理解这样的场景并不是什么难事儿。</p>
<p>　　<img src="assets/86d3yy8fa419c94b7e3766fe0a4e3db1-20220724223142-ki4vf5f.png" alt="" /></p>
<p>　　图3 微信登录流程图</p>
<p>　　看到这个图，你是不是觉得特别熟悉，跟普通的授权码流程没有区别，仍是两步走的策略：第一步换取授权码 code，第二步通过授权码 code 换取访问令牌 access_token。</p>
<p>　　这里的第三方应用，就是我们作为开发者来开发的应用，包含了移动 App 和 Server 端。我们将其“放大”得到下面这张图：</p>
<p>　　<img src="assets/564f5b7af360180d270e205df5f9c05e-20220724223141-70tfqai.png" alt="" /></p>
<p>　　图4 有Server端的App的授权流程</p>
<p>　　我们从这张“放大”的图中，就会发现有 Server 端的 App 在使用授权码流程的时候，跟普通的 Web 应用几乎没有任何差别。</p>
<p>　　大概流程是：当我们访问第三方 App 的时候，需要用到微信来登录；第三方 App 可以拉起微信的 App，我们会在微信的 App 里面进行登录及授权；微信 Server 端验证成功之后会返回一个授权码 code，通过微信 App 传递给了第三方 App；后面的流程就是我们熟悉的使用授权码 code 和 app_secret，换取访问令牌 access_token 的值了。</p>
<p>　　这次使用 app_secret 的时候，我们是在第三方 App 的 Server 端来使用的，因此安全性上没有任何问题。</p>
<h2>总结</h2>
<p>　　今天这一讲，我重点和你讲了两块内容，没有 Server 端的 App 和有 Server 端的 App 分别是如何使用授权码许可类型的。我希望你能够记住以下两点内容。</p>
<p>　　我们使用 OAuth 2.0 协议的目的，就是要起到安全性的作用，但有些时候，因为使用不当反而会造成更大的安全问题，比如将 app_secret 放入 App 中的最基本错误。如果放弃了 app_secret，又是如何让没有 Server 端的 App 安全地使用授权码许可协议呢？针对这种情况，我和你介绍了 PKCE 协议。它是一种在失去 app_secret 保护的时候，防止授权码失窃的解决方案。</p>
<p>　　我们需要思考一下，我们的 App 真的不需要一个 Server 端吗？我建议你在开发移动 App 的时候，尽可能地都要搭建一个 Server 端，因为通过后端通信来传输访问令牌比通过前端通信传输要安全得多。我也举了微信的例子，很多官方的开放平台在提供 OAuth 2.0 服务的时候，都会建议开发者要有一个相应的 Server 端。</p>
<p>　　那么，关于 OAuth 2.0 的使用还有哪些安全方面的防范措施是我们要注意的呢，接下来的一讲中我们会重点跟大家介绍。</p>
<h2>思考题</h2>
<p>　　在移动 App 中，你还能想到有哪些相对安全的方式来使用 OAuth 2.0 吗？</p>
<p>　　欢迎你在留言区分享你的观点，也欢迎你把今天的内容分享给其他朋友，我们一起交流。</p>
</div>
                        </div>
                        <div>
                            <div style="float: left">
                                <a href="06%20%E9%99%A4%E4%BA%86%E6%8E%88%E6%9D%83%E7%A0%81%E8%AE%B8%E5%8F%AF%E7%B1%BB%E5%9E%8B%EF%BC%8COAuth%202.0%E8%BF%98%E6%94%AF%E6%8C%81%E4%BB%80%E4%B9%88%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B%EF%BC%9F.md.html">上一页</a>
                            </div>
                            <div style="float: right">
                                <a href="08%20%E5%AE%9E%E8%B7%B5OAuth%202.0%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%93%AA%E4%BA%9B%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%EF%BC%9F.md.html">下一页</a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="copyright"><p>© 2019 - 2023 <a href="../../cdn-cgi/l/email-protection.html#adc1c1c194999c9c9d9aedcac0ccc4c183cec2c0" target="_blank">Liangliang Lee</a>. Powered by <a href="https://vertx.io/" target="_blank">Vert.x</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p></div>
        </div>

        <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
    </div>
<script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script defer src="https://static.cloudflareinsights.com/beacon.min.js/vb26e4fa9e5134444860be286fd8771851679335129114" integrity="sha512-M3hN/6cva/SjwrOtyXeUa5IuCT0sedyfT+jK/OV+s+D0RnzrTfwjwJHhd+wYfMm9HJSrZ1IKksOdddLuN6KOzw==" data-cf-beacon='{"rayId":"7aefb322df81ce8c","version":"2023.3.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }

    hljs.initHighlightingOnLoad()

</script>

</html>
