<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>18 案例：如何排查RocketMQ消息发送超时故障？.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <link rel="stylesheet"
              href="../../static/highlight.min.css">
        <script src="../../static/highlight.min.js"></script>
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5295275829820252"
                crossorigin="anonymous"></script>
        <script async defer data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" src="https://analyze.lianglianglee.com/umami.js"></script>
    </head>

<body>

    <div class="book-container">
        <div class="book-sidebar">
            <div class="book-brand">
                <a href="../../index.html">
                    <img src="../../static/favicon.png">
                    <span>技术文章摘抄</span>
                </a>
            </div>
            <div class="book-menu uncollapsible">
                <ul class="uncollapsible">
                    <li><a href="../../index.html" class="current-tab">首页</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li><a href="../index.html">上一级</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li>

                        
                        <a href="00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB%E6%9D%A5%E8%AF%B4%E8%BF%99%E4%B9%88%E9%87%8D%E8%A6%81%EF%BC%9F.md.html">00 开篇词 为什么中间件对分布式架构体系来说这么重要？.md</a>

                    </li>
                    <li>

                        
                        <a href="01%20%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%94%9F%E6%80%81%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F.md.html">01 中间件生态（上）：有哪些类型的中间件？.md</a>

                    </li>
                    <li>

                        
                        <a href="02%20%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%94%9F%E6%80%81%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%89%E5%9E%8B%EF%BC%9F.md.html">02 中间件生态（下）：同类型的中间件如何进行选型？.md</a>

                    </li>
                    <li>

                        
                        <a href="03%20%20%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%9F%B3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F.md.html">03  数组与链表：存储设计的基石有哪些？.md</a>

                    </li>
                    <li>

                        
                        <a href="04%20%20%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9A%E5%9B%BE%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.md.html">04  红黑树：图解红黑树的构造过程与应用场景.md</a>

                    </li>
                    <li>

                        
                        <a href="05%20%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F.md.html">05  多线程：多线程编程有哪些常见的设计模式？.md</a>

                    </li>
                    <li>

                        
                        <a href="06%20%20%E9%94%81%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%94%81%E7%9A%84%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B8%8E%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97%EF%BC%9F.md.html">06  锁：如何理解锁的同步阻塞队列与条件队列？.md</a>

                    </li>
                    <li>

                        
                        <a href="07%20%20NIO%EF%BC%9A%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%9AReactor%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.md.html">07  NIO：手撸一个简易的主从多Reactor线程模型.md</a>

                    </li>
                    <li>

                        
                        <a href="08%20%20Netty%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%BB%E5%86%99%EF%BC%8C%E5%88%B6%E5%AE%9A%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%9F.md.html">08  Netty：如何优雅地处理网络读写，制定网络通信协议？.md</a>

                    </li>
                    <li>

                        
                        <a href="08%20%E5%8A%A0%E9%A4%90%20%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BA%95%E5%B1%82%E7%9A%84%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5.md.html">08 加餐 中间件底层的通用设计理念.md</a>

                    </li>
                    <li>

                        
                        <a href="09%20%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E5%92%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%9F.md.html">09 技术选型：如何选择微服务框架和注册中心？.md</a>

                    </li>
                    <li>

                        
                        <a href="10%20%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9ADubbo%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.md.html">10 设计原理：Dubbo核心设计原理剖析.md</a>

                    </li>
                    <li>

                        
                        <a href="11%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8EDubbo%E8%BF%9B%E8%A1%8C%E7%BD%91%E5%85%B3%E8%AE%BE%E8%AE%A1%EF%BC%9F.md.html">11 案例：如何基于Dubbo进行网关设计？.md</a>

                    </li>
                    <li>

                        
                        <a href="12%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83%EF%BC%9F.md.html">12 案例：如何实现蓝绿发布？.md</a>

                    </li>
                    <li>

                        
                        <a href="13%20%20%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F.md.html">13  技术选型：如何根据应用场景选择合适的消息中间件？.md</a>

                    </li>
                    <li>

                        
                        <a href="14%20%20%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93%EF%BC%9ARocketMQ%E4%B8%8EKafka%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%AF%B9%E6%AF%94.md.html">14  性能之道：RocketMQ与Kafka高性能设计对比.md</a>

                    </li>
                    <li>

                        
                        <a href="15%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%93%9D%E7%BB%BF%EF%BC%9F.md.html">15 案例：消息中间件如何实现蓝绿？.md</a>

                    </li>
                    <li>

                        
                        <a href="16%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87RocketMQ%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E6%80%A7%E8%83%BD%EF%BC%9F.md.html">16 案例：如何提升RocketMQ顺序消费性能？.md</a>

                    </li>
                    <li>

                        
                        <a href="17%20%E8%BF%90%E7%BB%B4%EF%BC%9A%E5%A6%82%E4%BD%95%E8%BF%90%E7%BB%B4%E6%97%A5%E5%9D%87%E4%BA%BF%E7%BA%A7%E7%9A%84%E6%B6%88%E6%81%AF%E9%9B%86%E7%BE%A4%EF%BC%9F.md.html">17 运维：如何运维日均亿级的消息集群？.md</a>

                    </li>
                    <li>

                        <a class="current-tab" href="18%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5RocketMQ%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E8%B6%85%E6%97%B6%E6%95%85%E9%9A%9C%EF%BC%9F.md.html">18 案例：如何排查RocketMQ消息发送超时故障？.md</a>
                        

                    </li>
                    <li>

                        
                        <a href="19%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5RocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E7%A7%AF%E5%8E%8B%E9%97%AE%E9%A2%98%EF%BC%9F.md.html">19 案例：如何排查RocketMQ消息消费积压问题？.md</a>

                    </li>
                    <li>

                        
                        <a href="20%20%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E6%9C%AA%E6%9D%A5.md.html">20 技术选型：分布式定时调度框架的功能和未来.md</a>

                    </li>
                    <li>

                        
                        <a href="21%20%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8EZooKeeper%E8%AE%BE%E8%AE%A1%E5%87%86%E5%AE%9E%E6%97%B6%E6%9E%B6%E6%9E%84%EF%BC%9F.md.html">21 设计理念：如何基于ZooKeeper设计准实时架构？.md</a>

                    </li>
                    <li>

                        
                        <a href="22%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E8%AF%A5%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F.md.html">22 案例：使用分布式调度框架该考虑哪些问题？.md</a>

                    </li>
                    <li>

                        
                        <a href="23%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%BF%9B%E8%A1%8C%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%EF%BC%9F.md.html">23 案例：如何在生产环境进行全链路压测？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%A4%A7%E5%92%96%E5%8A%A9%E9%98%B5%20%20%E9%AB%98%E6%A5%BC%EF%BC%9A%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F.md.html">大咖助阵  高楼：我们应该如何学习中间件？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%20%20%E5%AD%A6%E8%80%8C%E6%97%B6%E4%B9%A0%E4%B9%8B%EF%BC%8C%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E.md.html">用户故事  学而时习之，不亦乐乎.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%20%20%E6%84%BF%E5%81%9A%E6%8A%80%E6%9C%AF%E7%9A%84%E8%BF%BD%E6%A2%A6%E4%BA%BA.md.html">用户故事  愿做技术的追梦人.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%20%20%E6%B5%AA%E8%B4%B9%E6%97%B6%E9%97%B4%E4%B9%9F%E6%98%AF%E4%B8%BA%E4%BA%86%E7%8F%8D%E6%83%9C%E6%97%B6%E9%97%B4.md.html">用户故事  浪费时间也是为了珍惜时间.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%BB%93%E6%9D%9F%E8%AF%AD%20%E5%9D%9A%E6%8C%81%E4%B8%8D%E6%87%88%EF%BC%8C%E8%B6%8A%E5%8A%AA%E5%8A%9B%E8%B6%8A%E5%B9%B8%E8%BF%90.md.html">结束语 坚持不懈，越努力越幸运.md</a>

                    </li>
                </ul>

            </div>
        </div>

        <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
            <div class="sidebar-toggle-inner"></div>
        </div>

        <script>
            function add_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.add('show')
            }

            function remove_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.remove('show')
            }

            function sidebar_toggle() {
                let sidebar_toggle = document.querySelector('.sidebar-toggle')
                let sidebar = document.querySelector('.book-sidebar')
                let content = document.querySelector('.off-canvas-content')
                if (sidebar_toggle.classList.contains('extend')) { // show
                    sidebar_toggle.classList.remove('extend')
                    sidebar.classList.remove('hide')
                    content.classList.remove('extend')
                } else { // hide
                    sidebar_toggle.classList.add('extend')
                    sidebar.classList.add('hide')
                    content.classList.add('extend')
                }
            }


            function open_sidebar() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.add('show')
                overlay.classList.add('show')
            }
            function hide_canvas() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.remove('show')
                overlay.classList.remove('show')
            }

        </script>

        <div class="off-canvas-content">
            <div class="columns">
                <div class="column col-12 col-lg-12">
                    <div class="book-navbar">
                        <!-- For Responsive Layout -->
                        <header class="navbar">
                            <section class="navbar-section">
                                <a onclick="open_sidebar()">
                                    <i class="icon icon-menu"></i>
                                </a>
                            </section>
                        </header>
                    </div>
                    <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                        <div class="book-post">
                            <p id="tip" align="center"></p>
                            <div><h1>18 案例：如何排查RocketMQ消息发送超时故障？</h1>
<p>你好，我是丁威。</p>
<p>不知道你在使用 RocketMQ 的时候有没有遇到过让人有些头疼的问题。我在用 RocketMQ 时遇到的最常见，也最让我头疼的问题就是**消息发送超时。**而且这种超时不是大面积的，而是偶尔会发生，占比在万分之一到万分之五之间。</p>
<h2>现象与关键日志</h2>
<p>消息发送超时的情况下，客户端的日志通常是下面这样：</p>
<p><img src="assets/9742c5e7e8ec8d1aebdc5f76b2a8c2b3-20220924201105-4ns9enx.png" alt="" /></p>
<p>我们这节课就从这些日志入手，看看怎样排查 RocketMQ 的消息发送超时故障。</p>
<p>首先，我们要查看 RocketMQ 相关的日志，在应用服务器上，RocketMQ 的日志默认路径为 ${USER_HOME}/logs/rocketmqlogs/ rocketmq_client.log。</p>
<p>在上面这张图中，有两条非常关键的日志。</p>
<ul>
<li>invokeSync：wait response timeout exception.</li>
</ul>
<p>它表示等待响应结果超时。</p>
<ul>
<li>recive response, but not matched any request.</li>
</ul>
<p>这条日志非常关键，它表示，尽管客户端在获取服务端返回结果时超时了，但客户端最终还是能收到服务端的响应结果，只是此时客户端已经在等待足够时间之后放弃处理了。</p>
<h2>单一长连接如何实现多请求并发发送？</h2>
<p>为什么第二条日志超时后还能收到服务端的响应结果，又为什么匹配不到对应的请求了呢？</p>
<p>我们可以详细探究一下这背后的原理。原来，这是使用单一长连接进行网络请求的编程范式。举个例子，一条长连接向服务端先后发送了两个请求，客户端在收到服务端响应结果时，需要判断这个响应结果对应的是哪个请求。</p>
<p><img src="assets/435035c392ea7907b9c46e59b169420f-20220924201105-2i91wmh.jpg" alt="" /></p>
<p>正如上图所示，客户端多个线程通过一条连接依次发送了 req1，req2 两个请求，服务端解码请求后，会将请求转发到线程池中异步执行。如果请求 2 处理得比较快，比请求 1 更早将结果返回给客户端，那客户端怎么识别服务端返回的数据对应的是哪个请求呢？</p>
<p>解决办法是，客户端在发送请求之前，会为这个请求生成一个本机器唯一的请求 ID（requestId），它还会采用 Future 模式，将 requestId 和 Future 对象放到一个 Map 中，然后将 reqestId 放入请求体。服务端在返回响应结果时，会将请求 ID 原封不动地放入响应结果中。客户端收到响应时，会先解码出 requestId，然后从缓存中找到对应的 Future 对象，唤醒业务线程，将返回结果通知给调用方，完成整个通信。</p>
<p>结合日志我发现，如果客户端在指定时间内没有收到服务端的请求，最终会抛出超时异常。但是，网络层面上客户端还是能收到服务端的响应结果。这就把矛头直接指向了 Broker 端，是不是 Broker 有瓶颈，处理慢导致的呢？</p>
<h2>如何诊断 Broker 端内存写入性能？</h2>
<p>我们知道消息发送时，一个非常重要的过程就是服务端写入。如果服务端出现写入瓶颈，通常会返回各种各样的 Broker Busy。我们可以简单来看一下消息发送的写入流程：</p>
<p><img src="assets/9yy4cd8794f51ddab23cc7847943476c-20220924201106-v3wy38n.jpg" alt="" /></p>
<p>我们首先要判断的是，是不是消息写入 PageCache 或者磁盘写入慢导致的问题。我们这个集群采用的是异步刷盘机制，所以写磁盘这一环可以忽略。</p>
<p>然后，我们可以通过跟踪 Broker 端写入 PageCache 的数据指标来判断 Broker 有没有遇到瓶颈。具体做法是查看 RocketMQ 中的 store.log 文件，具体使用命令如下：</p>
<pre><code class="language-bash">cd /home/codingw/logs/rocketmqlogs/store.log //其中codingw为当前rocketmq broker进程的归属用户
grep &quot;PAGECACHERT&quot; store.log
</code></pre>
<p>执行命令后，可以得到这样的结果：</p>
<p><img src="assets/28e8dcd57b18b1db9cd562796e923341-20220924201102-5buh90f.png" alt="" /></p>
<p>这段日志记录了消息写入到 PageCache 的耗时分布。通过分析我们可以知道，写入 PageCache 的耗时都小于 100ms，所以 PageCache 的写入并没有产生瓶颈。不过，<strong>客户端可是真真切切地在 3 秒后才收到响应结果，难道是网络问题？</strong></p>
<h2>网络层排查通用方法</h2>
<p>接下来我们就分析一下网络。</p>
<p>通常，我们可以用 netstat 命令来分析网络通信，需要重点关注网络通信中的 Recv-Q 与 Send-Q 这两个指标。</p>
<p>netstat 命令的执行效果如下图所示：</p>
<p><img src="assets/b395b317544c3961c064985027026a75-20220924201104-8u9iriq.png" alt="" /></p>
<p>解释一下，这里的 Recv-Q 是 TCP 通道的接受缓存区；Send-Q 是 TCP 通道的发送缓存区。</p>
<p>在 TCP 中，Recv-Q 和 Send-Q 的工作机制如下图所示：</p>
<p><img src="assets/a0f374d6e43cf7aaeb950fc6ec634f1b-20220924201104-bdg7s91.jpg" alt="" /></p>
<p>正如上图描述的那样，网络通信有下面几个关键步骤。</p>
<ul>
<li>
<p>客户端调用网络通道时（例如 NIO 的 Channel 写入数据），数据首先是写入到 TCP 的发送缓存区，如果发送缓存区已满，客户端无法继续向该通道发送请求，从 NIO 层面调用 Channel 底层的 write 方法的时候会返回 0。这个时候在应用层面需要注册写事件，待发送缓存区有空闲时，再通知上层应用程序继续写入上次未写入的数据。</p>
</li>
<li>
<p>数据进入到发送缓存区后，会随着网络到达目标端。数据首先进入的是目标端的接收缓存区，如果服务端采用事件选择机制的话，通道的读事件会就绪。应用从接收缓存区成功读取到字节后，会发送 ACK 给发送方。</p>
</li>
<li>
<p>发送方在收到 ACK 后，会删除发送缓冲区的数据。如果接收方一直不读取数据，那发送方也无法发送数据。</p>
</li>
</ul>
<p>运维同事分别在客户端和 MQ 服务器上，在服务器上写一个脚本，每 500ms 采集一次 netstat 。最终汇总到的采集结果如下：</p>
<p><img src="assets/d2663e95c03913273d319eece0baaabc-20220924201105-q356ngf.png" alt="" /></p>
<p>从客户端来看，客户端的 Recv-Q 中出现大量积压，它对应的是 MQ 的 Send-Q 中的大量积压。</p>
<p>结合 Recv-Q、Send-Q 的工作机制，再次怀疑可能是客户端从网络中读取字节太慢导致的。为了验证这个观点，我修改了和 RocketMQ Client 相关的包，加入了 Netty 性能采集方面的代码：</p>
<p><img src="assets/7c7ac37cae929419c65f4327cfbdb14d-20220924201103-km5dbps.png" alt="" /></p>
<p>我的核心思路是，针对每一次被触发的读事件，判断客户端会对一个通道进行多少次读取操作。如果一次读事件需要触发很多次的读取，说明这个通道确实积压了很多数据，网络读存在瓶颈。</p>
<p>部分采集数据如下：</p>
<p><img src="assets/5374ce040ff2a31e2b7ce6e565762f95-20220924201103-lwhb3iy.png" alt="" /></p>
<p>我们可以通过 awk 命令对这个数据进行分析。从结果可以看出，一次读事件触发，大部分通道只要读两次就可以成功抽取读缓存区中的数据。读数据方面并不存在瓶颈。</p>
<p>统计分析结果如下图所示：</p>
<p><img src="assets/38c60d07ce3ff424c69e81de77dc8eff-20220924201102-0sl7qv0.png" alt="" /></p>
<p>如此看来，瓶颈应该不在客户端，还是需要将目光转移到服务端。</p>
<p>从刚才的分析中我们已经看到，Broker 服务端写入 PageCache 很快。但是刚刚我们唯独没有监控“响应结果写入网络”这个环节。那是不是写入响应结果不及时，导致消息大量积压在 Netty 的写缓存区，不能及时写入到 TCP 的发送缓冲区，最终造成消息发送超时呢？</p>
<h2>解决方案</h2>
<p>为了验证这个设想，我最初的打算是改造代码，从 Netty 层面监控服务端的写性能。但这样做的风险比较大，所以我暂时搁置了这个计划，又认真读了一遍 RocketMQ 封装 Netty 的代码。在这之前，我一直以为 RocketMQ 的 网络层基本不需要参数优化，因为公司的服务器都是 64 核心的，而 Netty 的 IO 线程默认都是 CPU 的核数。</p>
<p>但这次阅读源码后我发现，RocketMQ 中和 IO 相关的线程参数有两个，分别是 serverSelectorThreads（默认值为 3）和 serverWorkerThreads（默认值为 8）。</p>
<p>在 Netty 中，serverSelectorThreads 就是 WorkGroup，即所谓的 IO 线程池。每一个线程池会持有一个 NIO 中的 Selector 对象用来进行事件选择，所有的通道会轮流注册在这 3 个线程中，绑定在一个线程中的所有 Channel 会串行进行网络读写操作。</p>
<p>我们的 MQ 服务器的配置，CPU 的核数都在 48C 及以上，用 3 个线程来做这件事显然太“小家子气”，这个参数可以调优。</p>
<p>RocketMQ 的网络通信层使用的是 Netty 框架，默认情况下事件的传播（编码、解码）都在 IO 线程中，也就是上面提到的 Selector 对象所在的线程。</p>
<p>在 RocketMQ 中 IO 线程就只负责网络读、写，然后将读取到的二进制数据转发到一个线程池处理。这个线程池会负责数据的编码、解码等操作，线程池线程数量由 serverWorkerThreads 指定。</p>
<p>看到这里，我开始心潮澎湃了，我感觉自己离真相越来越近了。参考 Netty 将 IO 线程设置为 CPU 核数的两倍，我的第一波优化是让 serverSelectorThreads=16，serverWorkerThreads=32，然后在生产环境中进行一波验证。</p>
<p>经过一个多月的验证，在集群数量逐步减少，业务量逐步上升的背景下，我们生产环境的消息发送超时比例达到了十万分之一，基本可以忽略不计。</p>
<p>网络超时问题的排查到这里就彻底完成了。但生产环境复杂无比，我们基本无法做到 100% 不出现超时。</p>
<p>比方说，虽然调整了 Broker 服务端网络的相关参数，超时问题得到了极大的缓解，但有时候还是会因为一些未知的问题导致网络超时。如果在一定时间内出现大量网络超时，会导致线程资源耗尽，继而影响其他业务的正常执行。</p>
<p>所以在这节课的最后我们再从代码层面介绍如何应对消息发送超时。</p>
<h2>发送超时兜底策略</h2>
<p>我们在应用中使用消息中间件就是看中了消息中间件的低延迟。但是如果消息发送超时，这就和我们的初衷相违背了。为了尽可能避免这样的问题出现，消息中间件领域解决超时的另一个思路是：<strong>增加快速失败的最大等待时长，并减少消息发送的超时时间，增加重试次数。</strong></p>
<p>我们来看下具体做法。</p>
<ol>
<li>增加 Broker 端快速失败的等待时长。这里建议为 1000。在 Broker 的配置文件中增加如下配置：</li>
</ol>
<pre><code class="language-properties">maxWaitTimeMillsInQueue=1000
</code></pre>
<ol start="2">
<li>减少超时时间，增加重试次数。</li>
</ol>
<p>你可能会问，现在已经发生超时了，你还要减少超时时间，那发生超时的概率岂不是更大了？</p>
<p>这样做背后的动机是希望客户端尽快超时并快速重试。因为局域网内的网络抖动是瞬时的，下次重试时就能恢复。并且 RocketMQ 有故障规避机制，重试的时候会尽量选择不同的 Broker。</p>
<p>执行这个操作的代码和版本有关，如果 RocketMQ 的客户端版本低于 4.3.0，代码如下：</p>
<pre><code class="language-java">  DefaultMQProducer producer = new DefaultMQProducer(&quot;dw_test_producer_group&quot;);
  producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);
  producer.setRetryTimesWhenSendFailed(5);//　同步发送模式：重试次数
  producer.setRetryTimesWhenSendAsyncFailed(5);// 异步发送模式：重试次数
  producer.start();
  producer.send(msg,500);//消息发送超时时间
</code></pre>
<p>如果客户端版本是 4.3.0 及以上版本，因为设置的消息发送超时时间是所有重试的总的超时时间，所以不能直接设置 RocketMQ 的发送 API 的超时时间，而是需要对 RocketMQ API 进行包装，例如示例代码如下：</p>
<pre><code class="language-java"> public static SendResult send(DefaultMQProducer producer, Message msg, int 
                                retryCount) {
      Throwable e = null;
      for(int i =0; i &lt; retryCount; i ++ ) {
          try {
              return producer.send(msg,500); //设置超时时间，为 500ms，内部有重试机制
          } catch (Throwable e2) {
              e = e2;
          }
      }
      throw new RuntimeException(&quot;消息发送异常&quot;,e);
   }
</code></pre>
<h2><strong>总结</strong></h2>
<p>好了，我们这节课就介绍到这里了。</p>
<p>这节课，我首先抛出一个生产环境中，消息发送环节最容易遇到的问题：消息发送超时问题。我们对日志现象进行了解读，并引出了单一长连接支持多线程网络请求的原理。</p>
<p>整个排查过程，我首先判断了一下 Broker 写入 PageCache 是否有瓶颈，然后通过 netstat 命令，以 Recv-Q、Send-Q 两个指标为依据进行了网络方面的排查，最终定位到瓶颈可能在于服务端网络读写模型。通过研读 RocketMQ 的网络模型，我发现了两个至关重要的参数，serverSelectorThreads 和 serverWorkerThreads。其中：</p>
<ul>
<li>
<p>serverSelectorThreads 是 RocketMQ 服务端 IO 线程的个数，默认为 3，建议设置为 CPU 核数；</p>
</li>
<li>
<p>serverWorkerThreads 是 RocketMQ 事件处理线程数，主要承担编码、解码等责任，默认为 8，建议设置为 CPU 核数的两倍。</p>
</li>
</ul>
<p>通过调整这两个参数，我们极大地降低了网络超时发生的概率。</p>
<p>不过，发生网络超时的原因是多种多样的，所以我们还介绍了第二种方法，<strong>那就是降低超时时间，增加重试的次数，从而降低网络超时对运行时线程的影响，降低系统响应时间。</strong></p>
<h2><strong>课后题</strong></h2>
<p>学完今天的内容，我也给你留一道课后题吧。</p>
<p>网络通讯在中间件领域非常重要，掌握网络排查相关的知识对线上故障分析有很大的帮助。建议你系统地学习一下 netstat 命令和网络抓包相关技能，分享一下你的经验和困惑。我们下节课见！</p>
</div>
                        </div>
                        <div>
                            <div style="float: left">
                                <a href="17%20%E8%BF%90%E7%BB%B4%EF%BC%9A%E5%A6%82%E4%BD%95%E8%BF%90%E7%BB%B4%E6%97%A5%E5%9D%87%E4%BA%BF%E7%BA%A7%E7%9A%84%E6%B6%88%E6%81%AF%E9%9B%86%E7%BE%A4%EF%BC%9F.md.html">上一页</a>
                            </div>
                            <div style="float: right">
                                <a href="19%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5RocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E7%A7%AF%E5%8E%8B%E9%97%AE%E9%A2%98%EF%BC%9F.md.html">下一页</a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="copyright"><p>© 2019 - 2023 <a href="../../cdn-cgi/l/email-protection.html#aac6c6c6939e9b9b9a9deacdc7cbc3c684c9c5c7" target="_blank">Liangliang Lee</a>. Powered by <a href="https://vertx.io/" target="_blank">Vert.x</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p></div>
        </div>

        <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
    </div>
<script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script defer src="https://static.cloudflareinsights.com/beacon.min.js/vb26e4fa9e5134444860be286fd8771851679335129114" integrity="sha512-M3hN/6cva/SjwrOtyXeUa5IuCT0sedyfT+jK/OV+s+D0RnzrTfwjwJHhd+wYfMm9HJSrZ1IKksOdddLuN6KOzw==" data-cf-beacon='{"rayId":"7af0974ea99cfa86","version":"2023.3.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }

    hljs.initHighlightingOnLoad()

</script>

</html>
