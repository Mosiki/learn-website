<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>24  从哨兵Leader选举学习Raft协议实现（下）.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <link rel="stylesheet"
              href="../../static/highlight.min.css">
        <script src="../../static/highlight.min.js"></script>
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5295275829820252"
                crossorigin="anonymous"></script>
        <script async defer data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" src="https://analyze.lianglianglee.com/umami.js"></script>
    </head>

<body>

    <div class="book-container">
        <div class="book-sidebar">
            <div class="book-brand">
                <a href="../../index.html">
                    <img src="../../static/favicon.png">
                    <span>技术文章摘抄</span>
                </a>
            </div>
            <div class="book-menu uncollapsible">
                <ul class="uncollapsible">
                    <li><a href="../../index.html" class="current-tab">首页</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li><a href="../index.html">上一级</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li>

                        
                        <a href="00%20%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%20%E9%98%85%E8%AF%BBRedis%E6%BA%90%E7%A0%81%E8%83%BD%E7%BB%99%E4%BD%A0%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%EF%BC%9F.md.html">00  开篇词  阅读Redis源码能给你带来什么？.md</a>

                    </li>
                    <li>

                        
                        <a href="01%20%20%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%BB%E7%95%A5Redis%E6%BA%90%E7%A0%81%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.md.html">01  带你快速攻略Redis源码的整体架构.md</a>

                    </li>
                    <li>

                        
                        <a href="02%20%20%E9%94%AE%E5%80%BC%E5%AF%B9%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E7%94%A8char%E8%BF%98%E6%98%AF%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9F.md.html">02  键值对中字符串的实现，用char还是结构体？.md</a>

                    </li>
                    <li>

                        
                        <a href="03%20%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%80%A7%E8%83%BD%E4%BC%98%E5%BC%82%E7%9A%84Hash%E8%A1%A8%EF%BC%9F.md.html">03  如何实现一个性能优异的Hash表？.md</a>

                    </li>
                    <li>

                        
                        <a href="04%20%20%E5%86%85%E5%AD%98%E5%8F%8B%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A5%E5%A6%82%E4%BD%95%E7%BB%86%E5%8C%96%E8%AE%BE%E8%AE%A1%EF%BC%9F.md.html">04  内存友好的数据结构该如何细化设计？.md</a>

                    </li>
                    <li>

                        
                        <a href="05%20%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E4%B8%BA%E4%BD%95%E8%83%BD%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81%E7%82%B9%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%EF%BC%9F.md.html">05  有序集合为何能同时支持点查询和范围查询？.md</a>

                    </li>
                    <li>

                        
                        <a href="06%20%20%E4%BB%8Eziplist%E5%88%B0quicklist%EF%BC%8C%E5%86%8D%E5%88%B0listpack%E7%9A%84%E5%90%AF%E5%8F%91.md.html">06  从ziplist到quicklist，再到listpack的启发.md</a>

                    </li>
                    <li>

                        
                        <a href="07%20%20%E4%B8%BA%E4%BB%80%E4%B9%88Stream%E4%BD%BF%E7%94%A8%E4%BA%86Radix%20Tree%EF%BC%9F.md.html">07  为什么Stream使用了Radix Tree？.md</a>

                    </li>
                    <li>

                        
                        <a href="08%20%20Redis%20server%E5%90%AF%E5%8A%A8%E5%90%8E%E4%BC%9A%E5%81%9A%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%EF%BC%9F.md.html">08  Redis server启动后会做哪些操作？.md</a>

                    </li>
                    <li>

                        
                        <a href="09%20%20Redis%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8select%E3%80%81poll%E3%80%81epoll%EF%BC%9F.md.html">09  Redis事件驱动框架（上）：何时使用select、poll、epoll？.md</a>

                    </li>
                    <li>

                        
                        <a href="10%20%20Redis%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9ARedis%E5%AE%9E%E7%8E%B0%E4%BA%86Reactor%E6%A8%A1%E5%9E%8B%E5%90%97%EF%BC%9F.md.html">10  Redis事件驱动框架（中）：Redis实现了Reactor模型吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="11%20%20Redis%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9ARedis%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BA%8B%E4%BB%B6%EF%BC%9F.md.html">11  Redis事件驱动框架（下）：Redis有哪些事件？.md</a>

                    </li>
                    <li>

                        
                        <a href="12%20%20Redis%E7%9C%9F%E7%9A%84%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F.md.html">12  Redis真的是单线程吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="13%20%20Redis%206.0%E5%A4%9AIO%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%88%E7%8E%87%E6%8F%90%E9%AB%98%E4%BA%86%E5%90%97%EF%BC%9F.md.html">13  Redis 6.0多IO线程的效率提高了吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="14%20%20%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%9C%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E4%BF%9D%E8%AF%81.md.html">14  从代码实现看分布式锁的原子性保证.md</a>

                    </li>
                    <li>

                        
                        <a href="15%20%20%E4%B8%BA%E4%BB%80%E4%B9%88LRU%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%92%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F.md.html">15  为什么LRU算法原理和代码实现不一样？.md</a>

                    </li>
                    <li>

                        
                        <a href="16%20%20LFU%E7%AE%97%E6%B3%95%E5%92%8C%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BC%98%E5%8A%BF%E5%90%97%EF%BC%9F.md.html">16  LFU算法和其他算法相比有优势吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="17%20%20Lazy%20Free%E4%BC%9A%E5%BD%B1%E5%93%8D%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2%E5%90%97%EF%BC%9F.md.html">17  Lazy Free会影响缓存替换吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="18%20%20%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%92%8C%E8%A7%A3%E8%AF%BBRDB%E6%96%87%E4%BB%B6%EF%BC%9F.md.html">18  如何生成和解读RDB文件？.md</a>

                    </li>
                    <li>

                        
                        <a href="19%20%20AOF%E9%87%8D%E5%86%99%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA%E4%B8%8E%E9%87%8D%E5%86%99%E7%9A%84%E5%BD%B1%E5%93%8D.md.html">19  AOF重写（上）：触发时机与重写的影响.md</a>

                    </li>
                    <li>

                        
                        <a href="20%20%20AOF%E9%87%8D%E5%86%99%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84%E6%96%B0%E5%86%99%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F.md.html">20  AOF重写（下）：重写时的新写操作记录在哪里？.md</a>

                    </li>
                    <li>

                        
                        <a href="21%20%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.md.html">21  主从复制：基于状态机的设计与实现.md</a>

                    </li>
                    <li>

                        
                        <a href="22%20%20%E5%93%A8%E5%85%B5%E4%B9%9F%E5%92%8CRedis%E5%AE%9E%E4%BE%8B%E4%B8%80%E6%A0%B7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%97%EF%BC%9F.md.html">22  哨兵也和Redis实例一样初始化吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="23%20%20%E4%BB%8E%E5%93%A8%E5%85%B5Leader%E9%80%89%E4%B8%BE%E5%AD%A6%E4%B9%A0Raft%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89.md.html">23  从哨兵Leader选举学习Raft协议实现（上）.md</a>

                    </li>
                    <li>

                        <a class="current-tab" href="24%20%20%E4%BB%8E%E5%93%A8%E5%85%B5Leader%E9%80%89%E4%B8%BE%E5%AD%A6%E4%B9%A0Raft%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8B%EF%BC%89.md.html">24  从哨兵Leader选举学习Raft协议实现（下）.md</a>
                        

                    </li>
                    <li>

                        
                        <a href="25%20%20PubSub%E5%9C%A8%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%E6%97%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E6%8C%A5%E4%BD%9C%E7%94%A8%E7%9A%84%EF%BC%9F.md.html">25  PubSub在主从故障切换时是如何发挥作用的？.md</a>

                    </li>
                    <li>

                        
                        <a href="26%20%20%E4%BB%8EPing-Pong%E6%B6%88%E6%81%AF%E5%AD%A6%E4%B9%A0Gossip%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E7%8E%B0.md.html">26  从Ping-Pong消息学习Gossip协议的实现.md</a>

                    </li>
                    <li>

                        
                        <a href="27%20%20%E4%BB%8EMOVED%E3%80%81ASK%E7%9C%8B%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%EF%BC%9F.md.html">27  从MOVED、ASK看集群节点如何处理命令？.md</a>

                    </li>
                    <li>

                        
                        <a href="28%20%20Redis%20Cluster%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E4%BC%9A%E9%98%BB%E5%A1%9E%E5%90%97%EF%BC%9F.md.html">28  Redis Cluster数据迁移会阻塞吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="29%20%20%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9F.md.html">29  如何正确实现循环缓冲区？.md</a>

                    </li>
                    <li>

                        
                        <a href="30%20%20%E5%A6%82%E4%BD%95%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E7%9B%91%E6%8E%A7%EF%BC%9F.md.html">30  如何在系统中实现延迟监控？.md</a>

                    </li>
                    <li>

                        
                        <a href="31%20%20%E4%BB%8EModule%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AD%A6%E4%B9%A0%E5%8A%A8%E6%80%81%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD.md.html">31  从Module的实现学习动态扩展功能.md</a>

                    </li>
                    <li>

                        
                        <a href="32%20%20%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%9F.md.html">32  如何在一个系统中实现单元测试？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%BB%93%E6%9D%9F%E8%AF%AD%20%20Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%8C%E8%AE%A9%E6%88%91%E4%BB%AC%E4%BB%8E%E6%96%B0%E5%BC%80%E5%A7%8B.md.html">结束语  Redis源码阅读，让我们从新开始.md</a>

                    </li>
                </ul>

            </div>
        </div>

        <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
            <div class="sidebar-toggle-inner"></div>
        </div>

        <script>
            function add_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.add('show')
            }

            function remove_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.remove('show')
            }

            function sidebar_toggle() {
                let sidebar_toggle = document.querySelector('.sidebar-toggle')
                let sidebar = document.querySelector('.book-sidebar')
                let content = document.querySelector('.off-canvas-content')
                if (sidebar_toggle.classList.contains('extend')) { // show
                    sidebar_toggle.classList.remove('extend')
                    sidebar.classList.remove('hide')
                    content.classList.remove('extend')
                } else { // hide
                    sidebar_toggle.classList.add('extend')
                    sidebar.classList.add('hide')
                    content.classList.add('extend')
                }
            }


            function open_sidebar() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.add('show')
                overlay.classList.add('show')
            }
            function hide_canvas() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.remove('show')
                overlay.classList.remove('show')
            }

        </script>

        <div class="off-canvas-content">
            <div class="columns">
                <div class="column col-12 col-lg-12">
                    <div class="book-navbar">
                        <!-- For Responsive Layout -->
                        <header class="navbar">
                            <section class="navbar-section">
                                <a onclick="open_sidebar()">
                                    <i class="icon icon-menu"></i>
                                </a>
                            </section>
                        </header>
                    </div>
                    <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                        <div class="book-post">
                            <p id="tip" align="center"></p>
                            <div><h1>24  从哨兵Leader选举学习Raft协议实现（下）</h1>
<p>上节课，我给你介绍了 Raft 协议的基本流程，以及哨兵实例工作的基本过程。哨兵是通过 serverCron 函数的周期性执行，进而在 serverCron 中调用 sentinelTimer 函数，实现周期性处理哨兵相关的时间事件。而 sentinelTimer 函数处理的时间事件，就包括了对哨兵监听的每个主节点，它会通过调用 sentinelHandleRedisInstance 函数，来检查主节点的在线状态，并在主节点客观下线时进行故障切换。</p>
<p>另外，我还带你了解了 sentinelHandleRedisInstance 函数执行过程的前三步操作，分别是重连断连的实例、周期性给实例发送检测命令，检测实例是否主观下线，这也分别对应了 sentinelReconnectInstance、sentinelSendPeriodicCommands 和 sentinelCheckSubjectivelyDown 这三个函数，你可以再回顾下。</p>
<p>那么，今天这节课，我接着来给你介绍 sentinelHandleRedisInstance 函数执行过程中的剩余操作，分别是检测主节点是否客观下线、判断是否需要执行故障切换，以及需要故障切换时的哨兵 Leader 选举的具体过程。</p>
<p>学完这节课的内容，你就可以对哨兵工作的过程有个全面了解了。并且，你可以掌握如何在代码层面实现 Raft 协议来完成 Leader 选举。这样，当你日后在分布式系统中实现分布式共识时，这部分内容就能帮助指导你的代码设计与实现了。</p>
<p>接下来，我们先来看下主节点的客观下线判断。</p>
<h2>主节点客观下线判断</h2>
<p>现在我们知道，哨兵在 sentinelHandleRedisInstance 函数中会<strong>调用 sentinelCheckObjectivelyDown 函数</strong>（在 sentinel.c 文件中），来检测主节点是否客观下线。</p>
<p>而 sentinelCheckObjectivelyDown 函数在执行时，除了会检查当前哨兵对主节点主观下线的判断结果，还需要结合监听相同主节点的其他哨兵，对主节点主观下线的判断结果。它把这些判断结果综合起来，才能做出主节点客观下线的最终判断。</p>
<p>从代码实现层面来看，在哨兵用来记录主节点信息的 <strong>sentinelRedisInstance 结构体</strong>中，本身已经用哈希表保存了监听同一主节点的其他哨兵实例，如下所示：</p>
<pre><code class="language-c">typedef struct sentinelRedisInstance {
…
dict *sentinels;
…
}
</code></pre>
<p>这样一来，sentinelCheckObjectivelyDown 函数通过遍历主节点记录的 sentinels 哈希表，就可以获取其他哨兵实例对同一主节点主观下线的判断结果。这也是因为，sentinels 哈希表中保存的哨兵实例，它们同样使用了 sentinelRedisInstance 这个结构体，而这个结构体的成员变量 flags，会记录哨兵对主节点主观下线的判断结果。</p>
<p>具体来说，sentinelCheckObjectivelyDown 函数会<strong>使用 quorum 变量，来记录判断主节点为主观下线的哨兵数量</strong>。如果当前哨兵已经判断主节点为主观下线，那么它会先把 quorum 值置为 1。然后，它会依次判断其他哨兵的 flags 变量，<strong>检查是否设置了 SRI_MASTER_DOWN 的标记</strong>。如果设置了，它就会把 quorum 值加 1。</p>
<p>当遍历完 sentinels 哈希表后，sentinelCheckObjectivelyDown 函数会判断 quorum 值是否大于等于预设定的 quorum 阈值，这个阈值保存在了主节点的数据结构中，也就是 master-&gt;quorum，而这个阈值是在 sentinel.conf 配置文件中设置的。</p>
<p>如果实际的 quorum 值大于等于预设的 quorum 阈值，sentinelCheckObjectivelyDown 函数就判断主节点为客观下线，并**设置变量 odown 为 1，**而这个变量就是用来表示当前哨兵对主节点客观下线的判断结果的。</p>
<p>这部分的判断逻辑如下代码所示，你可以看下：</p>
<pre><code class="language-c">void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {
…
//当前主节点已经被当前哨兵判断为主观下线
if (master-&gt;flags &amp; SRI_S_DOWN) {
   quorum = 1; //当前哨兵将quorum值置为1
   
   di = dictGetIterator(master-&gt;sentinels);
   while((de = dictNext(di)) != NULL) {  //遍历监听同一主节点的其他哨兵
      sentinelRedisInstance *ri = dictGetVal(de);
      if (ri-&gt;flags &amp; SRI_MASTER_DOWN) quorum++;
   }
   dictReleaseIterator(di);
   //如果quorum值大于预设的quorum阈值，那么设置odown为1。
   if (quorum &gt;= master-&gt;quorum) odown = 1;
}
</code></pre>
<p>另外，这里我也画了一张图，展示了该判断逻辑，你可以再来回顾下。</p>
<p><img src="assets/c4201b2611c7e6c53604914b29b9418f-20221014000238-7b9i3fo.jpg" alt="" /></p>
<p>那么，一旦 sentinelCheckObjectivelyDown 函数判断主节点客观下线了，它就会调用 sentinelEvent 函数发送 +odown 事件消息，然后在主节点的 flags 变量中<strong>设置 SRI_O_DOWN 标记</strong>，如下所示：</p>
<pre><code class="language-c">//判断主节点为客观下线
if (odown) {
   //如果没有设置SRI_O_DOWN标记
   if ((master-&gt;flags &amp; SRI_O_DOWN) == 0) {
    sentinelEvent(LL_WARNING,&quot;+odown&quot;,master,&quot;%@ #quorum %d/%d&quot;,
                quorum, master-&gt;quorum); //发送+odown事件消息
    master-&gt;flags |= SRI_O_DOWN;  //在主节点的flags中记录SRI_O_DOWN标记
    master-&gt;o_down_since_time = mstime(); //记录判断客观下线的时间
   }
}
</code></pre>
<p>也就是说，<strong>sentinelCheckObjectivelyDown 函数是通过遍历监听同一主节点的其他哨兵的 flags 变量，来判断主节点是否客观下线的。</strong></p>
<p>不过，你看完刚才的代码可能会有一个疑问，在上节课学习的 sentinelCheckSubjectivelyDown 函数中，如果哨兵判断主节点为主观下线，是会在主节点的 flags 变量中<strong>设置 SRI_S_DOWN 标记</strong>，如下所示：</p>
<pre><code class="language-c">//哨兵已判断主节点为主观下线
…
//对应主节点的sentinelRedisInstance结构中flags没有记录主观下线
if ((ri-&gt;flags &amp; SRI_S_DOWN) == 0) {
   …
   ri-&gt;flags |= SRI_S_DOWN;  //在主节点的flags中记录主观下线的标记，
}
</code></pre>
<p>但是，sentinelCheckObjectivelyDown 函数，是检查监听同一主节点的其他哨兵 flags 变量中的 SRI_MASTER_DOWN 标记，<strong>那么其他哨兵的 SRI_MASTER_DOWN 标记是如何设置的呢?</strong></p>
<p>这就和 sentinelAskMasterStateToOtherSentinels 函数（在 sentinel.c 文件中）有关系了，下面，我们来具体了解下这个函数。</p>
<h3>sentinelAskMasterStateToOtherSentinels 函数</h3>
<p>sentinelAskMasterStateToOtherSentinels 函数的主要目的，是向监听同一主节点的其他哨兵发送 is-master-down-by-addr 命令，进而询问其他哨兵对主节点的状态判断。</p>
<p>它会调用 redisAsyncCommand 函数（在<a href="https://github.com/redis/redis/tree/5.0/deps/hiredis/async.c">async.c</a>文件中），依次向其他哨兵发送 sentinel is-master-down-by-addr 命令，同时，它设置了<strong>收到该命令返回结果的处理函数为 sentinelReceiveIsMasterDownReply</strong>（在 sentinel.c 文件中），如下所示：</p>
<pre><code class="language-c">void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {
…
di = dictGetIterator(master-&gt;sentinels);
//遍历监听同一主节点的其他哨兵
while((de = dictNext(di)) != NULL) {
   sentinelRedisInstance *ri = dictGetVal(de);
   …
   //发送sentinel is-master-down-by-addr命令
   retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
             sentinelReceiveIsMasterDownReply, ri,
             &quot;%s is-master-down-by-addr %s %s %llu %s&quot;,
             sentinelInstanceMapCommand(ri,&quot;SENTINEL&quot;),
             master-&gt;addr-&gt;ip, port,
             sentinel.current_epoch,
             (master-&gt;failover_state &gt; SENTINEL_FAILOVER_STATE_NONE) ?
                 sentinel.myid : &quot;*&quot;);
}
…
}
</code></pre>
<p>另外从代码中，我们可以看到，sentinel is-master-down-by-addr 命令中还包括主节点 IP、主节点端口号、当前纪元（sentinel.current_epoch）和实例 ID。下面展示的就是这个命令的格式：</p>
<pre><code class="language-c">sentinel is-master-down-by-addr 主节点IP 主节点端口 当前epoch 实例ID
</code></pre>
<p>在这其中，哨兵会根据当前主节点所处的状态来设置实例 ID。如果主节点已经要开始进行故障切换了，那么，实例 ID 会被设置为当前哨兵自身的 ID，否则就会被设置为 * 号。</p>
<p>这里你需要注意的是，主节点的数据结构是使用了 <strong>master-&gt;failover_state</strong> 来记录故障切换的状态，其初始值为 SENTINEL_FAILOVER_STATE_NONE（对应的数值为 0），当主节点开始故障切换时，这个状态值就会大于 SENTINEL_FAILOVER_STATE_NONE 了。</p>
<p>好了，在了解了 sentinelAskMasterStateToOtherSentinels 函数的基本执行过程之后，我们还需要知道：sentinelAskMasterStateToOtherSentinels 函数向其他哨兵发出了 sentinel is-master-down-by-addr 命令后，其他哨兵是如何处理的呢？</p>
<h3>sentinel is-master-down-by-addr 命令的处理</h3>
<p>其实，哨兵对于 sentinel 开头的命令，都是在 <strong>sentinelCommand 函数</strong>（在 sentinel.c 文件）中进行处理的。sentinelCommand 函数会根据 sentinel 命令后面跟的不同子命令，来执行不同的分支，而 is-master-down-by-addr 就是一条子命令。</p>
<p>在 is-master-down-by-addr 子命令对应的代码分支中，sentinelCommand 函数会根据命令中的主节点 IP 和端口号，来获取主节点对应的 sentinelRedisInstance 结构体。</p>
<p>紧接着，它会判断主节点的 flags 变量中是否有 SRI_S_DOWN 和 SRI_MASTER 标记，也就是说，sentinelCommand 函数会检查当前节点是否的确是主节点，以及哨兵是否已经将该节点标记为主观下线了。如果条件符合，那么它会设置 <strong>isdown 变量</strong>为 1，而这个变量表示的就是哨兵对主节点主观下线的判断结果。</p>
<p>然后，sentinelCommand 函数会把当前哨兵对主节点主观下线的判断结果，返回给发送 sentinel 命令的哨兵。它返回的结果主要包含三部分内容，分别是<strong>当前哨兵对主节点主观下线的判断结果</strong>、<strong>哨兵 Leader 的 ID</strong>，以及<strong>哨兵 Leader 所属的纪元</strong>。</p>
<p>sentinelCommand 函数，对 sentinel 命令处理的基本过程如下所示：</p>
<pre><code class="language-c">void sentinelCommand(client *c) {
…
// is-master-down-by-addr子命令对应的分支
else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;is-master-down-by-addr&quot;)) {
…
//当前哨兵判断主节点为主观下线
if (!sentinel.tilt &amp;&amp; ri &amp;&amp; (ri-&gt;flags &amp; SRI_S_DOWN) &amp;&amp; (ri-&gt;flags &amp; SRI_MASTER))
   isdown = 1;
…
addReplyMultiBulkLen(c,3); //哨兵返回的sentinel命令处理结果中包含三部分内容
addReply(c, isdown ? shared.cone : shared.czero); //如果哨兵判断主节点为主观下线，第一部分为1，否则为0
addReplyBulkCString(c, leader ? leader : &quot;*&quot;); //第二部分是Leader ID或者是*
addReplyLongLong(c, (long long)leader_epoch); //第三部分是Leader的纪元
…}
…}
</code></pre>
<p>你也可以参考下图：</p>
<p><img src="assets/573b2cb64005925500d338030f61a1fd-20221014000238-seoawbv.jpg" alt="" /></p>
<p>好了，到这里你就已经知道，哨兵会通过 sentinelAskMasterStateToOtherSentinels 函数，向监听同一节点的其他哨兵发送 sentinel is-master-down-by-addr 命令，来获取其他哨兵对主节点主观下线的判断结果。而其他哨兵是使用 sentinelCommand 函数，来处理 sentinel is-master-down-by-addr 命令，并在命令处理的返回结果中，包含自己对主节点主观下线的判断结果。</p>
<p>不过从刚才的代码中，你也可以看到，在其他哨兵返回的 sentinel 命令处理结果中，会包含哨兵 Leader 的信息。其实，这是因为 sentinelAskMasterStateToOtherSentinels 函数发送的 sentinel is-master-down-by-addr 命令本身，也可以用来<strong>触发哨兵 Leader 选举</strong>。这个我稍后会给你介绍。</p>
<p>那么，我们再回到前面讲主节点客观下线判断时提出的问题，sentinelCheckObjectivelyDown 函数要检查监听同一主节点的其他哨兵 flags 变量中的 SRI_MASTER_DOWN 标记，但是，其他哨兵的 SRI_MASTER_DOWN 标记是如何设置的呢？</p>
<p>这实际上是和哨兵在 sentinelAskMasterStateToOtherSentinels 函数中，向其他哨兵发送 sentinel is-master-down-by-addr 命令时，设置的<strong>命令结果处理函数 sentinelReceiveIsMasterDownReply</strong> 有关。</p>
<h3>sentinelReceiveIsMasterDownReply 函数</h3>
<p>在 sentinelReceiveIsMasterDownReply 函数中，它会判断其他哨兵返回的回复结果。回复结果会包含我刚才介绍的三部分内容，分别是当前哨兵对主节点主观下线的判断结果、哨兵 Leader 的 ID，以及哨兵 Leader 所属的纪元。这个函数会进一步检查，其中第一部分内容“当前哨兵对主节点主观下线的判断结果”是否为 1。</p>
<p>如果是的话，这就表明对应的哨兵已经判断主节点为主观下线了，那么当前哨兵就会把自己记录的对应哨兵的 flags，设置为 SRI_MASTER_DOWN。</p>
<p>下面的代码就展示了 sentinelReceiveIsMasterDownReply 函数判断其他哨兵回复结果的执行逻辑，你可以看下。</p>
<pre><code class="language-c">//r是当前哨兵收到的其他哨兵的命令处理结果
//如果返回结果包含三部分内容，并且第一，二，三部分内容的类型分别是整数、字符串和整数
if (r-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; r-&gt;elements == 3 &amp;&amp;
        r-&gt;element[0]-&gt;type == REDIS_REPLY_INTEGER &amp;&amp;
        r-&gt;element[1]-&gt;type == REDIS_REPLY_STRING &amp;&amp;
        r-&gt;element[2]-&gt;type == REDIS_REPLY_INTEGER)
{
        ri-&gt;last_master_down_reply_time = mstime();
        //如果返回结果第一部分的值为1，则在对应哨兵的flags中设置SRI_MASTER_DOWN标记
        if (r-&gt;element[0]-&gt;integer == 1) {
            ri-&gt;flags |= SRI_MASTER_DOWN;
        }
</code></pre>
<p>所以到这里，你就可以知道，一个哨兵调用 sentinelCheckObjectivelyDown 函数，是直接检查其他哨兵的 flags 是否有 SRI_MASTER_DOWN 标记，而哨兵又是通过 sentinelAskMasterStateToOtherSentinels 函数，向其他哨兵发送 sentinel is-master-down-by-addr 命令，从而询问其他哨兵对主节点主观下线的判断结果的，并且会根据命令回复结果，在结果处理函数 sentinelReceiveIsMasterDownReply 中，设置其他哨兵的 flags 为 SRI_MASTER_DOWN。下图也展示了这个执行逻辑，你可以再来整体回顾下。</p>
<p><img src="assets/51c98fec129byy830c8878466c95337f-20221014000238-6w3e2vj.jpg" alt="" /></p>
<p>那么，掌握了这个执行逻辑后，我们再来看下，哨兵选举是什么时候开始执行的。</p>
<h2>哨兵选举</h2>
<p>这里，为了了解哨兵选举的触发，我们先来复习下在上节课，我讲过的 sentinelHandleRedisInstance 函数中针对主节点的调用关系，如下图所示：</p>
<p><img src="assets/276ee9fb08acf2405aa24b4658387df7-20221014000238-wlag5g9.jpg" alt="" /></p>
<p>从图中可以看到，sentinelHandleRedisInstance 会先调用 sentinelCheckObjectivelyDown 函数，再调用 sentinelStartFailoverIfNeeded 函数，判断是否要开始故障切换，如果 sentinelStartFailoverIfNeeded 函数的返回值为<strong>非 0 值</strong>，那么 sentinelAskMasterStateToOtherSentinels 函数会被调用。否则的话，sentinelHandleRedisInstance 就直接调用 sentinelFailoverStateMachine 函数，并再次调用 sentinelAskMasterStateToOtherSentinels 函数。</p>
<p>那么，在这个调用关系中，sentinelStartFailoverIfNeeded 会判断是否要进行故障切换，它的<strong>判断条件</strong>有三个，分别是：</p>
<ul>
<li>主节点的 flags 已经标记了 SRI_O_DOWN；</li>
<li>当前没有在执行故障切换；</li>
<li>如果已经开始故障切换，那么开始时间距离当前时间，需要超过 sentinel.conf 文件中的 sentinel failover-timeout 配置项的 2 倍。</li>
</ul>
<p>这三个条件都满足后，sentinelStartFailoverIfNeeded 就会调用 <strong>sentinelStartFailover 函数</strong>，开始启动故障切换，而 sentinelStartFailover 会将主节点的 failover_state 设置为 SENTINEL_FAILOVER_STATE_WAIT_START，同时在主节点的 flags 设置 SRI_FAILOVER_IN_PROGRESS 标记，表示已经开始故障切换，如下所示：</p>
<pre><code class="language-c">void sentinelStartFailover(sentinelRedisInstance *master) {
…
master-&gt;failover_state = SENTINEL_FAILOVER_STATE_WAIT_START;
master-&gt;flags |= SRI_FAILOVER_IN_PROGRESS;
…
}
</code></pre>
<p>而一旦 sentinelStartFailover 函数将主节点的 failover_state 设置为 SENTINEL_FAILOVER_STATE_WAIT_START 后，接下来，sentinelFailoverStateMachine 函数就会执行状态机来完成实际的切换。不过，<strong>在实际切换前，sentinelAskMasterStateToOtherSentinels 函数会被调用。</strong></p>
<p>看到这个调用关系，你可能会有个疑问：sentinelAskMasterStateToOtherSentinels 函数是用来向其他哨兵询问对主节点主观下线的判断结果的，如果 sentinelStartFailoverIfNeeded 判断要开始执行故障切换，那么为什么还要调用 sentinelAskMasterStateToOtherSentinels 函数呢？</p>
<p>其实，这就和 sentinelAskMasterStateToOtherSentinels 函数的另一个作用有关了，这个函数除了会用来向其他哨兵询问对主节点状态的判断，它还可以用来<strong>向其他哨兵发起 Leader 选举</strong>。</p>
<p>在刚才给你介绍这个函数时，我提到它会给其他哨兵发送 sentinel is-master-down-by-addr 命令，这个命令包括主节点 IP、主节点端口号、当前纪元（sentinel.current_epoch）和实例 ID。其中，如果主节点的 failover_state 已经不再是 SENTINEL_FAILOVER_STATE_NONE，那么实例 ID 会被设置为当前哨兵的 ID。</p>
<p>而在 sentinel 命令处理函数中，如果检测到 sentinel 命令中的实例 ID 不为 * 号，那么就会调用 <strong>sentinelVoteLeader 函数</strong>来进行 Leader 选举。</p>
<p>//当前实例为主节点，并且sentinel命令的实例ID不等于*号</p>
<pre><code class="language-c">//当前实例为主节点，并且sentinel命令的实例ID不等于*号
if (ri &amp;&amp; ri-&gt;flags &amp; SRI_MASTER &amp;&amp; strcasecmp(c-&gt;argv[5]-&gt;ptr,&quot;*&quot;)) {
   //调用sentinelVoteLeader进行哨兵Leader选举
   leader = sentinelVoteLeader(ri,(uint64_t)req_epoch, c-&gt;argv[5]-&gt;ptr,
                                            &amp;leader_epoch);
}
</code></pre>
<p>下面，我们来具体了解下这个 sentinelVoteLeader 函数。</p>
<h3>sentinelVoteLeader 函数</h3>
<p>sentinelVoteLeader 函数会实际执行投票逻辑，这里我通过一个例子来给你说明。</p>
<p>假设哨兵 A 判断主节点 master 客观下线了，它现在向哨兵 B 发起投票请求，哨兵 A 的 ID 是 req_runid。那么哨兵 B 在执行 sentinelVoteLeader 函数时，这个函数会判断哨兵 A 的纪元（req_epoch）、哨兵 B 的纪元（sentinel.current_epoch），以及 master 记录的 Leader 的纪元（master-&gt;leader_epoch）。按照 Raft 协议的定义，哨兵 A 就是 Candidate 节点，而哨兵 B 就是 Follower 节点。</p>
<p>我在上节课给你介绍 Raft 协议时有提到过，Candidate 发起投票都是有轮次记录的，Follower 在一轮投票中只能投一票。这里的纪元正是起到了<strong>轮次记录</strong>的作用。而 sentinelVoteLeader 函数判断纪元也是按照 Raft 协议的要求，让 Follower 在一轮中只能投一票。</p>
<p>那么，<strong>sentinelVoteLeader 函数让哨兵 B 投票的条件是</strong>：master 记录的 Leader 的纪元小于哨兵 A 的纪元，同时，哨兵 A 的纪元要大于或等于哨兵 B 的纪元。这两个条件保证了哨兵 B 还没有投过票，否则的话，sentinelVoteLeader 函数就直接返回当前 master 中记录的 Leader ID 了，这也是哨兵 B 之前投过票后记录下来的。</p>
<p>下面的代码展示了刚才介绍的这部分逻辑，你可以看下。</p>
<pre><code class="language-c">if (req_epoch &gt; sentinel.current_epoch) {
   sentinel.current_epoch = req_epoch;
   …
   sentinelEvent(LL_WARNING,&quot;+new-epoch&quot;,master,&quot;%llu&quot;,
            (unsigned long long) sentinel.current_epoch);
}
 
if (master-&gt;leader_epoch &lt; req_epoch &amp;&amp; sentinel.current_epoch &lt;= req_epoch)
{
        sdsfree(master-&gt;leader);
        master-&gt;leader = sdsnew(req_runid);
        master-&gt;leader_epoch = sentinel.current_epoch;
        …
}
return master-&gt;leader ? sdsnew(master-&gt;leader) : NULL;
</code></pre>
<p>那么现在，你就了解了 sentinelVoteLeader 函数是如何使用纪元判断来按照 Raft 协议完成哨兵 Leader 选举的了。</p>
<p>接下来，发起投票的哨兵仍然是通过 sentinelReceiveIsMasterDownReply 函数来处理其他哨兵对 Leader 投票的返回结果。这个返回结果，就像刚才给你介绍的，它的第二、三部分内容是哨兵 Leader 的 ID，和哨兵 Leader 所属的纪元。发起投票的哨兵就可以从这个结果中获得其他哨兵对 Leader 的投票结果了。</p>
<p>最后，发起投票的哨兵在调用了 sentinelAskMasterStateToOtherSentinels 函数让其他哨兵投票后，会执行 sentinelFailoverStateMachine 函数。</p>
<p>如果主节点开始执行故障切换了，那么，主节点的 failover_state，会被设置成 SENTINEL_FAILOVER_STATE_WAIT_START。在这种状态下，sentinelFailoverStateMachine 函数会调用 sentinelFailoverWaitStart 函数。而 sentinelFailoverWaitStart 函数，又会调用 sentinelGetLeader 函数，来判断发起投票的哨兵是否为哨兵 Leader。发起投票的哨兵要想成为 Leader，必须满足两个条件：</p>
<ul>
<li>一是，获得超过半数的其他哨兵的赞成票</li>
<li>二是，获得超过预设的 quorum 阈值的赞成票数。</li>
</ul>
<p>这两个条件，也可以从 sentinelGetLeader 函数中的代码片段看到，如下所示。</p>
<pre><code class="language-c">//voters是所有哨兵的个数，max_votes是获得的票数
 voters_quorum = voters/2+1;  //赞成票的数量必须是超过半数以上的哨兵个数
//如果赞成票数不到半数的哨兵个数或者少于quorum阈值，那么Leader就为NULL
 if (winner &amp;&amp; (max_votes &lt; voters_quorum || max_votes &lt; master-&gt;quorum))
        winner = NULL;
//确定最终的Leader
winner = winner ? sdsnew(winner) : NULL;
</code></pre>
<p>下图就展示了刚才介绍的确认哨兵 Leader 时的调用关系，你可以看下。</p>
<p><img src="assets/192b72d0cf77cfefee8e26952b4f1652-20221014000238-g48oqlj.jpg" alt="" /></p>
<p>好了，到这里，最终的哨兵 Leader 就能被确定了。</p>
<h2>小结</h2>
<p>好了，今天这节课的内容就到这里，我们来小结下。</p>
<p>今天这节课，我在上节课的基础上，重点给你介绍了哨兵工作过程中的客观下线判断，以及 Leader 选举。因为这个过程涉及哨兵之间的交互询问，所以并不容易掌握，你需要好好关注以下我提到的重点内容。</p>
<p>首先，客观下线的判断涉及三个标记的判断，分别是主节点 flags 中的 SRI_S_DOWN 和 SRI_O_DOWN，以及哨兵实例 flags 中的 SRI_MASTER_DOWN，我画了下面这张表，展示了这三个标记的设置函数和条件，你可以再整体回顾下。</p>
<p><img src="assets/738ea2375d2e302bb6742fa825650b1f-20221014000238-nlbeaj0.jpg" alt="" /></p>
<p>而一旦哨兵判断主节点客观下线了，那么哨兵就会<strong>调用 sentinelAskMasterStateToOtherSentinels 函数进行哨兵 Leader 选举</strong>。这里，你需要注意的是，向其他哨兵询问主节点主观下线状态，以及向其他哨兵发起 Leader 投票，都是通过 sentinel is-master-down-by-addr 命令实现的，而 Redis 源码是用了同一个函数 sentinelAskMasterStateToOtherSentinels 来发送该命令，所以你在阅读源码时，<strong>要注意区分 sentinelAskMasterStateToOtherSentinels 发送的命令是查询主节点主观下线状态还是进行投票</strong>。</p>
<p>最后，哨兵 Leader 选举的投票是在 sentinelVoteLeader 函数中完成的，为了符合 Raft 协议的规定，sentinelVoteLeader 函数在执行时主要是要比较哨兵的纪元，以及 master 记录的 Leader 纪元，这样才能满足 Raft 协议对 Follower 在一轮投票中只能投一票的要求。</p>
<p>好了，到今天这节课，我们就了解了哨兵 Leader 选举的过程，你可以看到，虽然哨兵选举的最后执行逻辑就是在一个函数中，但是哨兵选举的触发逻辑是包含在了哨兵的整个工作过程中的，所以我们也需要掌握这个过程中的其他操作，比如主观下线判断、客观下线判断等。</p>
<h2>每课一问</h2>
<p>哨兵在 sentinelTimer 函数中调用 sentinelHandleDictOfRedisInstances 函数，对每个主节点都执行 sentinelHandleRedisInstance 函数，并且还会对主节点的所有从节点也执行 sentinelHandleRedisInstance 函数，那么，哨兵会判断从节点的主观下线和客观下线吗？</p>
</div>
                        </div>
                        <div>
                            <div style="float: left">
                                <a href="23%20%20%E4%BB%8E%E5%93%A8%E5%85%B5Leader%E9%80%89%E4%B8%BE%E5%AD%A6%E4%B9%A0Raft%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89.md.html">上一页</a>
                            </div>
                            <div style="float: right">
                                <a href="25%20%20PubSub%E5%9C%A8%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%E6%97%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E6%8C%A5%E4%BD%9C%E7%94%A8%E7%9A%84%EF%BC%9F.md.html">下一页</a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="copyright"><p>© 2019 - 2023 <a href="../../cdn-cgi/l/email-protection.html#127e7e7e2b262323222552757f737b7e3c717d7f" target="_blank">Liangliang Lee</a>. Powered by <a href="https://vertx.io/" target="_blank">Vert.x</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p></div>
        </div>

        <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
    </div>
<script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script defer src="https://static.cloudflareinsights.com/beacon.min.js/vb26e4fa9e5134444860be286fd8771851679335129114" integrity="sha512-M3hN/6cva/SjwrOtyXeUa5IuCT0sedyfT+jK/OV+s+D0RnzrTfwjwJHhd+wYfMm9HJSrZ1IKksOdddLuN6KOzw==" data-cf-beacon='{"rayId":"7af00140d80a6450","version":"2023.3.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }

    hljs.initHighlightingOnLoad()

</script>

</html>
