<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>25  PubSub在主从故障切换时是如何发挥作用的？.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <link rel="stylesheet"
              href="../../static/highlight.min.css">
        <script src="../../static/highlight.min.js"></script>
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5295275829820252"
                crossorigin="anonymous"></script>
        <script async defer data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" src="https://analyze.lianglianglee.com/umami.js"></script>
    </head>

<body>

    <div class="book-container">
        <div class="book-sidebar">
            <div class="book-brand">
                <a href="../../index.html">
                    <img src="../../static/favicon.png">
                    <span>技术文章摘抄</span>
                </a>
            </div>
            <div class="book-menu uncollapsible">
                <ul class="uncollapsible">
                    <li><a href="../../index.html" class="current-tab">首页</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li><a href="../index.html">上一级</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li>

                        
                        <a href="00%20%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%20%E9%98%85%E8%AF%BBRedis%E6%BA%90%E7%A0%81%E8%83%BD%E7%BB%99%E4%BD%A0%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%EF%BC%9F.md.html">00  开篇词  阅读Redis源码能给你带来什么？.md</a>

                    </li>
                    <li>

                        
                        <a href="01%20%20%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%BB%E7%95%A5Redis%E6%BA%90%E7%A0%81%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.md.html">01  带你快速攻略Redis源码的整体架构.md</a>

                    </li>
                    <li>

                        
                        <a href="02%20%20%E9%94%AE%E5%80%BC%E5%AF%B9%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E7%94%A8char%E8%BF%98%E6%98%AF%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9F.md.html">02  键值对中字符串的实现，用char还是结构体？.md</a>

                    </li>
                    <li>

                        
                        <a href="03%20%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%80%A7%E8%83%BD%E4%BC%98%E5%BC%82%E7%9A%84Hash%E8%A1%A8%EF%BC%9F.md.html">03  如何实现一个性能优异的Hash表？.md</a>

                    </li>
                    <li>

                        
                        <a href="04%20%20%E5%86%85%E5%AD%98%E5%8F%8B%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A5%E5%A6%82%E4%BD%95%E7%BB%86%E5%8C%96%E8%AE%BE%E8%AE%A1%EF%BC%9F.md.html">04  内存友好的数据结构该如何细化设计？.md</a>

                    </li>
                    <li>

                        
                        <a href="05%20%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E4%B8%BA%E4%BD%95%E8%83%BD%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81%E7%82%B9%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%EF%BC%9F.md.html">05  有序集合为何能同时支持点查询和范围查询？.md</a>

                    </li>
                    <li>

                        
                        <a href="06%20%20%E4%BB%8Eziplist%E5%88%B0quicklist%EF%BC%8C%E5%86%8D%E5%88%B0listpack%E7%9A%84%E5%90%AF%E5%8F%91.md.html">06  从ziplist到quicklist，再到listpack的启发.md</a>

                    </li>
                    <li>

                        
                        <a href="07%20%20%E4%B8%BA%E4%BB%80%E4%B9%88Stream%E4%BD%BF%E7%94%A8%E4%BA%86Radix%20Tree%EF%BC%9F.md.html">07  为什么Stream使用了Radix Tree？.md</a>

                    </li>
                    <li>

                        
                        <a href="08%20%20Redis%20server%E5%90%AF%E5%8A%A8%E5%90%8E%E4%BC%9A%E5%81%9A%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%EF%BC%9F.md.html">08  Redis server启动后会做哪些操作？.md</a>

                    </li>
                    <li>

                        
                        <a href="09%20%20Redis%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8select%E3%80%81poll%E3%80%81epoll%EF%BC%9F.md.html">09  Redis事件驱动框架（上）：何时使用select、poll、epoll？.md</a>

                    </li>
                    <li>

                        
                        <a href="10%20%20Redis%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9ARedis%E5%AE%9E%E7%8E%B0%E4%BA%86Reactor%E6%A8%A1%E5%9E%8B%E5%90%97%EF%BC%9F.md.html">10  Redis事件驱动框架（中）：Redis实现了Reactor模型吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="11%20%20Redis%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9ARedis%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BA%8B%E4%BB%B6%EF%BC%9F.md.html">11  Redis事件驱动框架（下）：Redis有哪些事件？.md</a>

                    </li>
                    <li>

                        
                        <a href="12%20%20Redis%E7%9C%9F%E7%9A%84%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F.md.html">12  Redis真的是单线程吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="13%20%20Redis%206.0%E5%A4%9AIO%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%88%E7%8E%87%E6%8F%90%E9%AB%98%E4%BA%86%E5%90%97%EF%BC%9F.md.html">13  Redis 6.0多IO线程的效率提高了吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="14%20%20%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%9C%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E4%BF%9D%E8%AF%81.md.html">14  从代码实现看分布式锁的原子性保证.md</a>

                    </li>
                    <li>

                        
                        <a href="15%20%20%E4%B8%BA%E4%BB%80%E4%B9%88LRU%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%92%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F.md.html">15  为什么LRU算法原理和代码实现不一样？.md</a>

                    </li>
                    <li>

                        
                        <a href="16%20%20LFU%E7%AE%97%E6%B3%95%E5%92%8C%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BC%98%E5%8A%BF%E5%90%97%EF%BC%9F.md.html">16  LFU算法和其他算法相比有优势吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="17%20%20Lazy%20Free%E4%BC%9A%E5%BD%B1%E5%93%8D%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2%E5%90%97%EF%BC%9F.md.html">17  Lazy Free会影响缓存替换吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="18%20%20%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%92%8C%E8%A7%A3%E8%AF%BBRDB%E6%96%87%E4%BB%B6%EF%BC%9F.md.html">18  如何生成和解读RDB文件？.md</a>

                    </li>
                    <li>

                        
                        <a href="19%20%20AOF%E9%87%8D%E5%86%99%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA%E4%B8%8E%E9%87%8D%E5%86%99%E7%9A%84%E5%BD%B1%E5%93%8D.md.html">19  AOF重写（上）：触发时机与重写的影响.md</a>

                    </li>
                    <li>

                        
                        <a href="20%20%20AOF%E9%87%8D%E5%86%99%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84%E6%96%B0%E5%86%99%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F.md.html">20  AOF重写（下）：重写时的新写操作记录在哪里？.md</a>

                    </li>
                    <li>

                        
                        <a href="21%20%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.md.html">21  主从复制：基于状态机的设计与实现.md</a>

                    </li>
                    <li>

                        
                        <a href="22%20%20%E5%93%A8%E5%85%B5%E4%B9%9F%E5%92%8CRedis%E5%AE%9E%E4%BE%8B%E4%B8%80%E6%A0%B7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%97%EF%BC%9F.md.html">22  哨兵也和Redis实例一样初始化吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="23%20%20%E4%BB%8E%E5%93%A8%E5%85%B5Leader%E9%80%89%E4%B8%BE%E5%AD%A6%E4%B9%A0Raft%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89.md.html">23  从哨兵Leader选举学习Raft协议实现（上）.md</a>

                    </li>
                    <li>

                        
                        <a href="24%20%20%E4%BB%8E%E5%93%A8%E5%85%B5Leader%E9%80%89%E4%B8%BE%E5%AD%A6%E4%B9%A0Raft%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8B%EF%BC%89.md.html">24  从哨兵Leader选举学习Raft协议实现（下）.md</a>

                    </li>
                    <li>

                        <a class="current-tab" href="25%20%20PubSub%E5%9C%A8%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%E6%97%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E6%8C%A5%E4%BD%9C%E7%94%A8%E7%9A%84%EF%BC%9F.md.html">25  PubSub在主从故障切换时是如何发挥作用的？.md</a>
                        

                    </li>
                    <li>

                        
                        <a href="26%20%20%E4%BB%8EPing-Pong%E6%B6%88%E6%81%AF%E5%AD%A6%E4%B9%A0Gossip%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E7%8E%B0.md.html">26  从Ping-Pong消息学习Gossip协议的实现.md</a>

                    </li>
                    <li>

                        
                        <a href="27%20%20%E4%BB%8EMOVED%E3%80%81ASK%E7%9C%8B%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%EF%BC%9F.md.html">27  从MOVED、ASK看集群节点如何处理命令？.md</a>

                    </li>
                    <li>

                        
                        <a href="28%20%20Redis%20Cluster%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E4%BC%9A%E9%98%BB%E5%A1%9E%E5%90%97%EF%BC%9F.md.html">28  Redis Cluster数据迁移会阻塞吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="29%20%20%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9F.md.html">29  如何正确实现循环缓冲区？.md</a>

                    </li>
                    <li>

                        
                        <a href="30%20%20%E5%A6%82%E4%BD%95%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E7%9B%91%E6%8E%A7%EF%BC%9F.md.html">30  如何在系统中实现延迟监控？.md</a>

                    </li>
                    <li>

                        
                        <a href="31%20%20%E4%BB%8EModule%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AD%A6%E4%B9%A0%E5%8A%A8%E6%80%81%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD.md.html">31  从Module的实现学习动态扩展功能.md</a>

                    </li>
                    <li>

                        
                        <a href="32%20%20%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%9F.md.html">32  如何在一个系统中实现单元测试？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%BB%93%E6%9D%9F%E8%AF%AD%20%20Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%8C%E8%AE%A9%E6%88%91%E4%BB%AC%E4%BB%8E%E6%96%B0%E5%BC%80%E5%A7%8B.md.html">结束语  Redis源码阅读，让我们从新开始.md</a>

                    </li>
                </ul>

            </div>
        </div>

        <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
            <div class="sidebar-toggle-inner"></div>
        </div>

        <script>
            function add_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.add('show')
            }

            function remove_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.remove('show')
            }

            function sidebar_toggle() {
                let sidebar_toggle = document.querySelector('.sidebar-toggle')
                let sidebar = document.querySelector('.book-sidebar')
                let content = document.querySelector('.off-canvas-content')
                if (sidebar_toggle.classList.contains('extend')) { // show
                    sidebar_toggle.classList.remove('extend')
                    sidebar.classList.remove('hide')
                    content.classList.remove('extend')
                } else { // hide
                    sidebar_toggle.classList.add('extend')
                    sidebar.classList.add('hide')
                    content.classList.add('extend')
                }
            }


            function open_sidebar() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.add('show')
                overlay.classList.add('show')
            }
            function hide_canvas() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.remove('show')
                overlay.classList.remove('show')
            }

        </script>

        <div class="off-canvas-content">
            <div class="columns">
                <div class="column col-12 col-lg-12">
                    <div class="book-navbar">
                        <!-- For Responsive Layout -->
                        <header class="navbar">
                            <section class="navbar-section">
                                <a onclick="open_sidebar()">
                                    <i class="icon icon-menu"></i>
                                </a>
                            </section>
                        </header>
                    </div>
                    <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                        <div class="book-post">
                            <p id="tip" align="center"></p>
                            <div><h1>25  PubSub在主从故障切换时是如何发挥作用的？</h1>
<p>在前面两节课，我们学习了哨兵工作的基本过程：哨兵会使用 sentinelRedisInstance 结构体来记录主节点的信息，在这个结构体中又记录了监听同一主节点的其他哨兵的信息。<strong>那么，一个哨兵是如何获得其他哨兵的信息的呢？</strong></p>
<p>这其实就和哨兵在运行过程中，使用的**发布订阅（Pub/Sub）**通信方法有关了。Pub/Sub 通信方法可以让哨兵订阅一个或多个频道，当频道中有消息时，哨兵可以收到相应消息；同时，哨兵也可以向频道中发布自己生成的消息，以便订阅该频道的其他客户端能收到消息。</p>
<p>今天这节课，我就带你来了解发布订阅通信方法的实现，以及它在哨兵工作过程中的应用。同时，你还可以了解哨兵之间是如何发现彼此的，以及客户端是如何知道故障切换完成的。Pub/Sub 通信方法在分布式系统中可以用作多对多的信息交互，在学完这节课之后，当你要实现分布式节点间通信时，就可以把它应用起来。</p>
<p>好了，接下来，我们先来看下发布订阅通信方法的实现。</p>
<h2>发布订阅通信方法的实现</h2>
<p>发布订阅通信方法的基本模型是包含<strong>发布者、频道和订阅者</strong>，发布者把消息发布到频道上，而订阅者会订阅频道，一旦频道上有消息，频道就会把消息发送给订阅者。一个频道可以有多个订阅者，而对于一个订阅者来说，它也可以订阅多个频道，从而获得多个发布者发布的消息。</p>
<p>下图展示的就是发布者 - 频道 - 订阅者的基本模型，你可以看下。</p>
<p><img src="assets/b41f7bc078c210ef35d17bf3dc9be09d-20221014000254-298sfqw.jpg" alt="" /></p>
<h3>频道的实现</h3>
<p>了解了发布订阅方法的基本模型后，我们就来看下频道是如何实现的，因为在发布订阅通信方法中，频道很重要，它是发布者和订阅者之间通信的基础。</p>
<p>其实，Redis 的全局变量 server 使用了一个成员变量 <strong>pubsub_channels</strong> 来保存频道，pubsub_channels 的初始化是在 initServer 函数（在<a href="https://github.com/redis/redis/tree/5.0/src/server.c">server.c</a>文件中）中完成的。initServer 函数会调用 dictCreate 创建一个 <strong>keylistDictType 类型的哈希表</strong>，然后用这个哈希表来保存频道的信息，如下所示：</p>
<pre><code class="language-c">void initServer(void) {
…
server.pubsub_channels = dictCreate(&amp;keylistDictType,NULL);
…
}
</code></pre>
<p>注意，当哈希表是 keylistDictType 类型时，它保存的哈希项的 value 就是一个列表。而之所以采用这种类型来保存频道信息，是因为 Redis 把频道的名称作为哈希项的 key，而把订阅频道的订阅者作为哈希项的 value。就像刚才我们介绍的，一个频道可以有多个订阅者，所以 Redis 在实现时，就会用列表把订阅同一个频道的订阅者保存起来。</p>
<p>pubsub_channels 哈希表保存频道和订阅者的示意图如下所示：</p>
<p><img src="assets/21775d173b9db1650d3285a18d7d7a7f-20221014000254-xs8fmxc.jpg" alt="" /></p>
<p>了解了频道是如何实现的之后，下面我们再分别看下发布命令和订阅命令的实现。</p>
<h3>发布命令的实现</h3>
<p>发布命令在 Redis 的实现中对应的是 <strong>publish</strong>。我在【第 14 讲】中给你介绍过，Redis server 在初始化时，会初始化一个命令表 redisCommandTable，表中就记录了 Redis 支持的各种命令，以及对应的实现函数。</p>
<p>这张命令表是在 server.c 文件中定义的，当你需要了解 Redis 某个命令的具体实现函数时，一个快捷的方式就是在这张表中查找对应命令，然后就能定位到该命令的实现函数了。我们同样可以用这个方法来定位 publish 命令，这样就可以看到它<strong>对应的实现函数是 publishCommand</strong>（在<a href="https://github.com/redis/redis/tree/5.0/src/pubsub.c">pubsub.c</a>文件中），如下所示：</p>
<pre><code class="language-c">struct redisCommand redisCommandTable[] = {
…
{&quot;publish&quot;,publishCommand,3,&quot;pltF&quot;,0,NULL,0,0,0,0,0},
…
}
</code></pre>
<p>我们来看下 publishCommand 函数，它是调用 <strong>pubsubPublishMessage 函数</strong>（在 pubsub.c 文件中）来完成消息的实际发送，然后，再返回接收消息的订阅者数量的，如下所示：</p>
<pre><code class="language-c">void publishCommand(client *c) {
    //调用pubsubPublishMessage发布消息
    int receivers = pubsubPublishMessage(c-&gt;argv[1],c-&gt;argv[2]);
    … //如果Redis启用了cluster，那么在集群中发送publish命令
    addReplyLongLong(c,receivers); //返回接收消息的订阅者数量
}
</code></pre>
<p>而对于 pubsubPublishMessage 函数来说，它的原型如下。你可以看到，它的两个参数分别是要<strong>发布消息的频道</strong>，以及<strong>要发布的具体消息</strong>。</p>
<pre><code class="language-c">int pubsubPublishMessage(robj *channel, robj *message)
</code></pre>
<p>pubsubPublishMessage 函数会在 server.pubsub_channels 哈希表中，查找要发布的频道。如果找见了，它就会遍历这个 channel 对应的订阅者列表，然后依次向每个订阅者发送要发布的消息。这样一来，只要订阅者订阅了这个频道，那么发布者发布消息时，它就能收到了。</p>
<pre><code class="language-c">//查找频道是否存在
de = dictFind(server.pubsub_channels,channel);
    if (de) { //频道存在
        …
        //遍历频道对应的订阅者，向订阅者发送要发布的消息
        while ((ln = listNext(&amp;li)) != NULL) {
            client *c = ln-&gt;value;
            …
            addReplyBulk(c,channel);
            addReplyBulk(c,message);
            receivers++;
        }
    }
</code></pre>
<p>好了，了解了发布命令后，我们再来看下订阅命令的实现。</p>
<h3>订阅命令的实现</h3>
<p>和查找发布命令的方法一样，我们可以在 redisCommandTable 表中，找到订阅命令 <strong>subscribe</strong> 对应的实现函数是 <strong>subscribeCommand</strong>（在 pubsub.c 文件中）。</p>
<p>subscribeCommand 函数的逻辑比较简单，它会直接调用 pubsubSubscribeChannel 函数（在 pubsub.c 文件中）来完成订阅操作，如下所示：</p>
<pre><code class="language-c">void subscribeCommand(client *c) {
    int j;
    for (j = 1; j &lt; c-&gt;argc; j++)
        pubsubSubscribeChannel(c,c-&gt;argv[j]);
    c-&gt;flags |= CLIENT_PUBSUB;
}
</code></pre>
<p>从代码中，你可以看到，subscribeCommand 函数的参数是 client 类型的变量，而它会根据 client 的 <strong>argc</strong> 成员变量执行一个循环，并把 client 的每个 <strong>argv</strong> 成员变量传给 pubsubSubscribeChannel 函数执行。</p>
<p>对于 client 的 argc 和 argv 来说，它们分别代表了要执行命令的参数个数和具体参数值，那么，<strong>这里的参数值是指什么呢?</strong></p>
<p>其实，我们来看下 pubsubSubscribeChannel 函数的原型就能知道了，如下所示：</p>
<pre><code class="language-c">int pubsubSubscribeChannel(client *c, robj *channel)
</code></pre>
<p>pubsubSubscribeChannel 函数的参数除了 client 变量外，还会<strong>接收频道的信息</strong>，这也就是说，subscribeCommand 会按照 subscribe 执行时附带的频道名称，来逐个订阅频道。我也在下面展示了 subscribe 命令执行的一个示例，你可以看下。当这个 subscribe 命令执行时，它会订阅三个频道，分别是 channel1、channel2 和 channel3：</p>
<pre><code class="language-c">subscribe channel1 channel2 channel3
</code></pre>
<p>下面我们来具体看下 pubsubSubscribeChannel 函数的实现。这个函数的逻辑也比较清晰，主要可以分成三步。</p>
<p><strong>首先</strong>，它把要订阅的频道加入到 server 记录的 pubsub_channels 中。如果这个频道是新创建的，那么它会在 pubsub_channels 哈希表中新建一个哈希项，代表新创建的这个频道，并且会创建一个列表，用来保存这个频道对应的订阅者。</p>
<p>如果频道已经在 pubsub_channels 哈希表中存在了，那么 pubsubSubscribeChannel 函数就直接获取该频道对应的订阅者列表。</p>
<p><strong>然后</strong>，pubsubSubscribeChannel 函数把执行 subscribe 命令的订阅者，加入到订阅者列表中。</p>
<p><strong>最后</strong>，pubsubSubscribeChannel 函数会把成功订阅的频道个数返回给订阅者。</p>
<p>下面的代码展示了这部分的逻辑，你可以看下。</p>
<pre><code class="language-c">if (dictAdd(c-&gt;pubsub_channels,channel,NULL) == DICT_OK) {
   …
   de = dictFind(server.pubsub_channels,channel); //在pubsub_channels哈希表中查找频道
   if (de == NULL) { //如果频道不存在
      clients = listCreate();  //创建订阅者对应的列表
      dictAdd(server.pubsub_channels,channel,clients); //新插入频道对应的哈希项
      …
    } else {
      clients = dictGetVal(de); //频道已存在，获取订阅者列表
    }
    listAddNodeTail(clients,c); //将订阅者加入到订阅者列表
}
 
…
addReplyLongLong(c,clientSubscriptionsCount(c)); //给订阅者返回成功订阅的频道数量
</code></pre>
<p>现在，你就了解了 Redis 中发布订阅方法的实现。接下来，我们来看下哨兵在工作过程中，又是如何使用发布订阅功能的。</p>
<h2>发布订阅方法在哨兵中的应用</h2>
<p>首先，我们来看下哨兵用来发布消息的函数 sentinelEvent。</p>
<h3>sentinelEvent 函数与消息生成</h3>
<p>哨兵在使用发布订阅方法时，封装了 <strong>sentinelEvent 函数</strong>（在<a href="https://github.com/redis/redis/tree/5.0/src/sentinel.c">sentinel.c</a>文件中），用来发布消息。所以，你在阅读 sentinel.c 文件中关于哨兵的源码时，如果看到 sentinelEvent，这就表明哨兵正在用它来发布消息。</p>
<p>我在【第 22 讲】中给你介绍过 sentinelEvent 函数，你可以再回顾下。这个函数的原型如下所示：</p>
<pre><code class="language-c">void sentinelEvent(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...) 
</code></pre>
<p>实际上，这个函数最终是通过调用刚才我提到的 pubsubPublishMessage 函数，来实现向某一个频道发布消息的。那么，当我们要发布一条消息时，需要确定两个方面的内容：<strong>一个是要发布的频道，另一个是要发布的消息</strong>。</p>
<p>sentinelEvent 函数的第二个参数 type，表示的就是要发布的频道，而要发布的消息，就是由这个函数第四个参数 fmt 后面的省略号来表示的。</p>
<p>看到这里，你可以会有一个疑问，<strong>为什么 sentinelEvent 函数参数中会有省略号？</strong></p>
<p>其实，这里的省略号表示的是<strong>可变参数</strong>，当我们无法列出传递给函数的所有实参类型和数目时，我们可以用省略号来表示可变参数，这就是说，我们可以给 sentinelEvent 函数传递 4 个、5 个、6 个甚至更多的参数。</p>
<p>我在这里就以 sentinelEvent 函数的实现为例，给你介绍下可变参数的使用，这样一来，当你在开发分布式通信程序时，需要生成内容不定的消息时，就可以把哨兵源码中实现的方法用起来。</p>
<p>在 sentinelEvent 函数中，为了使用了可变参数，它主要包含了四个步骤：</p>
<ul>
<li>首先，我们需要定义一个 va_list 类型的变量，假设是 ap。这个变量是指向可变参数的指针。</li>
<li>然后，当我们要在函数中使用可变参数了，就需要通过 <strong>va_start 宏</strong>来获取可变参数中的第一个参数。va_start 宏有两个参数，一个是刚才定义的 va_list 类型变量 ap，另一个是可变参数的前一个参数，也就是 sentinelEvent 函数参数中，省略号前的参数 fmt。</li>
<li>紧接着，我们可以使用 vsnprintf 函数，来按照 fmt 定义的格式，打印可变参数中的内容。vsnprintf 函数会逐个获取可变参数中的每一个参数，并进行打印。</li>
<li>最后，我们在获取完所有参数后，需要调用 va_end 宏将刚才创建的 ap 指针关闭。</li>
</ul>
<p>下面的代码展示了刚才介绍的这个过程，你可以再看下。</p>
<pre><code class="language-c">void sentinelEvent(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...) {
    va_list ap;
    ... 
    if (fmt[0] != '\0') {
        va_start(ap, fmt);
        vsnprintf(msg+strlen(msg), sizeof(msg)-strlen(msg), fmt, ap);
        va_end(ap);
    }
    ...
}
</code></pre>
<p>为了让你有个更加直观的了解，我在下面列了三个 sentinelEvent 函数的调用示例，你可以再学习掌握下。</p>
<p>第一个对应了哨兵调用 sentinelCheckSubjectivelyDown 函数<strong>检测出主节点主观下线后</strong>，sentinelCheckSubjectivelyDown 函数调用 sentinelEvent 函数，向“+sdown”频道发布消息。此时，传递给 sentinelEvent 的参数就是 4 个，并没有可变参数，如下所示：</p>
<pre><code class="language-c">sentinelEvent(LL_WARNING,&quot;+sdown&quot;,ri,&quot;%@&quot;);
</code></pre>
<p>第二个对应了<strong>哨兵在初始化时</strong>，在 sentinelGenerateInitialMonitorEvents 函数中，调用 sentinelEvent 函数向“+monitor”频道发布消息，此时，传递给 sentinelEvent 的参数有 5 个，包含了 1 个可变参数，表示的是哨兵的 quorum 阈值，如下所示：</p>
<pre><code class="language-c">sentinelEvent(LL_WARNING,&quot;+monitor&quot;,ri,&quot;%@ quorum %d&quot;,ri-&gt;quorum);
</code></pre>
<p>最后一个对应了<strong>哨兵在完成主节点切换后</strong>，在 sentinelFailoverSwitchToPromotedSlave 函数中，调用 sentinelEvent 函数向“+switch-master”频道发布消息。此时，传递给 sentinelEvent 的可变参数一共有 5 个，对应了故障切换前的主节点名称、IP 和端口号，以及切换后升级为主节点的从节点 IP 和端口号，如下所示：</p>
<pre><code class="language-c">sentinelEvent(LL_WARNING,&quot;+switch-master&quot;,master,&quot;%s %s %d %s %d&quot;,
        master-&gt;name, master-&gt;addr-&gt;ip, master-&gt;addr-&gt;port,
        ref-&gt;addr-&gt;ip, ref-&gt;addr-&gt;port);
</code></pre>
<p>这样一来，你也就了解了，哨兵在工作过程中是通过 sentinelEvent 函数和 pubsubPublishMessage 函数，来实现消息的发布的。在哨兵的整个工作过程中，它会在一些关键节点上，<strong>使用 sentinelEvent 函数往不同的频道上发布消息</strong>。除了刚才给你举例的三个频道 +monitor、+sdown、+switch-master 以外，我还把哨兵在工作过程中会用到的消息发布频道列在了下表中，你可以了解下。</p>
<p><img src="assets/53c920eec89a2108351d816a80cbe272-20221014000254-xggnu7x.jpg" alt="" /></p>
<p>其实，在哨兵的工作过程中，如果有客户端想要了解故障切换的整体情况或进度，比如主节点是否被判断为主观下线、主节点是否被判断为客观下线、Leader 是否完成选举、新主节点是否切换完成，等等，就可以通过 subscribe 命令，订阅上面这张表中的相应频道。这样一来，客户端就可以了解故障切换的过程了。</p>
<p>好，下面我们再来看下，哨兵在工作过程中对消息的订阅是如何实现的。</p>
<h3>哨兵订阅与 hello 频道</h3>
<p>首先你要知道，每个哨兵会订阅它所监听的主节点的&quot;<strong>sentinel</strong>:hello&quot;频道。在【第 23 讲】中，我给你介绍过，哨兵会周期性调用 sentinelTimer 函数来完成周期性的任务，这其中，就有哨兵订阅主节点 hello 频道的操作。</p>
<p>具体来说，哨兵在周期性执行 sentinelTimer 函数时，会调用 sentinelHandleRedisInstance 函数，进而调用 sentinelReconnectInstance 函数。而在 sentinelReconnectInstance 函数中，哨兵会调用 redisAsyncCommand 函数，向主节点发送 subscribe 命令，订阅的频道由宏定义 SENTINEL_HELLO_CHANNEL（在 sentinel.c 文件中）指定，也就是&quot;<strong>sentinel</strong>:hello&quot;频道。这部分的代码如下所示：</p>
<pre><code class="language-c">retval = redisAsyncCommand(link-&gt;pc,
                sentinelReceiveHelloMessages, ri, &quot;%s %s&quot;,
                sentinelInstanceMapCommand(ri,&quot;SUBSCRIBE&quot;),
                SENTINEL_HELLO_CHANNEL);
</code></pre>
<p>从代码中，我们也可以看到，当在&quot;<strong>sentinel</strong>:hello&quot;频道上收到 hello 消息后，哨兵会回调 sentinelReceiveHelloMessages 函数来进行处理。而 sentinelReceiveHelloMessages 函数，实际是通过调用 <strong>sentinelProcessHelloMessage 函数</strong>，来完成 hello 消息的处理的。</p>
<p>对于 sentinelProcessHelloMessage 函数来说，它主要是从 hello 消息中获得发布 hello 消息的哨兵实例的基本信息，比如 IP、端口号、quorum 阈值等。如果当前哨兵并没有记录发布 hello 消息的哨兵实例的信息，那么，sentinelProcessHelloMessage 函数就会调用 <strong>createSentinelRedisInstance 函数</strong>，来创建发布 hello 消息的哨兵实例的信息记录，这样一来，当前哨兵就拥有了其他哨兵实例的信息了。</p>
<p>好了，了解了哨兵对&quot;<strong>sentinel</strong>:hello&quot;频道的订阅和处理后，我们还需要搞清楚一个问题，即<strong>哨兵是在什么时候发布 hello 消息的呢？</strong></p>
<p>这其实是哨兵在 sentinelTimer 函数中，调用 sentinelSendPeriodicCommands 函数时，由 sentinelSendPeriodicCommands 函数调用 sentinelSendHello 函数来完成的。</p>
<p><strong>sentinelSendHello 函数</strong>会调用 redisAsyncCommand 函数，向主节点的&quot;<strong>sentinel</strong>:hello&quot;频道发布 hello 消息。在它发送的 hello 消息中，包含了发布 hello 消息的哨兵实例的 IP、端口号、ID 和当前的纪元，以及该哨兵监听的主节点的名称、IP、端口号和纪元信息。</p>
<p>下面的代码就展示了 hello 消息的生成和发布，你可以看下。</p>
<pre><code class="language-c">//hello消息包含的内容
snprintf(payload,sizeof(payload),
        &quot;%s,%d,%s,%llu,&quot; //当前哨兵实例的信息，包括ip、端口号、ID和当前纪元
        &quot;%s,%s,%d,%llu&quot;, //当前主节点的信息，包括名称、IP、端口号和纪元
        announce_ip, announce_port, sentinel.myid,
        (unsigned long long) sentinel.current_epoch,
        master-&gt;name,master_addr-&gt;ip,master_addr-&gt;port,
        (unsigned long long) master-&gt;config_epoch);
//向主节点的hello频道发布hello消息
retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
        sentinelPublishReplyCallback, ri, &quot;%s %s %s&quot;,
        sentinelInstanceMapCommand(ri,&quot;PUBLISH&quot;),
        SENTINEL_HELLO_CHANNEL,payload);
</code></pre>
<p>这样，当哨兵通过 sentinelSendHello，向自己监听的主节点的&quot;<strong>sentinel</strong>:hello&quot;频道发布 hello 消息时，和该哨兵监听同一个主节点的其他哨兵，也会订阅主节点的&quot;<strong>sentinel</strong>:hello&quot;频道，从而就可以获得该频道上的 hello 消息了。</p>
<p>通过这样的通信方式，监听同一主节点的哨兵就能相互知道彼此的访问信息了。如此一来，哨兵就可以基于这些访问信息，执行主节点状态共同判断，以及进行 Leader 选举等操作了。</p>
<h2>小结</h2>
<p>今天这节课，我们了解了 Redis 实现的发布订阅通信方法。这个方法是提供了频道的方式，让要通信的双方按照频道来完成消息交互。而<strong>不同频道的不同名称，就代表了哨兵工作过程中的不同状态</strong>。当客户端需要了解哨兵的工作进度或是主节点的状态判断时，就可以通过订阅哨兵发布消息的频道来完成。</p>
<p>当然，对于一个哨兵来说，它一定会订阅的频道是它所监听的主节点的&quot;<strong>sentinel</strong>:hello&quot;频道。通过这个频道，监听同一主节点的不同哨兵就能通过频道上的 hello 消息，来交互彼此的访问信息了，比如哨兵的 IP、端口号等。</p>
<p>此外，在这节课，我还给你介绍了一个 <strong>C 语言函数可变参数的使用小技巧</strong>，当你开发发布订阅功能时，都需要生成发布的消息，而可变参数就可以用来生成长度不定的消息。希望你能把这个小技巧应用起来。</p>
<h2>每课一问</h2>
<p>如果我们在哨兵实例上执行 publish 命令，那么，这条命令是不是就是由 pubsub.c 文件中的 publishCommand 函数来处理的呢?</p>
</div>
                        </div>
                        <div>
                            <div style="float: left">
                                <a href="24%20%20%E4%BB%8E%E5%93%A8%E5%85%B5Leader%E9%80%89%E4%B8%BE%E5%AD%A6%E4%B9%A0Raft%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8B%EF%BC%89.md.html">上一页</a>
                            </div>
                            <div style="float: right">
                                <a href="26%20%20%E4%BB%8EPing-Pong%E6%B6%88%E6%81%AF%E5%AD%A6%E4%B9%A0Gossip%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E7%8E%B0.md.html">下一页</a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="copyright"><p>© 2019 - 2023 <a href="../../cdn-cgi/l/email-protection.html#69050505505d5858595e290e04080005470a0604" target="_blank">Liangliang Lee</a>. Powered by <a href="https://vertx.io/" target="_blank">Vert.x</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p></div>
        </div>

        <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
    </div>
<script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script defer src="https://static.cloudflareinsights.com/beacon.min.js/vb26e4fa9e5134444860be286fd8771851679335129114" integrity="sha512-M3hN/6cva/SjwrOtyXeUa5IuCT0sedyfT+jK/OV+s+D0RnzrTfwjwJHhd+wYfMm9HJSrZ1IKksOdddLuN6KOzw==" data-cf-beacon='{"rayId":"7af001458dfa6450","version":"2023.3.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }

    hljs.initHighlightingOnLoad()

</script>

</html>
