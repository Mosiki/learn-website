<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>21 Java并发类库提供的线程池有哪几种？ 分别有什么特点？.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <link rel="stylesheet"
              href="../../static/highlight.min.css">
        <script src="../../static/highlight.min.js"></script>
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5295275829820252"
                crossorigin="anonymous"></script>
        <script async defer data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" src="https://analyze.lianglianglee.com/umami.js"></script>
    </head>

<body>

    <div class="book-container">
        <div class="book-sidebar">
            <div class="book-brand">
                <a href="../../index.html">
                    <img src="../../static/favicon.png">
                    <span>技术文章摘抄</span>
                </a>
            </div>
            <div class="book-menu uncollapsible">
                <ul class="uncollapsible">
                    <li><a href="../../index.html" class="current-tab">首页</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li><a href="../index.html">上一级</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li>

                        
                        <a href="00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%E4%BB%A5%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%BA%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%8C%E6%9C%89%E6%95%88%E6%8F%90%E5%8D%87%E4%BD%A0%E7%9A%84Java%E5%86%85%E5%8A%9F.md.html">00 开篇词 以面试题为切入点，有效提升你的Java内功.md</a>

                    </li>
                    <li>

                        
                        <a href="01%20%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Java%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F.md.html">01 谈谈你对Java平台的理解？.md</a>

                    </li>
                    <li>

                        
                        <a href="02%20Exception%E5%92%8CError%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md.html">02 Exception和Error有什么区别？.md</a>

                    </li>
                    <li>

                        
                        <a href="03%20%E8%B0%88%E8%B0%88final%E3%80%81finally%E3%80%81%20finalize%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F.md.html">03 谈谈final、finally、 finalize有什么不同？.md</a>

                    </li>
                    <li>

                        
                        <a href="04%20%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md.html">04 强引用、软引用、弱引用、幻象引用有什么区别？.md</a>

                    </li>
                    <li>

                        
                        <a href="05%20String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md.html">05 String、StringBuffer、StringBuilder有什么区别？.md</a>

                    </li>
                    <li>

                        
                        <a href="06%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F.md.html">06 动态代理是基于什么原理？.md</a>

                    </li>
                    <li>

                        
                        <a href="07%20int%E5%92%8CInteger%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md.html">07 int和Integer有什么区别？.md</a>

                    </li>
                    <li>

                        
                        <a href="08%20%E5%AF%B9%E6%AF%94Vector%E3%80%81ArrayList%E3%80%81LinkedList%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F.md.html">08 对比Vector、ArrayList、LinkedList有何区别？.md</a>

                    </li>
                    <li>

                        
                        <a href="09%20%E5%AF%B9%E6%AF%94Hashtable%E3%80%81HashMap%E3%80%81TreeMap%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F.md.html">09 对比Hashtable、HashMap、TreeMap有什么不同？.md</a>

                    </li>
                    <li>

                        
                        <a href="10%20%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%9B%86%E5%90%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84_%20ConcurrentHashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%9C%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F.md.html">10 如何保证集合是线程安全的_ ConcurrentHashMap如何实现高效地线程安全？.md</a>

                    </li>
                    <li>

                        
                        <a href="11%20Java%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9BIO%E6%96%B9%E5%BC%8F%EF%BC%9F%20NIO%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F.md.html">11 Java提供了哪些IO方式？ NIO如何实现多路复用？.md</a>

                    </li>
                    <li>

                        
                        <a href="12%20Java%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%93%AA%E4%B8%80%E7%A7%8D%E6%9C%80%E9%AB%98%E6%95%88%EF%BC%9F.md.html">12 Java有几种文件拷贝方式？哪一种最高效？.md</a>

                    </li>
                    <li>

                        
                        <a href="13%20%E8%B0%88%E8%B0%88%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md.html">13 谈谈接口和抽象类有什么区别？.md</a>

                    </li>
                    <li>

                        
                        <a href="14%20%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F.md.html">14 谈谈你知道的设计模式？.md</a>

                    </li>
                    <li>

                        
                        <a href="15%20synchronized%E5%92%8CReentrantLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F.md.html">15 synchronized和ReentrantLock有什么区别呢？.md</a>

                    </li>
                    <li>

                        
                        <a href="16%20synchronized%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E3%80%81%E9%99%8D%E7%BA%A7%EF%BC%9F.md.html">16 synchronized底层如何实现？什么是锁的升级、降级？.md</a>

                    </li>
                    <li>

                        
                        <a href="17%20%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8start()%E6%96%B9%E6%B3%95%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F.md.html">17 一个线程两次调用start()方法会出现什么情况？.md</a>

                    </li>
                    <li>

                        
                        <a href="18%20%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8BJava%E7%A8%8B%E5%BA%8F%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E3%80%81%E4%BF%AE%E5%A4%8D%EF%BC%9F.md.html">18 什么情况下Java程序会产生死锁？如何定位、修复？.md</a>

                    </li>
                    <li>

                        
                        <a href="19%20Java%E5%B9%B6%E5%8F%91%E5%8C%85%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9F.md.html">19 Java并发包提供了哪些并发工具类？.md</a>

                    </li>
                    <li>

                        
                        <a href="20%20%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84ConcurrentLinkedQueue%E5%92%8CLinkedBlockingQueue%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md.html">20 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？.md</a>

                    </li>
                    <li>

                        <a class="current-tab" href="21%20Java%E5%B9%B6%E5%8F%91%E7%B1%BB%E5%BA%93%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%20%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F.md.html">21 Java并发类库提供的线程池有哪几种？ 分别有什么特点？.md</a>
                        

                    </li>
                    <li>

                        
                        <a href="22%20AtomicInteger%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%A7%E5%93%81%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%BA%94%E7%94%A8CAS%E6%93%8D%E4%BD%9C%EF%BC%9F.md.html">22 AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？.md</a>

                    </li>
                    <li>

                        
                        <a href="23%20%E8%AF%B7%E4%BB%8B%E7%BB%8D%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F.md.html">23 请介绍类加载过程，什么是双亲委派模型？.md</a>

                    </li>
                    <li>

                        
                        <a href="24%20%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AAJava%E7%B1%BB%EF%BC%9F.md.html">24 有哪些方法可以在运行时动态生成一个Java类？.md</a>

                    </li>
                    <li>

                        
                        <a href="25%20%E8%B0%88%E8%B0%88JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%88%92%E5%88%86%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9FOutOfMemoryError_.md.html">25 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError_.md</a>

                    </li>
                    <li>

                        
                        <a href="26%20%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%92%8C%E8%AF%8A%E6%96%ADJVM%E5%A0%86%E5%86%85%E5%92%8C%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%9F.md.html">26 如何监控和诊断JVM堆内和堆外内存使用？.md</a>

                    </li>
                    <li>

                        
                        <a href="27%20Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F.md.html">27 Java常见的垃圾收集器有哪些？.md</a>

                    </li>
                    <li>

                        
                        <a href="28%20%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84GC%E8%B0%83%E4%BC%98%E6%80%9D%E8%B7%AF_.md.html">28 谈谈你的GC调优思路_.md</a>

                    </li>
                    <li>

                        
                        <a href="29%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84happen-before%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.md.html">29 Java内存模型中的happen-before是什么？.md</a>

                    </li>
                    <li>

                        
                        <a href="30%20Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9C%A8Docker%E7%AD%89%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E9%97%AE%E9%A2%98%EF%BC%9F.md.html">30 Java程序运行在Docker等容器环境有哪些新问题？.md</a>

                    </li>
                    <li>

                        
                        <a href="31%20%E4%BD%A0%E4%BA%86%E8%A7%A3Java%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%90%97%EF%BC%9F.md.html">31 你了解Java应用开发中的注入攻击吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="32%20%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E5%AE%89%E5%85%A8%E7%9A%84Java%E4%BB%A3%E7%A0%81%EF%BC%9F.md.html">32 如何写出安全的Java代码？.md</a>

                    </li>
                    <li>

                        
                        <a href="33%20%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%87%BA%E7%8E%B0%E6%98%8E%E6%98%BE%E2%80%9C%E5%8F%98%E6%85%A2%E2%80%9D%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E8%AF%8A%E6%96%AD%E6%80%9D%E8%B7%AF%EF%BC%9F.md.html">33 后台服务出现明显“变慢”，谈谈你的诊断思路？.md</a>

                    </li>
                    <li>

                        
                        <a href="34%20%E6%9C%89%E4%BA%BA%E8%AF%B4%E2%80%9CLambda%E8%83%BD%E8%AE%A9Java%E7%A8%8B%E5%BA%8F%E6%85%A230%E5%80%8D%E2%80%9D%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E7%9C%8B%EF%BC%9F.md.html">34 有人说“Lambda能让Java程序慢30倍”，你怎么看？.md</a>

                    </li>
                    <li>

                        
                        <a href="35%20JVM%E4%BC%98%E5%8C%96Java%E4%BB%A3%E7%A0%81%E6%97%B6%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.md.html">35 JVM优化Java代码时都做了什么？.md</a>

                    </li>
                    <li>

                        
                        <a href="36%20%E8%B0%88%E8%B0%88MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F.md.html">36 谈谈MySQL支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？.md</a>

                    </li>
                    <li>

                        
                        <a href="37%20%E8%B0%88%E8%B0%88Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F.md.html">37 谈谈Spring Bean的生命周期和作用域？.md</a>

                    </li>
                    <li>

                        
                        <a href="38%20%E5%AF%B9%E6%AF%94Java%E6%A0%87%E5%87%86NIO%E7%B1%BB%E5%BA%93%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93Netty%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9B%B4%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%90%97%EF%BC%9F.md.html">38 对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？.md</a>

                    </li>
                    <li>

                        
                        <a href="39%20%E8%B0%88%E8%B0%88%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8FID%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%EF%BC%9FSnowflake%E6%98%AF%E5%90%A6%E5%8F%97%E5%86%AC%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E5%BD%B1%E5%93%8D%EF%BC%9F.md.html">39 谈谈常用的分布式ID的设计方案？Snowflake是否受冬令时切换影响？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%91%A8%E6%9C%AB%E7%A6%8F%E5%88%A9%20%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9Java%E5%AD%A6%E4%B9%A0%E5%92%8C%E9%9D%A2%E8%AF%95%E7%9A%84%E7%9C%8B%E6%B3%95.md.html">周末福利 谈谈我对Java学习和面试的看法.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%BB%93%E6%9D%9F%E8%AF%AD%20%E6%8A%80%E6%9C%AF%E6%B2%A1%E6%9C%89%E7%BB%88%E7%82%B9.md.html">结束语 技术没有终点.md</a>

                    </li>
                </ul>

            </div>
        </div>

        <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
            <div class="sidebar-toggle-inner"></div>
        </div>

        <script>
            function add_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.add('show')
            }

            function remove_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.remove('show')
            }

            function sidebar_toggle() {
                let sidebar_toggle = document.querySelector('.sidebar-toggle')
                let sidebar = document.querySelector('.book-sidebar')
                let content = document.querySelector('.off-canvas-content')
                if (sidebar_toggle.classList.contains('extend')) { // show
                    sidebar_toggle.classList.remove('extend')
                    sidebar.classList.remove('hide')
                    content.classList.remove('extend')
                } else { // hide
                    sidebar_toggle.classList.add('extend')
                    sidebar.classList.add('hide')
                    content.classList.add('extend')
                }
            }


            function open_sidebar() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.add('show')
                overlay.classList.add('show')
            }
            function hide_canvas() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.remove('show')
                overlay.classList.remove('show')
            }

        </script>

        <div class="off-canvas-content">
            <div class="columns">
                <div class="column col-12 col-lg-12">
                    <div class="book-navbar">
                        <!-- For Responsive Layout -->
                        <header class="navbar">
                            <section class="navbar-section">
                                <a onclick="open_sidebar()">
                                    <i class="icon icon-menu"></i>
                                </a>
                            </section>
                        </header>
                    </div>
                    <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                        <div class="book-post">
                            <p id="tip" align="center"></p>
                            <div><h1>21 Java并发类库提供的线程池有哪几种？ 分别有什么特点？</h1>
<p>我在[专栏第17讲]中介绍过线程是不能够重复启动的，创建或销毁线程存在一定的开销，所以利用线程池技术来提高系统资源利用效率，并简化线程管理，已经是非常成熟的选择。</p>
<p>今天我要问你的问题是，Java并发类库提供的线程池有哪几种？ 分别有什么特点？</p>
<h2>典型回答</h2>
<p>通常开发者都是利用Executors提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的ExecutorService类型或者不同的初始参数。</p>
<p>Executors目前提供了5种不同的线程池创建配置：</p>
<ul>
<li>
<p>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用SynchronousQueue作为工作队列。</p>
</li>
<li>
<p>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads。</p>
</li>
<li>
<p>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</p>
</li>
<li>
<p>newSingleThreadScheduledExecutor()和newScheduledThreadPool(int corePoolSize)，创建的是个ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</p>
</li>
<li>
<p>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8才加入这个创建方法，其内部会构建<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a>，利用<a href="https://en.wikipedia.org/wiki/Work_stealing">Work-Stealing</a>算法，并行地处理任务，不保证处理顺序。</p>
</li>
</ul>
<h2>考点分析</h2>
<p>Java并发包中的Executor框架无疑是并发编程中的重点，今天的题目考察的是对几种标准线程池的了解，我提供的是一个针对最常见的应用方式的回答。</p>
<p>在大多数应用场景下，使用Executors提供的5个静态工厂方法就足够了，但是仍然可能需要直接利用ThreadPoolExecutor等构造函数创建，这就要求你对线程构造方式有进一步的了解，你需要明白线程池的设计和结构。</p>
<p>另外，线程池这个定义就是个容易让人误解的术语，因为ExecutorService除了通常意义上“池”的功能，还提供了更全面的线程管理、任务提交等方法。</p>
<p>Executor框架可不仅仅是线程池，我觉得至少下面几点值得深入学习：</p>
<ul>
<li>
<p>掌握Executor框架的主要内容，至少要了解组成与职责，掌握基本开发用例中的使用。</p>
</li>
<li>
<p>对线程池和相关并发工具类型的理解，甚至是源码层面的掌握。</p>
</li>
<li>
<p>实践中有哪些常见问题，基本的诊断思路是怎样的。</p>
</li>
<li>
<p>如何根据自身应用特点合理使用线程池。</p>
</li>
</ul>
<h2>知识扩展</h2>
<p>首先，我们来看看Executor框架的基本组成，请参考下面的类图。</p>
<p><img src="assets/fc70c37867c7fbfb672fa3e37fe14b5b.png" alt="" /></p>
<p>我们从整体上把握一下各个类型的主要设计目的：</p>
<ul>
<li>Executor是一个基础的接口，其初衷是将任务提交和任务执行细节解耦，这一点可以体会其定义的唯一方法。</li>
</ul>
<pre><code class="language-java">    void execute(Runnable command);
</code></pre>
<p>Executor的设计是源于Java早期线程API使用的教训，开发者在实现应用逻辑时，被太多线程创建、调度等不相关细节所打扰。就像我们进行HTTP通信，如果还需要自己操作TCP握手，开发效率低下，质量也难以保证。</p>
<ul>
<li>ExecutorService则更加完善，不仅提供service的管理功能，比如shutdown等方法，也提供了更加全面的提交任务机制，如返回<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Future.html">Future</a>而不是void的submit方法。</li>
</ul>
<pre><code class="language-java">    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
</code></pre>
<p>注意，这个例子输入的可是<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Callable.html">Callable</a>，它解决了Runnable无法返回结果的困扰。</p>
<ul>
<li>
<p>Java标准类库提供了几种基础实现，比如<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a>、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">ScheduledThreadPoolExecutor</a>、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a>。这些线程池的设计特点在于其高度的可调节性和灵活性，以尽量满足复杂多变的实际应用场景，我会进一步分析其构建部分的源码，剖析这种灵活性的源头。</p>
</li>
<li>
<p>Executors则从简化使用的角度，为我们提供了各种方便的静态工厂方法。</p>
</li>
</ul>
<p>下面我就从源码角度，分析线程池的设计与实现，我将主要围绕最基础的ThreadPoolExecutor源码。ScheduledThreadPoolExecutor是ThreadPoolExecutor的扩展，主要是增加了调度逻辑，如想深入了解，你可以参考相关<a href="https://www.journaldev.com/2340/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example">教程</a>。而ForkJoinPool则是为ForkJoinTask定制的线程池，与通常意义的线程池有所不同。</p>
<p>这部分内容比较晦涩，罗列概念也不利于你去理解，所以我会配合一些示意图来说明。在现实应用中，理解应用与线程池的交互和线程池的内部工作过程，你可以参考下图。</p>
<p><img src="assets/18b64aee22c67f488171a73133e4d465.png" alt="" /></p>
<p>简单理解一下：</p>
<ul>
<li>工作队列负责存储用户提交的各个任务，这个工作队列，可以是容量为0的SynchronousQueue（使用newCachedThreadPool），也可以是像固定大小线程池（newFixedThreadPool）那样使用LinkedBlockingQueue。</li>
</ul>
<pre><code class="language-java">    private final BlockingQueue&lt;Runnable&gt; workQueue;
</code></pre>
<ul>
<li>内部的“线程池”，这是指保持工作线程的集合，线程池需要在运行过程中管理线程创建、销毁。例如，对于带缓存的线程池，当任务压力较大时，线程池会创建新的工作线程；当业务压力退去，线程池会在闲置一段时间（默认60秒）后结束线程。</li>
</ul>
<pre><code class="language-java">    private final HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;();
</code></pre>
<p>线程池的工作线程被抽象为静态内部类Worker，基于<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html">AQS</a>实现。</p>
<ul>
<li>
<p>ThreadFactory提供上面所需要的创建线程逻辑。</p>
</li>
<li>
<p>如果任务提交时被拒绝，比如线程池已经处于SHUTDOWN状态，需要为其提供处理逻辑，Java标准库提供了类似<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html">ThreadPoolExecutor.AbortPolicy</a>等默认实现，也可以按照实际需求自定义。</p>
</li>
</ul>
<p>从上面的分析，就可以看出线程池的几个基本组成部分，一起都体现在线程池的构造函数中，从字面我们就可以大概猜测到其用意：</p>
<ul>
<li>
<p>corePoolSize，所谓的核心线程数，可以大致理解为长期驻留的线程数目（除非设置了allowCoreThreadTimeOut）。对于不同的线程池，这个值可能会有很大区别，比如newFixedThreadPool会将其设置为nThreads，而对于newCachedThreadPool则是为0。</p>
</li>
<li>
<p>maximumPoolSize，顾名思义，就是线程不够时能够创建的最大线程数。同样进行对比，对于newFixedThreadPool，当然就是nThreads，因为其要求是固定大小，而newCachedThreadPool则是Integer.MAX_VALUE。</p>
</li>
<li>
<p>keepAliveTime和TimeUnit，这两个参数指定了额外的线程能够闲置多久，显然有些线程池不需要它。</p>
</li>
<li>
<p>workQueue，工作队列，必须是BlockingQueue。</p>
</li>
</ul>
<p>通过配置不同的参数，我们就可以创建出行为大相径庭的线程池，这就是线程池高度灵活性的基础。</p>
<pre><code class="language-java">    public ThreadPoolExecutor(int corePoolSize,
                          	int maximumPoolSize,
                          	long keepAliveTime,
                          	TimeUnit unit,
                          	BlockingQueue&lt;Runnable&gt; workQueue,
                          	ThreadFactory threadFactory,
                          	RejectedExecutionHandler handler)
</code></pre>
<p>进一步分析，线程池既然有生命周期，它的状态是如何表征的呢？</p>
<p>这里有一个非常有意思的设计，ctl变量被赋予了双重角色，通过高低位的不同，既表示线程池状态，又表示工作线程数目，这是一个典型的高效优化。试想，实际系统中，虽然我们可以指定线程极限为Integer.MAX_VALUE，但是因为资源限制，这只是个理论值，所以完全可以将空闲位赋予其他意义。</p>
<pre><code class="language-java">    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    // 真正决定了工作线程数的理论上限 
    private static final int COUNT_BITS = Integer.SIZE - 3;
    private static final int COUNT_MASK = (1 &lt;&lt; COUNT_BITS) - 1;
    // 线程池状态，存储在数字的高位
    private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;
    …
    // Packing and unpacking ctl
    private static int runStateOf(int c)  { return c &amp; ~COUNT_MASK; }
    private static int workerCountOf(int c)  { return c &amp; COUNT_MASK; }
    private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre>
<p>为了让你能对线程生命周期有个更加清晰的印象，我这里画了一个简单的状态流转图，对线程池的可能状态和其内部方法之间进行了对应，如果有不理解的方法，请参考Javadoc。<strong>注意</strong>，实际Java代码中并不存在所谓Idle状态，我添加它仅仅是便于理解。</p>
<p><img src="assets/c50ce5f2ff4ae723c6267185699ccda1.png" alt="" /></p>
<p>前面都是对线程池属性和构建等方面的分析，下面我选择典型的execute方法，来看看其是如何工作的，具体逻辑请参考我添加的注释，配合代码更加容易理解。</p>
<pre><code class="language-java">    public void execute(Runnable command) {
    …
    	int c = ctl.get();
    // 检查工作线程数目，低于corePoolSize则添加Worker
    	if (workerCountOf(c) &lt; corePoolSize) {
        	if (addWorker(command, true))
            	return;
        	c = ctl.get();
    	}
    // isRunning就是检查线程池是否被shutdown
    // 工作队列可能是有界的，offer是比较友好的入队方式
    	if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        	int recheck = ctl.get();
    // 再次进行防御性检查
        	if (! isRunning(recheck) &amp;&amp; remove(command))
            	reject(command);
        	else if (workerCountOf(recheck) == 0)
            	addWorker(null, false);
    	}
    // 尝试添加一个worker，如果失败意味着已经饱和或者被shutdown了
    	else if (!addWorker(command, false))
        	reject(command);
    }
</code></pre>
<p><strong>线程池实践</strong></p>
<p>线程池虽然为提供了非常强大、方便的功能，但是也不是银弹，使用不当同样会导致问题。我这里介绍些典型情况，经过前面的分析，很多方面可以自然的推导出来。</p>
<ul>
<li>
<p>避免任务堆积。前面我说过newFixedThreadPool是创建指定数目的线程，但是其工作队列是无界的，如果工作线程数目太少，导致处理跟不上入队的速度，这就很有可能占用大量系统内存，甚至是出现OOM。诊断时，你可以使用jmap之类的工具，查看是否有大量的任务对象入队。</p>
</li>
<li>
<p>避免过度扩展线程。我们通常在处理大量短时任务时，使用缓存的线程池，比如在最新的HTTP/2 client API中，目前的默认实现就是如此。我们在创建线程池的时候，并不能准确预计任务压力有多大、数据特征是什么样子（大部分请求是1K 、100K还是1M以上？），所以很难明确设定一个线程数目。</p>
</li>
<li>
<p>另外，如果线程数目不断增长（可以使用jstack等工具检查），也需要警惕另外一种可能性，就是线程泄漏，这种情况往往是因为任务逻辑有问题，导致工作线程迟迟不能被释放。建议你排查下线程栈，很有可能多个线程都是卡在近似的代码处。</p>
</li>
<li>
<p>避免死锁等同步问题，对于死锁的场景和排查，你可以复习[专栏第18讲]。</p>
</li>
<li>
<p>尽量避免在使用线程池时操作ThreadLocal，同样是[专栏第17讲]已经分析过的，通过今天的线程池学习，应该更能理解其原因，工作线程的生命周期通常都会超过任务的生命周期。</p>
</li>
</ul>
<p><strong>线程池大小的选择策略</strong></p>
<p>上面我已经介绍过，线程池大小不合适，太多或太少，都会导致麻烦，所以我们需要去考虑一个合适的线程池大小。虽然不能完全确定，但是有一些相对普适的规则和思路。</p>
<ul>
<li>
<p>如果我们的任务主要是进行计算，那么就意味着CPU的处理能力是稀缺的资源，我们能够通过大量增加线程数提高计算能力吗？往往是不能的，如果线程太多，反倒可能导致大量的上下文切换开销。所以，这种情况下，通常建议按照CPU核的数目N或者N+1。</p>
</li>
<li>
<p>如果是需要较多等待的任务，例如I/O操作比较多，可以参考Brain Goetz推荐的计算方法：</p>
</li>
</ul>
<pre><code>    线程数 = CPU核数 × 目标CPU利用率 ×（1 + 平均等待时间/平均工作时间）
</code></pre>
<p>这些时间并不能精准预计，需要根据采样或者概要分析等方式进行计算，然后在实际中验证和调整。</p>
<ul>
<li>上面是仅仅考虑了CPU等限制，实际还可能受各种系统资源限制影响，例如我最近就在Mac OS X上遇到了大负载时<a href="http://danielmendel.github.io/blog/2013/04/07/benchmarkers-beware-the-ephemeral-port-limit/">ephemeral端口受限</a>的情况。当然，我是通过扩大可用端口范围解决的，如果我们不能调整资源的容量，那么就只能限制工作线程的数目了。这里的资源可以是文件句柄、内存等。</li>
</ul>
<p>另外，在实际工作中，不要把解决问题的思路全部指望到调整线程池上，很多时候架构上的改变更能解决问题，比如利用背压机制的<a href="http://www.reactive-streams.org/">Reactive Stream</a>、合理的拆分等。</p>
<p>今天，我从Java创建的几种线程池开始，对Executor框架的主要组成、线程池结构与生命周期等方面进行了讲解和分析，希望对你有所帮助。</p>
<h2>一课一练</h2>
<p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是从逻辑上理解，线程池创建和生命周期。请谈一谈，如果利用newSingleThreadExecutor()创建一个线程池，corePoolSize、maxPoolSize等都是什么数值？ThreadFactory可能在线程池生命周期中被使用多少次？怎么验证自己的判断？</p>
<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习奖励礼券，欢迎你与我一起讨论。</p>
<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>
</div>
                        </div>
                        <div>
                            <div style="float: left">
                                <a href="20%20%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84ConcurrentLinkedQueue%E5%92%8CLinkedBlockingQueue%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md.html">上一页</a>
                            </div>
                            <div style="float: right">
                                <a href="22%20AtomicInteger%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%A7%E5%93%81%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%BA%94%E7%94%A8CAS%E6%93%8D%E4%BD%9C%EF%BC%9F.md.html">下一页</a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="copyright"><p>© 2019 - 2023 <a href="../../cdn-cgi/l/email-protection.html#234f4f4f1a171212131463444e424a4f0d404c4e" target="_blank">Liangliang Lee</a>. Powered by <a href="https://vertx.io/" target="_blank">Vert.x</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p></div>
        </div>

        <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
    </div>
<script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script defer src="https://static.cloudflareinsights.com/beacon.min.js/vb26e4fa9e5134444860be286fd8771851679335129114" integrity="sha512-M3hN/6cva/SjwrOtyXeUa5IuCT0sedyfT+jK/OV+s+D0RnzrTfwjwJHhd+wYfMm9HJSrZ1IKksOdddLuN6KOzw==" data-cf-beacon='{"rayId":"7aef0333b80c641c","version":"2023.3.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }

    hljs.initHighlightingOnLoad()

</script>

</html>
