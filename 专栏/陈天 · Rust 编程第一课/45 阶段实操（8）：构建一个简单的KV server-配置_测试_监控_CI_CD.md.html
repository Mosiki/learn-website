<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>45 阶段实操（8）：构建一个简单的KV server-配置_测试_监控_CI_CD.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <link rel="stylesheet"
              href="../../static/highlight.min.css">
        <script src="../../static/highlight.min.js"></script>
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5295275829820252"
                crossorigin="anonymous"></script>
        <script async defer data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" src="https://analyze.lianglianglee.com/umami.js"></script>
    </head>

<body>

    <div class="book-container">
        <div class="book-sidebar">
            <div class="book-brand">
                <a href="../../index.html">
                    <img src="../../static/favicon.png">
                    <span>技术文章摘抄</span>
                </a>
            </div>
            <div class="book-menu uncollapsible">
                <ul class="uncollapsible">
                    <li><a href="../../index.html" class="current-tab">首页</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li><a href="../index.html">上一级</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li>

                        
                        <a href="00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%E8%AE%A9Rust%E6%88%90%E4%B8%BA%E4%BD%A0%E7%9A%84%E4%B8%8B%E4%B8%80%E9%97%A8%E4%B8%BB%E5%8A%9B%E8%AF%AD%E8%A8%80.md.html">00 开篇词 让Rust成为你的下一门主力语言.md</a>

                    </li>
                    <li>

                        
                        <a href="01%20%E5%86%85%E5%AD%98%EF%BC%9A%E5%80%BC%E6%94%BE%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%94%BE%E6%A0%88%E4%B8%8A%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98.md.html">01 内存：值放堆上还是放栈上，这是一个问题.md</a>

                    </li>
                    <li>

                        
                        <a href="02%20%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E9%82%A3%E4%BA%9B%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.md.html">02 串讲：编程开发中，那些你需要掌握的基本概念.md</a>

                    </li>
                    <li>

                        
                        <a href="03%20%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%EF%BC%9A%E4%BB%8E%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AARust%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%A7%8B%EF%BC%81.md.html">03 初窥门径：从你的第一个Rust程序开始！.md</a>

                    </li>
                    <li>

                        
                        <a href="04%20get%20hands%20dirty%EF%BC%9A%E6%9D%A5%E5%86%99%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84CLI%E5%B0%8F%E5%B7%A5%E5%85%B7.md.html">04 get hands dirty：来写个实用的CLI小工具.md</a>

                    </li>
                    <li>

                        
                        <a href="05%20get%20hands%20dirty%EF%BC%9A%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E5%A4%9A%E9%9A%BE%EF%BC%9F.md.html">05 get hands dirty：做一个图片服务器有多难？.md</a>

                    </li>
                    <li>

                        
                        <a href="06%20get%20hands%20dirty%EF%BC%9ASQL%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7%E6%80%8E%E4%B9%88%E4%B8%80%E9%B1%BC%E5%A4%9A%E5%90%83%EF%BC%9F.md.html">06 get hands dirty：SQL查询工具怎么一鱼多吃？.md</a>

                    </li>
                    <li>

                        
                        <a href="07%20%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%81%E6%89%8B%E4%B8%8A%EF%BC%9F.md.html">07 所有权：值的生杀大权到底在谁手上？.md</a>

                    </li>
                    <li>

                        
                        <a href="08%20%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E5%80%9F%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F.md.html">08 所有权：值的借用是如何工作的？.md</a>

                    </li>
                    <li>

                        
                        <a href="09%20%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F.md.html">09 所有权：一个值可以有多个所有者么？.md</a>

                    </li>
                    <li>

                        
                        <a href="10%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E4%BD%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%80%BC%E7%A9%B6%E7%AB%9F%E8%83%BD%E6%B4%BB%E5%A4%9A%E4%B9%85%EF%BC%9F.md.html">10 生命周期：你创建的值究竟能活多久？.md</a>

                    </li>
                    <li>

                        
                        <a href="11%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.md.html">11 内存管理：从创建到消亡，值都经历了什么？.md</a>

                    </li>
                    <li>

                        
                        <a href="12%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F.md.html">12 类型系统：Rust的类型系统有什么特点？.md</a>

                    </li>
                    <li>

                        
                        <a href="13%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8trait%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F.md.html">13 类型系统：如何使用trait来定义接口？.md</a>

                    </li>
                    <li>

                        
                        <a href="14%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84trait%EF%BC%9F.md.html">14 类型系统：有哪些必须掌握的trait？.md</a>

                    </li>
                    <li>

                        
                        <a href="15%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%99%E4%BA%9B%E6%B5%93%E7%9C%89%E5%A4%A7%E7%9C%BC%E7%9A%84%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E9%83%BD%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F.md.html">15 数据结构：这些浓眉大眼的结构竟然都是智能指针？.md</a>

                    </li>
                    <li>

                        
                        <a href="16%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVec_T_%E3%80%81&amp;%5BT%5D%E3%80%81Box_%5BT%5D_%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F.md.html">16 数据结构：Vec_T_、&amp;[T]、Box_[T]_ ，你真的了解集合容器么？.md</a>

                    </li>
                    <li>

                        
                        <a href="17%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F.md.html">17 数据结构：软件系统核心部件哈希表，内存如何布局？.md</a>

                    </li>
                    <li>

                        
                        <a href="18%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Rust%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%EF%BC%9F.md.html">18 错误处理：为什么Rust的错误处理与众不同？.md</a>

                    </li>
                    <li>

                        
                        <a href="19%20%E9%97%AD%E5%8C%85%EF%BC%9AFnOnce%E3%80%81FnMut%E5%92%8CFn%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E7%B1%BB%E5%9E%8B%EF%BC%9F.md.html">19 闭包：FnOnce、FnMut和Fn，为什么有这么多类型？.md</a>

                    </li>
                    <li>

                        
                        <a href="20%204%20Steps%20%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E9%98%85%E8%AF%BBRust%E6%BA%90%E7%A0%81%EF%BC%9F.md.html">20 4 Steps ：如何更好地阅读Rust源码？.md</a>

                    </li>
                    <li>

                        
                        <a href="21%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%881%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.md.html">21 阶段实操（1）：构建一个简单的KV server-基本流程.md</a>

                    </li>
                    <li>

                        
                        <a href="22%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%882%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.md.html">22 阶段实操（2）：构建一个简单的KV server-基本流程.md</a>

                    </li>
                    <li>

                        
                        <a href="23%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%9F.md.html">23 类型系统：如何在实战中使用泛型编程？.md</a>

                    </li>
                    <li>

                        
                        <a href="24%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E4%BD%BF%E7%94%A8trait%20object%EF%BC%9F.md.html">24 类型系统：如何在实战中使用trait object？.md</a>

                    </li>
                    <li>

                        
                        <a href="25%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9B%B4%E7%BB%95trait%E6%9D%A5%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%9E%B6%E6%9E%84%E7%B3%BB%E7%BB%9F%EF%BC%9F.md.html">25 类型系统：如何围绕trait来设计和架构系统？.md</a>

                    </li>
                    <li>

                        
                        <a href="26%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%883%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E9%AB%98%E7%BA%A7trait%E6%8A%80%E5%B7%A7.md.html">26 阶段实操（3）：构建一个简单的KV server-高级trait技巧.md</a>

                    </li>
                    <li>

                        
                        <a href="27%20%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E6%9C%89%E7%9A%84Rust%E5%BA%93%E5%8F%AF%E4%BB%A5%E4%B8%BA%E6%88%91%E6%89%80%E7%94%A8%EF%BC%9F.md.html">27 生态系统：有哪些常有的Rust库可以为我所用？.md</a>

                    </li>
                    <li>

                        
                        <a href="28%20%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rust%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%9F.md.html">28 网络开发（上）：如何使用Rust处理网络请求？.md</a>

                    </li>
                    <li>

                        
                        <a href="29%20%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rust%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%9F.md.html">29 网络开发（下）：如何使用Rust处理网络请求？.md</a>

                    </li>
                    <li>

                        
                        <a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%99%88%E5%A4%A9%20%C2%B7%20Rust%20%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/30%20Unsafe%20Rust%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8C++%E7%9A%84%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80Rust%EF%BC%9F.md">30 Unsafe Rust：如何用C++的方式打开Rust？.md</a>

                    </li>
                    <li>

                        
                        <a href="31%20FFI%EF%BC%9ARust%E5%A6%82%E4%BD%95%E5%92%8C%E4%BD%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E6%9E%B6%E8%B5%B7%E6%B2%9F%E9%80%9A%E6%A1%A5%E6%A2%81%EF%BC%9F.md.html">31 FFI：Rust如何和你的语言架起沟通桥梁？.md</a>

                    </li>
                    <li>

                        
                        <a href="32%20%E5%AE%9E%E6%93%8D%E9%A1%B9%E7%9B%AE%EF%BC%9A%E4%BD%BF%E7%94%A8PyO3%E5%BC%80%E5%8F%91Python3%E6%A8%A1%E5%9D%97.md.html">32 实操项目：使用PyO3开发Python3模块.md</a>

                    </li>
                    <li>

                        
                        <a href="33%20%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BB%8Eatomics%E5%88%B0Channel%EF%BC%8CRust%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%EF%BC%9F.md.html">33 并发处理（上）：从atomics到Channel，Rust都提供了什么工具？.md</a>

                    </li>
                    <li>

                        
                        <a href="34%20%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%BB%8Eatomics%E5%88%B0Channel%EF%BC%8CRust%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%EF%BC%9F.md.html">34 并发处理（下）：从atomics到Channel，Rust都提供了什么工具？.md</a>

                    </li>
                    <li>

                        
                        <a href="35%20%E5%AE%9E%E6%93%8D%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84MPSC%20channel%EF%BC%9F.md.html">35 实操项目：如何实现一个基本的MPSC channel？.md</a>

                    </li>
                    <li>

                        
                        <a href="36%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%884%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86.md.html">36 阶段实操（4）：构建一个简单的KV server-网络处理.md</a>

                    </li>
                    <li>

                        
                        <a href="37%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%885%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.md.html">37 阶段实操（5）：构建一个简单的KV server-网络安全.md</a>

                    </li>
                    <li>

                        
                        <a href="38%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9AFuture%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E5%92%8Casync_await%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F.md.html">38 异步处理：Future是什么？它和async_await是什么关系？.md</a>

                    </li>
                    <li>

                        
                        <a href="39%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9Aasync_await%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.md.html">39 异步处理：async_await内部是怎么实现的？.md</a>

                    </li>
                    <li>

                        
                        <a href="40%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5IO%EF%BC%9F.md.html">40 异步处理：如何处理异步IO？.md</a>

                    </li>
                    <li>

                        
                        <a href="41%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%886%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.md.html">41 阶段实操（6）：构建一个简单的KV server-异步处理.md</a>

                    </li>
                    <li>

                        
                        <a href="42%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%887%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A4%A7%E7%9A%84%E9%87%8D%E6%9E%84%EF%BC%9F.md.html">42 阶段实操（7）：构建一个简单的KV server-如何做大的重构？.md</a>

                    </li>
                    <li>

                        
                        <a href="43%20%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%EF%BC%9A%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E4%B8%8B%E7%9A%84%E4%B8%80%E4%B8%AARust%E9%A1%B9%E7%9B%AE%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E8%A6%81%E7%B4%A0%EF%BC%9F.md.html">43 生产环境：真实世界下的一个Rust项目包含哪些要素？.md</a>

                    </li>
                    <li>

                        
                        <a href="44%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%89%93%E4%BA%A4%E9%81%93%EF%BC%9F.md.html">44 数据处理：应用程序和数据如何打交道？.md</a>

                    </li>
                    <li>

                        <a class="current-tab" href="45%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%888%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E9%85%8D%E7%BD%AE_%E6%B5%8B%E8%AF%95_%E7%9B%91%E6%8E%A7_CI_CD.md.html">45 阶段实操（8）：构建一个简单的KV server-配置_测试_监控_CI_CD.md</a>
                        

                    </li>
                    <li>

                        
                        <a href="46%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8Rust%E6%9E%B6%E6%9E%84%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F%EF%BC%9F.md.html">46 软件架构：如何用Rust架构复杂系统？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20Rust2021%E7%89%88%E6%AC%A1%E9%97%AE%E4%B8%96%E4%BA%86%EF%BC%81.md.html">加餐 Rust2021版次问世了！.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E4%BB%A3%E7%A0%81%E5%8D%B3%E6%95%B0%E6%8D%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%AE%8F%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%EF%BC%9F.md.html">加餐 代码即数据：为什么我们需要宏编程能力？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E5%AE%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E7%94%A8%E6%9C%80%E2%80%9C%E7%AC%A8%E2%80%9D%E7%9A%84%E6%96%B9%E5%BC%8F%E6%92%B0%E5%86%99%E5%AE%8F.md.html">加餐 宏编程（上）：用最“笨”的方式撰写宏.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E5%AE%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%94%A8%20syn_quote%20%E4%BC%98%E9%9B%85%E5%9C%B0%E6%9E%84%E5%BB%BA%E5%AE%8F.md.html">加餐 宏编程（下）：用 syn_quote 优雅地构建宏.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E6%84%9A%E6%98%A7%E4%B9%8B%E5%B7%85%EF%BC%9A%E4%BD%A0%E7%9A%84Rust%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.md.html">加餐 愚昧之巅：你的Rust学习常见问题汇总.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E6%9C%9F%E4%B8%AD%E6%B5%8B%E8%AF%95%EF%BC%9A%E5%8F%82%E8%80%83%E5%AE%9E%E7%8E%B0%E8%AE%B2%E8%A7%A3.md.html">加餐 期中测试：参考实现讲解.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E6%9C%9F%E4%B8%AD%E6%B5%8B%E8%AF%95%EF%BC%9A%E6%9D%A5%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84grep%E5%91%BD%E4%BB%A4%E8%A1%8C.md.html">加餐 期中测试：来写一个简单的grep命令行.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E8%BF%99%E4%B8%AA%E4%B8%93%E6%A0%8F%E4%BD%A0%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%AD%A6%EF%BC%8C%E4%BB%A5%E5%8F%8ARust%E6%98%AF%E5%90%A6%E5%80%BC%E5%BE%97%E5%AD%A6%EF%BC%9F.md.html">加餐 这个专栏你可以怎么学，以及Rust是否值得学？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%A4%A7%E5%92%96%E5%8A%A9%E5%9C%BA%20%E5%BC%80%E6%82%9F%E4%B9%8B%E5%9D%A1%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9ARust%E7%9A%84%E7%8E%B0%E7%8A%B6%E3%80%81%E6%9C%BA%E9%81%87%E4%B8%8E%E6%8C%91%E6%88%98.md.html">大咖助场 开悟之坡（上）：Rust的现状、机遇与挑战.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%A4%A7%E5%92%96%E5%8A%A9%E5%9C%BA%20%E5%BC%80%E6%82%9F%E4%B9%8B%E5%9D%A1%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9ARust%E7%9A%84%E7%8E%B0%E7%8A%B6%E3%80%81%E6%9C%BA%E9%81%87%E4%B8%8E%E6%8C%91%E6%88%98.md.html">大咖助场 开悟之坡（下）：Rust的现状、机遇与挑战.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%89%B9%E5%88%AB%E7%AD%96%E5%88%92%20%E5%AD%A6%E4%B9%A0%E9%94%A6%E5%9B%8A%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%90%AC%E5%90%AC%E8%AF%BE%E4%BB%A3%E8%A1%A8%E4%BB%AC%E6%80%8E%E4%B9%88%E8%AF%B4.md.html">特别策划 学习锦囊（一）：听听课代表们怎么说.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%89%B9%E5%88%AB%E7%AD%96%E5%88%92%20%E5%AD%A6%E4%B9%A0%E9%94%A6%E5%9B%8A%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%AC%E5%90%AC%E8%AF%BE%E4%BB%A3%E8%A1%A8%E4%BB%AC%E6%80%8E%E4%B9%88%E8%AF%B4.md.html">特别策划 学习锦囊（三）：听听课代表们怎么说.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%89%B9%E5%88%AB%E7%AD%96%E5%88%92%20%E5%AD%A6%E4%B9%A0%E9%94%A6%E5%9B%8A%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%90%AC%E5%90%AC%E8%AF%BE%E4%BB%A3%E8%A1%A8%E4%BB%AC%E6%80%8E%E4%B9%88%E8%AF%B4.md.html">特别策划 学习锦囊（二）：听听课代表们怎么说.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%20%E7%BB%9D%E6%9C%9B%E4%B9%8B%E8%B0%B7%EF%BC%9A%E6%94%B9%E5%8F%98%E4%BB%8E%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%A7%8B.md.html">用户故事 绝望之谷：改变从学习开始.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%20%E8%AF%AD%E8%A8%80%E4%B8%8D%E4%BB%85%E6%98%AF%E5%B7%A5%E5%85%B7%EF%BC%8C%E8%BF%98%E6%98%AF%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F.md.html">用户故事 语言不仅是工具，还是思维方式.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%BB%93%E6%9D%9F%E8%AF%AD%20%E6%B0%B8%E7%BB%AD%E4%B9%8B%E5%8E%9F%EF%BC%9ARust%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8C%81%E7%BB%AD%E7%B2%BE%E8%BF%9B%EF%BC%9F.md.html">结束语 永续之原：Rust学习，如何持续精进？.md</a>

                    </li>
                </ul>

            </div>
        </div>

        <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
            <div class="sidebar-toggle-inner"></div>
        </div>

        <script>
            function add_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.add('show')
            }

            function remove_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.remove('show')
            }

            function sidebar_toggle() {
                let sidebar_toggle = document.querySelector('.sidebar-toggle')
                let sidebar = document.querySelector('.book-sidebar')
                let content = document.querySelector('.off-canvas-content')
                if (sidebar_toggle.classList.contains('extend')) { // show
                    sidebar_toggle.classList.remove('extend')
                    sidebar.classList.remove('hide')
                    content.classList.remove('extend')
                } else { // hide
                    sidebar_toggle.classList.add('extend')
                    sidebar.classList.add('hide')
                    content.classList.add('extend')
                }
            }


            function open_sidebar() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.add('show')
                overlay.classList.add('show')
            }
            function hide_canvas() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.remove('show')
                overlay.classList.remove('show')
            }

        </script>

        <div class="off-canvas-content">
            <div class="columns">
                <div class="column col-12 col-lg-12">
                    <div class="book-navbar">
                        <!-- For Responsive Layout -->
                        <header class="navbar">
                            <section class="navbar-section">
                                <a onclick="open_sidebar()">
                                    <i class="icon icon-menu"></i>
                                </a>
                            </section>
                        </header>
                    </div>
                    <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                        <div class="book-post">
                            <p id="tip" align="center"></p>
                            <div><h1>45 阶段实操（8）：构建一个简单的KV server-配置_测试_监控_CI_CD</h1>
<p>你好，我是陈天。</p>
<p>终于来到了我们这个 KV server 系列的终章。其实原本 KV server 我只计划了 4 讲，但现在 8 讲似乎都还有些意犹未尽。虽然这是一个“简单”的 KV server，它没有复杂的性能优化 —— 我们只用了一句 unsafe；也没有复杂的生命周期处理 —— 只有零星 'static 标注；更没有支持集群的处理。</p>
<p>然而，如果你能够理解到目前为止的代码，甚至能独立写出这样的代码，那么，你已经具备足够的、能在一线大厂开发的实力了，国内我不是特别清楚，但在北美这边，保守一些地说，300k+ USD 的 package 应该可以轻松拿到。</p>
<p>今天我们就给KV server项目收个尾，结合之前梳理的实战中 Rust 项目应该考虑的问题，来聊聊和生产环境有关的一些处理，按开发流程，主要讲五个方面：配置、集成测试、性能测试、测量和监控、CI/CD。</p>
<h2>配置</h2>
<p>首先在 Cargo.toml 里添加 <a href="https://github.com/serde-rs/serde">serde</a> 和 <a href="https://github.com/alexcrichton/toml-rs">toml</a>。我们计划使用 toml 做配置文件，serde 用来处理配置的序列化和反序列化：</p>
<pre><code>[dependencies]
...
serde = { version = &quot;1&quot;, features = [&quot;derive&quot;] } # 序列化/反序列化
...
toml = &quot;0.5&quot; # toml 支持
...
</code></pre>
<p>然后来创建一个 src/config.rs，构建 KV server 的配置：</p>
<pre><code>use crate::KvError;
use serde::{Deserialize, Serialize};
use std::fs;

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ServerConfig {
    pub general: GeneralConfig,
    pub storage: StorageConfig,
    pub tls: ServerTlsConfig,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ClientConfig {
    pub general: GeneralConfig,
    pub tls: ClientTlsConfig,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct GeneralConfig {
    pub addr: String,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
#[serde(tag = &quot;type&quot;, content = &quot;args&quot;)]
pub enum StorageConfig {
    MemTable,
    SledDb(String),
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ServerTlsConfig {
    pub cert: String,
    pub key: String,
    pub ca: Option&lt;String&gt;,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ClientTlsConfig {
    pub domain: String,
    pub identity: Option&lt;(String, String)&gt;,
    pub ca: Option&lt;String&gt;,
}

impl ServerConfig {
    pub fn load(path: &amp;str) -&gt; Result&lt;Self, KvError&gt; {
        let config = fs::read_to_string(path)?;
        let config: Self = toml::from_str(&amp;config)?;
        Ok(config)
    }
}

impl ClientConfig {
    pub fn load(path: &amp;str) -&gt; Result&lt;Self, KvError&gt; {
        let config = fs::read_to_string(path)?;
        let config: Self = toml::from_str(&amp;config)?;
        Ok(config)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn server_config_should_be_loaded() {
        let result: Result&lt;ServerConfig, toml::de::Error&gt; =
            toml::from_str(include_str!(&quot;../fixtures/server.conf&quot;));
        assert!(result.is_ok());
    }

    #[test]
    fn client_config_should_be_loaded() {
        let result: Result&lt;ClientConfig, toml::de::Error&gt; =
            toml::from_str(include_str!(&quot;../fixtures/client.conf&quot;));
        assert!(result.is_ok());
    }
}
</code></pre>
<p>你可以看到，在 Rust 下，有了 serde 的帮助，处理任何已知格式的配置文件，是多么容易的一件事情。我们<strong>只需要定义数据结构，并为数据结构使用 Serialize/Deserialize 派生宏，就可以处理任何支持 serde 的数据结构</strong>。</p>
<p>我还写了个 examples/gen_config.rs（你可以自行去查阅它的代码），用来生成配置文件，下面是生成的服务端的配置：</p>
<pre><code>[general]
addr = '127.0.0.1:9527'

[storage]
type = 'SledDb'
args = '/tmp/kv_server'

[tls]
cert = &quot;&quot;&quot;
-----BEGIN CERTIFICATE-----\r
MIIBdzCCASmgAwIBAgIICpy02U2yuPowBQYDK2VwMDMxCzAJBgNVBAYMAkNOMRIw\r
EAYDVQQKDAlBY21lIEluYy4xEDAOBgNVBAMMB0FjbWUgQ0EwHhcNMjEwOTI2MDEy\r
NTU5WhcNMjYwOTI1MDEyNTU5WjA6MQswCQYDVQQGDAJDTjESMBAGA1UECgwJQWNt\r
ZSBJbmMuMRcwFQYDVQQDDA5BY21lIEtWIHNlcnZlcjAqMAUGAytlcAMhAK2Z2AjF\r
A0uiltNuCvl6EVFl6tpaS/wJYB5IdWT2IISdo1QwUjAcBgNVHREEFTATghFrdnNl\r
cnZlci5hY21lLmluYzATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMEBTADAQEA\r
MA8GA1UdDwEB/wQFAwMH4AAwBQYDK2VwA0EASGOmOWFPjbGhXNOmYNCa3lInbgRy\r
iTNtB/5kElnbKkhKhRU7yQ8HTHWWkyU5WGWbOOIXEtYp+5ERUJC+mzP9Bw==\r
-----END CERTIFICATE-----\r
&quot;&quot;&quot;
key = &quot;&quot;&quot;
-----BEGIN PRIVATE KEY-----\r
MFMCAQEwBQYDK2VwBCIEIPMyINaewhXwuTPUufFO2mMt/MvQMHrGDGxgdgfy/kUu\r
oSMDIQCtmdgIxQNLopbTbgr5ehFRZeraWkv8CWAeSHVk9iCEnQ==\r
-----END PRIVATE KEY-----\r
&quot;&quot;&quot;
</code></pre>
<p>有了配置文件的支持，就可以在 <a href="http://lib.rs">lib.rs</a> 下写一些辅助函数，让我们创建服务端和客户端更加简单：</p>
<pre><code>mod config;
mod error;
mod network;
mod pb;
mod service;
mod storage;

pub use config::*;
pub use error::KvError;
pub use network::*;
pub use pb::abi::*;
pub use service::*;
pub use storage::*;

use anyhow::Result;
use tokio::net::{TcpListener, TcpStream};
use tokio_rustls::client;
use tokio_util::compat::FuturesAsyncReadCompatExt;
use tracing::info;

/// 通过配置创建 KV 服务器
pub async fn start_server_with_config(config: &amp;ServerConfig) -&gt; Result&lt;()&gt; {
    let acceptor =
        TlsServerAcceptor::new(&amp;config.tls.cert, &amp;config.tls.key, config.tls.ca.as_deref())?;

    let addr = &amp;config.general.addr;
    match &amp;config.storage {
        StorageConfig::MemTable =&gt; start_tls_server(addr, MemTable::new(), acceptor).await?,
        StorageConfig::SledDb(path) =&gt; start_tls_server(addr, SledDb::new(path), acceptor).await?,
    };

    Ok(())
}

/// 通过配置创建 KV 客户端
pub async fn start_client_with_config(
    config: &amp;ClientConfig,
) -&gt; Result&lt;YamuxCtrl&lt;client::TlsStream&lt;TcpStream&gt;&gt;&gt; {
    let addr = &amp;config.general.addr;
    let tls = &amp;config.tls;

    let identity = tls.identity.as_ref().map(|(c, k)| (c.as_str(), k.as_str()));
    let connector = TlsClientConnector::new(&amp;tls.domain, identity, tls.ca.as_deref())?;
    let stream = TcpStream::connect(addr).await?;
    let stream = connector.connect(stream).await?;

    // 打开一个 stream
    Ok(YamuxCtrl::new_client(stream, None))
}

async fn start_tls_server&lt;Store: Storage&gt;(
    addr: &amp;str,
    store: Store,
    acceptor: TlsServerAcceptor,
) -&gt; Result&lt;()&gt; {
    let service: Service&lt;Store&gt; = ServiceInner::new(store).into();
    let listener = TcpListener::bind(addr).await?;
    info!(&quot;Start listening on {}&quot;, addr);
    loop {
        let tls = acceptor.clone();
        let (stream, addr) = listener.accept().await?;
        info!(&quot;Client {:?} connected&quot;, addr);

        let svc = service.clone();
        tokio::spawn(async move {
            let stream = tls.accept(stream).await.unwrap();
            YamuxCtrl::new_server(stream, None, move |stream| {
                let svc1 = svc.clone();
                async move {
                    let stream = ProstServerStream::new(stream.compat(), svc1.clone());
                    stream.process().await.unwrap();
                    Ok(())
                }
            });
        });
    }
}
</code></pre>
<p>有了 start_server_with_config 和 start_client_with_config 这两个辅助函数，我们就可以简化 src/server.rs 和 src/client.rs 了。下面是 src/server.rs 的新代码：</p>
<pre><code>use anyhow::Result;
use kv6::{start_server_with_config, ServerConfig};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();
    let config: ServerConfig = toml::from_str(include_str!(&quot;../fixtures/server.conf&quot;))?;

    start_server_with_config(&amp;config).await?;

    Ok(())
}
</code></pre>
<p>可以看到，整个代码简洁了很多。在这个重构的过程中，还有一些其它改动，你可以看 GitHub repo 下 45 讲的 diff_config。</p>
<h2>集成测试</h2>
<p>之前我们写了很多单元测试，但还没有写过一行集成测试。今天就来写一个简单的集成测试，确保客户端和服务器完整的交互工作正常。</p>
<p>之前提到在 Rust 里，集成测试放在 tests 目录下，每个测试编成单独的二进制。所以首先，我们创建和 src 平行的 tests 目录。然后再创建 tests/server.rs，填入以下代码：</p>
<pre><code>use anyhow::Result;
use kv6::{
    start_client_with_config, start_server_with_config, ClientConfig, CommandRequest,
    ProstClientStream, ServerConfig, StorageConfig,
};
use std::time::Duration;
use tokio::time;

#[tokio::test]
async fn yamux_server_client_full_tests() -&gt; Result&lt;()&gt; {
    let addr = &quot;127.0.0.1:10086&quot;;

    let mut config: ServerConfig = toml::from_str(include_str!(&quot;../fixtures/server.conf&quot;))?;
    config.general.addr = addr.into();
    config.storage = StorageConfig::MemTable;

    // 启动服务器
    tokio::spawn(async move {
        start_server_with_config(&amp;config).await.unwrap();
    });

    time::sleep(Duration::from_millis(10)).await;
    let mut config: ClientConfig = toml::from_str(include_str!(&quot;../fixtures/client.conf&quot;))?;
    config.general.addr = addr.into();

    let mut ctrl = start_client_with_config(&amp;config).await.unwrap();
    let stream = ctrl.open_stream().await?;
    let mut client = ProstClientStream::new(stream);

    // 生成一个 HSET 命令
    let cmd = CommandRequest::new_hset(&quot;table1&quot;, &quot;hello&quot;, &quot;world&quot;.to_string().into());
    client.execute_unary(&amp;cmd).await?;

    // 生成一个 HGET 命令
    let cmd = CommandRequest::new_hget(&quot;table1&quot;, &quot;hello&quot;);
    let data = client.execute_unary(&amp;cmd).await?;

    assert_eq!(data.status, 200);
    assert_eq!(data.values, &amp;[&quot;world&quot;.into()]);

    Ok(())
}
</code></pre>
<p>可以看到，<strong>集成测试的写法和单元测试其实很类似，只不过我们不需要再使用 #[cfg(test)] 来做条件编译</strong>。</p>
<p>如果你的集成测试比较复杂，需要比较多的辅助代码，那么你还可以在 tests 下 cargo new 出一个项目，然后在那个项目里撰写辅助代码和测试代码。如果你对此感兴趣，可以看 <a href="https://github.com/hyperium/tonic/tree/master/tests">tonic 的集成测试</a>。不过注意了，集成测试和你的 crate 用同样的条件编译，所以在集成测试里，无法使用单元测试中构建的辅助代码。</p>
<h2>性能测试</h2>
<p>在之前不断完善 KV server 的过程中，你一定会好奇：我们的 KV server 性能究竟如何呢？那来写一个关于 Pub/Sub 的性能测试吧。</p>
<p>基本的想法是我们连上 100 个 subscriber 作为背景，然后看 publisher publish 的速度。</p>
<p>因为 BROADCAST_CAPACITY 有限，是 128，当 publisher 速度太快，而导致 server 不能及时往 subscriber 发送时，server 接收 client 数据的速度就会降下来，无法接收新的 client，整体的 publish 的速度也会降下来，所以这个测试能够了解 server 处理 publish 的速度。</p>
<p>为了确认这一点，我们在 start_tls_server() 函数中，在 process() 之前，再加个 100ms 的延时，人为减缓系统的处理速度：</p>
<pre><code>async move {
    let stream = ProstServerStream::new(stream.compat(), svc1.clone());
    // 延迟 100ms 处理
    time::sleep(Duration::from_millis(100)).await;
    stream.process().await.unwrap();
    Ok(())
}
</code></pre>
<p>好，现在可以写性能测试了。</p>
<p>在 Rust 下，我们可以用 <a href="https://github.com/bheisler/criterion.rs">criterion</a> 库。它可以处理基本的性能测试，并生成漂亮的报告。所以在 Cargo.toml 中加入：</p>
<pre><code>[dev-dependencies]
...
criterion = { version = &quot;0.3&quot;, features = [&quot;async_futures&quot;, &quot;async_tokio&quot;, &quot;html_reports&quot;] } # benchmark
...
rand = &quot;0.8&quot; # 随机数处理
...

[[bench]]
name = &quot;pubsub&quot;
harness = false
</code></pre>
<p>最后这个 bench section，描述了性能测试的名字，它对应 benches 目录下的同名文件。</p>
<p>我们创建和 src 平级的 benches，然后再创建 benches/pubsub.rs，添入如下代码：</p>
<pre><code>use anyhow::Result;
use criterion::{criterion_group, criterion_main, Criterion};
use futures::StreamExt;
use kv6::{
    start_client_with_config, start_server_with_config, ClientConfig, CommandRequest, ServerConfig,
    StorageConfig, YamuxCtrl,
};
use rand::prelude::SliceRandom;
use std::time::Duration;
use tokio::net::TcpStream;
use tokio::runtime::Builder;
use tokio::time;
use tokio_rustls::client::TlsStream;
use tracing::info;

async fn start_server() -&gt; Result&lt;()&gt; {
    let addr = &quot;127.0.0.1:9999&quot;;
    let mut config: ServerConfig = toml::from_str(include_str!(&quot;../fixtures/server.conf&quot;))?;
    config.general.addr = addr.into();
    config.storage = StorageConfig::MemTable;

    tokio::spawn(async move {
        start_server_with_config(&amp;config).await.unwrap();
    });

    Ok(())
}

async fn connect() -&gt; Result&lt;YamuxCtrl&lt;TlsStream&lt;TcpStream&gt;&gt;&gt; {
    let addr = &quot;127.0.0.1:9999&quot;;
    let mut config: ClientConfig = toml::from_str(include_str!(&quot;../fixtures/client.conf&quot;))?;
    config.general.addr = addr.into();

    Ok(start_client_with_config(&amp;config).await?)
}

async fn start_subscribers(topic: &amp;'static str) -&gt; Result&lt;()&gt; {
    let mut ctrl = connect().await?;
    let stream = ctrl.open_stream().await?;
    info!(&quot;C(subscriber): stream opened&quot;);
    let cmd = CommandRequest::new_subscribe(topic.to_string());
    tokio::spawn(async move {
        let mut stream = stream.execute_streaming(&amp;cmd).await.unwrap();
        while let Some(Ok(data)) = stream.next().await {
            drop(data);
        }
    });

    Ok(())
}

async fn start_publishers(topic: &amp;'static str, values: &amp;'static [&amp;'static str]) -&gt; Result&lt;()&gt; {
    let mut rng = rand::thread_rng();
    let v = values.choose(&amp;mut rng).unwrap();

    let mut ctrl = connect().await.unwrap();
    let mut stream = ctrl.open_stream().await.unwrap();
    info!(&quot;C(publisher): stream opened&quot;);

    let cmd = CommandRequest::new_publish(topic.to_string(), vec![(*v).into()]);
    stream.execute_unary(&amp;cmd).await.unwrap();

    Ok(())
}

fn pubsub(c: &amp;mut Criterion) {
    // tracing_subscriber::fmt::init();
    // 创建 Tokio runtime
    let runtime = Builder::new_multi_thread()
        .worker_threads(4)
        .thread_name(&quot;pubsub&quot;)
        .enable_all()
        .build()
        .unwrap();
    let values = &amp;[&quot;Hello&quot;, &quot;Tyr&quot;, &quot;Goodbye&quot;, &quot;World&quot;];
    let topic = &quot;lobby&quot;;

    // 运行服务器和 100 个 subscriber，为测试准备
    runtime.block_on(async {
        eprint!(&quot;preparing server and subscribers&quot;);
        start_server().await.unwrap();
        time::sleep(Duration::from_millis(50)).await;
        for _ in 0..100 {
            start_subscribers(topic).await.unwrap();
            eprint!(&quot;.&quot;);
        }
        eprintln!(&quot;Done!&quot;);
    });

    // 进行 benchmark
    c.bench_function(&quot;publishing&quot;, move |b| {
        b.to_async(&amp;runtime)
            .iter(|| async { start_publishers(topic, values).await })
    });
}

criterion_group! {
    name = benches;
    config = Criterion::default().sample_size(10);
    targets = pubsub
}
criterion_main!(benches);
</code></pre>
<p>大部分的代码都很好理解，就是创建服务器和客户端，为测试做准备。说一下这里面核心的 benchmark 代码：</p>
<pre><code>c.bench_function(&quot;publishing&quot;, move |b| {
    b.to_async(&amp;runtime)
        .iter(|| async { start_publishers(topic, values).await })
});
</code></pre>
<p>对于要测试的代码，我们可以封装成一个函数进行测试。<strong>这里因为要做 async 函数的测试，需要使用 runtime。普通的函数不需要调用 to_async</strong>。对于更多有关 criterion 的用法，可以参考它的文档。</p>
<p>运行 <code>cargo bench</code> 后，会见到如下打印（如果你的代码无法通过，可以参考 repo 里的 diff_benchmark，我顺便做了一点小重构）：</p>
<pre><code>preparing server and subscribers....................................................................................................Done!
publishing              time:   [419.73 ms 426.84 ms 434.20 ms]                     
                        change: [-1.6712% +1.0499% +3.6586%] (p = 0.48 &gt; 0.05)
                        No change in performance detected.
</code></pre>
<p>可以看到，单个 publish 的处理速度要 426ms，好慢！我们把之前在 start_tls_server() 里加的延迟去掉，再次测试：</p>
<pre><code>preparing server and subscribers....................................................................................................Done!
publishing              time:   [318.61 ms 324.48 ms 329.81 ms]                     
                        change: [-25.854% -23.980% -22.144%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
</code></pre>
<p>嗯，这下 324ms，正好是减去刚才加的 100ms。可是这个速度依旧不合理，凭直觉我们感觉一下这个速度，是 Python 这样的语言还正常，如果是 Rust 也太慢了吧？</p>
<h2>测量和监控</h2>
<p>工业界有句名言：如果你无法测量，那你就无法改进（If you can’t measure it, you can’t improve it）。现在知道了 KV server 性能有问题，但并不知道问题出在哪里。我们需要使用合适的测量方式。</p>
<p>目前，<strong>比较好的端对端的性能监控和测量工具是 jaeger</strong>，我们可以在 KV server/client 侧收集监控信息，发送给 jaeger 来查看在服务器和客户端的整个处理流程中，时间都花费到哪里去了。</p>
<p>之前我们在 KV server 里使用的日志工具是 tracing，不过日志只是它的诸多功能之一，它还能做 <a href="https://docs.rs/tracing/0.1.28/tracing/attr.instrument.html">instrument</a>，然后配合 <a href="https://github.com/open-telemetry/opentelemetry-rust">opentelemetry</a> 库，我们就可以把 instrument 的结果发送给 jaeger 了。</p>
<p>好，在 Cargo.toml 里添加新的依赖：</p>
<pre><code>[dependencies]
...
opentelemetry-jaeger = &quot;0.15&quot; # opentelemetry jaeger 支持
...
tracing-appender = &quot;0.1&quot; # 文件日志
tracing-opentelemetry = &quot;0.15&quot; # opentelemetry 支持
tracing-subscriber = { version = &quot;0.2&quot;, features = [&quot;json&quot;, &quot;chrono&quot;] } # 日志处理
</code></pre>
<p>有了这些依赖后，在 benches/pubsub.rs 里，我们可以在初始化 tracing_subscriber 时，使用 jaeger 和 opentelemetry tracer：</p>
<pre><code>fn pubsub(c: &amp;mut Criterion) {
    let tracer = opentelemetry_jaeger::new_pipeline()
        .with_service_name(&quot;kv-bench&quot;)
        .install_simple()
        .unwrap();
    let opentelemetry = tracing_opentelemetry::layer().with_tracer(tracer);

    tracing_subscriber::registry()
        .with(EnvFilter::from_default_env())
        .with(opentelemetry)
        .init();

    let root = span!(tracing::Level::INFO, &quot;app_start&quot;, work_units = 2);
    let _enter = root.enter();
    // 创建 Tokio runtime
		...
}
</code></pre>
<p>设置好 tracing 后，就在系统的主流程上添加相应的 instrument：-
<img src="assets/f1680244d5c7901ec26181c01bfea8a1.jpg" alt="" /></p>
<p>新添加的代码你可以看 repo 中的 diff_telemetry。注意 instrument 可以用不同的名称，比如，对于 TlsConnector::new() 函数，可以用 <code>#[instrument(name = &quot;tls_connector_new&quot;)]</code>，这样它的名字辨识度高一些。</p>
<p>为主流程中的函数添加完 instrument 后，你需要先打开一个窗口，运行 jaeger（需要 docker）：</p>
<pre><code>docker run -d -p6831:6831/udp -p6832:6832/udp -p16686:16686 -p14268:14268 jaegertracing/all-in-one:latest
</code></pre>
<p>然后带着 RUST_LOG=info 运行 benchmark：</p>
<pre><code>RUST_LOG=info cargo bench
</code></pre>
<p>由于我的 OS X 上没装 docker（docker 不支持 Mac，需要 Linux VM 中转），我就在一个 Ubuntu 虚拟机里运行这两条命令：</p>
<pre><code>preparing server and subscribers....................................................................................................Done!
publishing              time:   [1.7464 ms 1.9556 ms 2.2343 ms]                       
Found 2 outliers among 10 measurements (20.00%)
  1 (10.00%) high mild
  1 (10.00%) high severe
</code></pre>
<p>并没有做任何事情，似乎只是换了个系统，性能就提升了很多，这给我们一个 tip：也许问题出在 OS X 和 Linux 系统相关的部分。</p>
<p>不管怎样，已经发送了不少数据给 jaeger，我们到 jaeger 上看看问题出在哪里。</p>
<p>打开 <a href="http://localhost:16686/">http://localhost:16686/</a>，service 选 kv-bench，Operation 选 app_start，点击 “Find Traces”，我们可以看到捕获的 trace。因为运行了两次 benchmark，所以有两个 app_start 的查询结果：-
<img src="assets/ecd9b1d06debe7fb3fe507befd803877.png" alt="" /></p>
<p>可以看到，每次 start_client_with_config 都要花 1.6-2.5ms，其中有差不多一小半时间花在了 TlsClientConnector::new() 上：-
<img src="assets/fe574ccac09ce5434027fce2afebaeb6.png" alt="" /></p>
<p>如果说 TlsClientConnector::connect() 花不少时间还情有可原，因为这是整个 TLS 协议的握手过程，涉及到网络调用、包的加解密等。<strong>但 TlsClientConnector::new() 就是加载一些证书、创建 TlsConnector 这个数据结构而已，为何这么慢</strong>？</p>
<p>仔细阅读 TlsClientConnector::new() 的代码，你可以对照注释看：</p>
<pre><code>#[instrument(name = &quot;tls_connector_new&quot;, skip_all)]
pub fn new(
    domain: impl Into&lt;String&gt; + std::fmt::Debug,
    identity: Option&lt;(&amp;str, &amp;str)&gt;,
    server_ca: Option&lt;&amp;str&gt;,
) -&gt; Result&lt;Self, KvError&gt; {
    let mut config = ClientConfig::new();

    // 如果有客户端证书，加载之
    if let Some((cert, key)) = identity {
        let certs = load_certs(cert)?;
        let key = load_key(key)?;
        config.set_single_client_cert(certs, key)?;
    }

    // 加载本地信任的根证书链
    config.root_store = match rustls_native_certs::load_native_certs() {
        Ok(store) | Err((Some(store), _)) =&gt; store,
        Err((None, error)) =&gt; return Err(error.into()),
    };

    // 如果有签署服务器的 CA 证书，则加载它，这样服务器证书不在根证书链
    // 但是这个 CA 证书能验证它，也可以
    if let Some(cert) = server_ca {
        let mut buf = Cursor::new(cert);
        config.root_store.add_pem_file(&amp;mut buf).unwrap();
    }

    Ok(Self {
        config: Arc::new(config),
        domain: Arc::new(domain.into()),
    })
}
</code></pre>
<p>可以发现，它的代码唯一可能影响性能的就是加载本地信任的根证书链的部分。这个代码会和操作系统交互，获取信任的根证书链。也许，这就是影响性能的原因之一？</p>
<p><strong>那我们将其简单重构一下</strong>。因为根证书链，只有在客户端没有提供用于验证服务器证书的 CA 证书时，才需要，所以可以在没有 CA 证书时，才加载本地的根证书链：</p>
<pre><code>#[instrument(name = &quot;tls_connector_new&quot;, skip_all)]
pub fn new(
    domain: impl Into&lt;String&gt; + std::fmt::Debug,
    identity: Option&lt;(&amp;str, &amp;str)&gt;,
    server_ca: Option&lt;&amp;str&gt;,
) -&gt; Result&lt;Self, KvError&gt; {
    let mut config = ClientConfig::new();

    // 如果有客户端证书，加载之
    if let Some((cert, key)) = identity {
        let certs = load_certs(cert)?;
        let key = load_key(key)?;
        config.set_single_client_cert(certs, key)?;
    }

    // 如果有签署服务器的 CA 证书，则加载它，这样服务器证书不在根证书链
    // 但是这个 CA 证书能验证它，也可以
    if let Some(cert) = server_ca {
        let mut buf = Cursor::new(cert);
        config.root_store.add_pem_file(&amp;mut buf).unwrap();
    } else {
        // 加载本地信任的根证书链
        config.root_store = match rustls_native_certs::load_native_certs() {
            Ok(store) | Err((Some(store), _)) =&gt; store,
            Err((None, error)) =&gt; return Err(error.into()),
        };
    }

    Ok(Self {
        config: Arc::new(config),
        domain: Arc::new(domain.into()),
    })
}
</code></pre>
<p>完成这个修改后，我们再运行 <code>RUST_LOG=info cargo bench</code>，现在的性能达到了 1.64ms，相比之前的 1.95ms，提升了 16%。</p>
<p>打开 jaeger，看最新的 app_start 结果，发现 TlsClientConnector::new() 所花时间降到了 ~12us 左右。嗯，虽然没有抓到服务器本身的 bug，但客户端的 bug 倒是解决了一个。-
<img src="assets/3cfde740dbe0d4a897e2d4c3684b530b.png" alt="" /></p>
<p>至于服务器，如果我们看 Service::execute 的主流程，执行速度在 40-60us，问题不大：-
<img src="assets/7be6139668c82fb8b79fb66f3ed06d31.png" alt="" /></p>
<p>再看服务器的主流程 server_process：-
<img src="assets/076402ac25b507295d022b980378e363.png" alt="" /></p>
<p>这是我们在 start_tls_server() 里额外添加的 tracing span：</p>
<pre><code>loop {
		let root = span!(tracing::Level::INFO, &quot;server_process&quot;);
		let _enter = root.enter();
		...
}
</code></pre>
<p>把右上角的 trace timeline 改成 trace graph，然后点右侧的 time：-
<img src="assets/1499657924a241e43c9d1be467793041.png" alt="" /></p>
<p>可以看到，主要的服务器时间都花在了 TLS accept 上，所以，<strong>目前服务器没有太多值得优化的地方</strong>。</p>
<p>由于 tracing 本身也占用不少 CPU，所以我们直接 <code>cargo bench</code> 看看目前的结果：</p>
<pre><code>preparing server and subscribers....................................................................................................Done!
publishing              time:   [1.3986 ms 1.4140 ms 1.4474 ms]                       
                        change: [-26.647% -19.977% -10.798%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 2 outliers among 10 measurements (20.00%)
  2 (20.00%) high severe
</code></pre>
<p>不加 RUST_LOG=info 后，整体性能到了 1.4ms。这是我在 Ubuntu 虚拟机下的结果。</p>
<p>我们再回到 OS X 下测试，看看 TlsClientConnector::new() 的修改，对OS X 是否有效：</p>
<pre><code>preparing server and subscribers....................................................................................................Done!
publishing              time:   [1.4086 ms 1.4229 ms 1.4315 ms]                       
                        change: [-99.570% -99.563% -99.554%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
</code></pre>
<p>嗯，在我的 OS X下，现在整体性能也到了 1.4ms 的水平。这也意味着，在有 100 个 subscribers 的情况下，我们的 KV server 每秒钟可以处理 714k publish 请求；而在 1000 个 subscribers 的情况下，性能在 11.1ms 的水平，也就是每秒可以处理 90k publish 请求：</p>
<pre><code>publishing              time:   [11.007 ms 11.095 ms 11.253 ms]                      
                        change: [-96.618% -96.556% -96.486%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
</code></pre>
<p>你也许会觉得目前 publish 的 value 太小，那换一些更加贴近实际的字符串大小：</p>
<pre><code>// let values = &amp;[&quot;Hello&quot;, &quot;Tyr&quot;, &quot;Goodbye&quot;, &quot;World&quot;];
let base_str = include_str!(&quot;../fixtures/server.conf&quot;); // 891 bytes

let values: &amp;'static [&amp;'static str] = Box::leak(
    vec![
        &amp;base_str[..64],
        &amp;base_str[..128],
        &amp;base_str[..256],
        &amp;base_str[..512],
    ]
    .into_boxed_slice(),
);
</code></pre>
<p>测试结果差不太多：</p>
<pre><code>publishing              time:   [10.917 ms 11.098 ms 11.428 ms]                      
                        change: [-0.4822% +2.3311% +4.9631%] (p = 0.12 &gt; 0.05)
                        No change in performance detected.
</code></pre>
<p>criterion 还会生成漂亮的 report，你可以用浏览器打开 ./target/criterion/publishing/report/index.html 查看（名字是publishing ，因为 benchmark ID 是 publishing）：-
<img src="assets/d3cebd8e3c164171febbe34e43916885.png" alt="" /></p>
<p>好，处理完性能相关的问题，我们来<strong>为 server 添加日志和性能监测的支持</strong>：</p>
<pre><code>use std::env;

use anyhow::Result;
use kv6::{start_server_with_config, RotationConfig, ServerConfig};
use tokio::fs;
use tracing::span;
use tracing_subscriber::{
    fmt::{self, format},
    layer::SubscriberExt,
    prelude::*,
    EnvFilter,
};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // 如果有环境变量，使用环境变量中的 config
    let config = match env::var(&quot;KV_SERVER_CONFIG&quot;) {
        Ok(path) =&gt; fs::read_to_string(&amp;path).await?,
        Err(_) =&gt; include_str!(&quot;../fixtures/server.conf&quot;).to_string(),
    };
    let config: ServerConfig = toml::from_str(&amp;config)?;

    let tracer = opentelemetry_jaeger::new_pipeline()
        .with_service_name(&quot;kv-server&quot;)
        .install_simple()?;
    let opentelemetry = tracing_opentelemetry::layer().with_tracer(tracer);

    // 添加
    let log = &amp;config.log;
    let file_appender = match log.rotation {
        RotationConfig::Hourly =&gt; tracing_appender::rolling::hourly(&amp;log.path, &quot;server.log&quot;),
        RotationConfig::Daily =&gt; tracing_appender::rolling::daily(&amp;log.path, &quot;server.log&quot;),
        RotationConfig::Never =&gt; tracing_appender::rolling::never(&amp;log.path, &quot;server.log&quot;),
    };

    let (non_blocking, _guard1) = tracing_appender::non_blocking(file_appender);
    let fmt_layer = fmt::layer()
        .event_format(format().compact())
        .with_writer(non_blocking);

    tracing_subscriber::registry()
        .with(EnvFilter::from_default_env())
        .with(fmt_layer)
        .with(opentelemetry)
        .init();

    let root = span!(tracing::Level::INFO, &quot;app_start&quot;, work_units = 2);
    let _enter = root.enter();

    start_server_with_config(&amp;config).await?;

    Ok(())
}
</code></pre>
<p>为了让日志能在配置文件中配置，需要更新一下 src/config.rs：</p>
<pre><code>#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ServerConfig {
    pub general: GeneralConfig,
    pub storage: StorageConfig,
    pub tls: ServerTlsConfig,
    pub log: LogConfig,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct LogConfig {
    pub path: String,
    pub rotation: RotationConfig,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub enum RotationConfig {
    Hourly,
    Daily,
    Never,
}
</code></pre>
<p>你还需要更新 examples/gen_config.rs。相关的改变可以看 repo 下的 diff_logging。-
tracing 和 opentelemetry 还支持 <a href="https://github.com/prometheus/prometheus">prometheus</a>，你可以使用 <a href="https://docs.rs/opentelemetry-prometheus">opentelemetry-prometheus</a> 来和 prometheus 交互，如果有兴趣，你可以自己深入研究一下。</p>
<h2>CI/CD</h2>
<p>为了讲述方便，我把 CI/CD 放在最后，但 CI/CD 应该是在一开始的时候就妥善设置的。</p>
<p>先说CI吧。这个课程的 repo <a href="https://github.com/tyrchen/geektime-rust">tyrchen/geektime-rust</a> 在一开始就设置了 github action，每次 commit 都会运行：</p>
<ul>
<li>代码格式检查：cargo fmt</li>
<li>依赖 license 检查：cargo deny</li>
<li>linting：cargo check 和 cargo clippy</li>
<li>单元测试和集成测试：cargo test</li>
<li>生成文档：cargo doc</li>
</ul>
<p>github action 配置如下，供你参考：</p>
<pre><code>name: build

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

jobs:
  build-rust:
    strategy:
      matrix:
        platform: [ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="25464d40464e4a5051655317">[email&#160;protected]</a>
      - name: Cache cargo registry
        uses: actions/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="ed8e8c8e8588ad9bdc">[email&#160;protected]</a>
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry
      - name: Cache cargo index
        uses: actions/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="d3b0b2b0bbb693a5e2">[email&#160;protected]</a>
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index
      - name: Cache cargo build
        uses: actions/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="b8dbd9dbd0ddf8ce89">[email&#160;protected]</a>
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-target
      - name: Install stable
        uses: actions-rs/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="e5918a8a89868d848c8ba593d4">[email&#160;protected]</a>
        with:
          profile: minimal
          toolchain: stable
          override: true
      - name: Check code format
        run: cargo fmt -- --check
      - name: Check the package for errors
        run: cargo check --all
      - name: Lint rust sources
        run: cargo clippy --all-targets --all-features --tests --benches -- -D warnings
      - name: Run tests
        run: cargo test --all-features -- --test-threads=1 --nocapture
      - name: Generate docs
        run: cargo doc --all-features --no-deps
      - name: Deploy docs to gh-page
        uses: peaceiris/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="167775627f7978653b717e3b6677717365566025">[email&#160;protected]</a>
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./target/doc
</code></pre>
<p>除此之外，我们还可以在每次 push tag 时做 release：</p>
<pre><code>name: release

on:
  push:
    tags:
      - &quot;v*&quot; # Push events to matching v*, i.e. v1.0, v20.15.10

jobs:
  build:
    name: Upload Release Asset
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
    steps:
      - name: Cache cargo registry
        uses: actions/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="ee8d8f8d868bae98df">[email&#160;protected]</a>
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry
      - name: Cache cargo index
        uses: actions/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="bfdcdedcd7daffc98e">[email&#160;protected]</a>
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index
      - name: Cache cargo build
        uses: actions/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="ec8f8d8f8489ac9add">[email&#160;protected]</a>
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-target
      - name: Checkout code
        uses: actions/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="d1b2b9b4b2babea4a591a7e3">[email&#160;protected]</a>
        with:
          token: ${{ secrets.GH_TOKEN }}
          submodules: recursive
      - name: Build project
        run: |
          make build-release
      - name: Create Release
        id: create_release
        uses: actions/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="c1a2b3a4a0b5a4ecb3a4ada4a0b2a481b7f0">[email&#160;protected]</a>
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false
      - name: Upload asset
        id: upload-kv-asset
        uses: actions/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="f98c899596989dd48b9c959c988a9cd4988a8a9c8db98fc8">[email&#160;protected]</a>
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./target/release/kvs
          asset_name: kvs
          asset_content_type: application/octet-stream
      - name: Set env
        run: echo &quot;RELEASE_VERSION=${GITHUB_REF#refs/*/}&quot; &gt;&gt; $GITHUB_ENV
      - name: Deploy docs to gh-page
        uses: peaceiris/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="244547504d4b4a5709434c095445434157645217">[email&#160;protected]</a>
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./target/doc/simple_kv
          destination_dir: ${{ env.RELEASE_VERSION }}
</code></pre>
<p>这样，每次 push tag 时，都可以打包出来 Linux 的 kvs 版本：-
<img src="assets/1c61b7f58dd176bd25a565577d75af19.png" alt="" /></p>
<p>如果你不希望直接使用编译出来的二进制，也可以打包成 docker，在 Kubernetes 下使用。</p>
<p><strong>在做 CI 的过程中，我们也可以触发 CD</strong>，比如：</p>
<ul>
<li>PR merge 到 master，在 build 完成后，触发 dev 服务器的部署，团队内部可以尝试；</li>
<li>如果 release tag 包含 alpha，在 build 完成后，触发 staging 服务器的部署，公司内部可以使用；</li>
<li>如果 release tag 包含 beta，在 build 完成后，触发 beta 服务器的部署，beta 用户可以使用；</li>
<li>正式的 release tag 会触发生产环境的滚动升级，升级覆盖到的用户可以使用。</li>
</ul>
<p>一般来说，每家企业都有自己的 CI/CD 的工具链，这里为了展示方便，我们演示了如何使用 github action 对 Rust 代码做 CI，你可以按照自己的需要来处理。</p>
<p>在刚才的 action 代码中，还编译并上传了文档，所以我们可以通过 github pages 很方便地访问文档：-
<img src="assets/885d092273f8cacda1a65867a2489ea7.png" alt="" /></p>
<h2>小结</h2>
<p>我们的 KV server 之旅就到此为止了。在整整 7 堂课里，我们一点点从零构造了一个完整的 KV server，包括注释在内，撰写了近三千行代码：</p>
<pre><code>❯ tokei .
-------------------------------------------------------------------------------
 Language            Files        Lines         Code     Comments       Blanks
-------------------------------------------------------------------------------
 Makefile                1           24           16            1            7
 Markdown                1            7            7            0            0
 Protocol Buffers        1          119           79           23           17
 Rust                   25         3366         2730          145          491
 TOML                    2          268          107          142           19
-------------------------------------------------------------------------------
 Total                  30         3784         2939          311          534
-------------------------------------------------------------------------------
</code></pre>
<p>这是一个非常了不起的成就！我们应该为自己感到自豪！</p>
<p>在这个系列里，我们大量使用 trait 和泛型，构建了很多复杂的数据结构；还为自己的类型实现了 AsyncRead/AsyncWrite/Stream/Sink 这些比较高阶的 trait。通过良好的设计，我们把网络层和业务层划分地非常清晰，网络层的变化不会影响到业务层，反之亦然：-
<img src="assets/53f5e5cf68b4300c3231885b10c784f3.jpeg" alt="" /></p>
<p>我们还模拟了比较真实的开发场景，通过大的需求变更，引发了一次不小的代码重构。</p>
<p>最终，通过性能测试，发现了一个客户端实现的小 bug。在处理这个 bug 的时候，我们欣喜地看到，Rust 有着非常强大的测试工具链，除了我们使用的单元测试、集成测试、性能测试，Rust 还支持模糊测试（fuzzy testing）和基于特性的测试（property testing）。</p>
<p>对于测试过程中发现的问题，Rust 有着非常完善的 tracing 工具链，可以和整个 opentelemetry 生态系统（包括 jaeger、prometheus 等工具）打通。我们就是通过使用 jaeger 找到并解决了问题。除此之外，Rust tracing 工具链还支持生成 <a href="https://github.com/tokio-rs/tracing/tree/master/tracing-flame">flamegraph</a>，篇幅关系，没有演示，你感兴趣的话可以试试。</p>
<p>最后，我们完善了 KV server 的配置、日志以及 CI。完整的代码我放在了 <a href="https://github.com/tyrchen/simple-kv">github.com/tyrchen/simple-kv</a> 上，欢迎查看最终的版本。</p>
<p>希望通过这个系列，你对如何使用 Rust 的特性来构造应用程序有了深度的认识。我相信，如果你能够跟得上这个系列的节奏，另外如果遇到新的库，用[第 20 讲]阅读代码的方式快速掌握，那么，大部分 Rust 开发中的挑战，对你而言都不是难事。</p>
<h3>思考题</h3>
<p>我们目前并未对日志做任何配置。一般来说，怎么做日志，会有相应的开关以及日志级别，如果希望能通过如下的配置记录日志，该怎么做？试试看：</p>
<pre><code>[log]
enable_log_file = true
enable_jaeger = false
log_level = 'info'
path = '/tmp/kv-log'
rotation = 'Daily'
</code></pre>
<p>欢迎在留言区分享自己做 KV server 系列的想法和感悟。你已经完成了第45次打卡，我们下节课见。</p>
</div>
                        </div>
                        <div>
                            <div style="float: left">
                                <a href="44%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%89%93%E4%BA%A4%E9%81%93%EF%BC%9F.md.html">上一页</a>
                            </div>
                            <div style="float: right">
                                <a href="46%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8Rust%E6%9E%B6%E6%9E%84%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F%EF%BC%9F.md.html">下一页</a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="copyright"><p>© 2019 - 2023 <a href="../../cdn-cgi/l/email-protection.html#a2cecece9b9693939295e2c5cfc3cbce8cc1cdcf" target="_blank">Liangliang Lee</a>. Powered by <a href="https://vertx.io/" target="_blank">Vert.x</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p></div>
        </div>

        <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
    </div>
<script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script defer src="https://static.cloudflareinsights.com/beacon.min.js/vb26e4fa9e5134444860be286fd8771851679335129114" integrity="sha512-M3hN/6cva/SjwrOtyXeUa5IuCT0sedyfT+jK/OV+s+D0RnzrTfwjwJHhd+wYfMm9HJSrZ1IKksOdddLuN6KOzw==" data-cf-beacon='{"rayId":"7af4aef699cafaaa","version":"2023.3.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }

    hljs.initHighlightingOnLoad()

</script>

</html>
