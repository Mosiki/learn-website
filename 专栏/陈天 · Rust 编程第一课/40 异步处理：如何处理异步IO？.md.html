<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>40 异步处理：如何处理异步IO？.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <link rel="stylesheet"
              href="../../static/highlight.min.css">
        <script src="../../static/highlight.min.js"></script>
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5295275829820252"
                crossorigin="anonymous"></script>
        <script async defer data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" src="https://analyze.lianglianglee.com/umami.js"></script>
    </head>

<body>

    <div class="book-container">
        <div class="book-sidebar">
            <div class="book-brand">
                <a href="../../index.html">
                    <img src="../../static/favicon.png">
                    <span>技术文章摘抄</span>
                </a>
            </div>
            <div class="book-menu uncollapsible">
                <ul class="uncollapsible">
                    <li><a href="../../index.html" class="current-tab">首页</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li><a href="../index.html">上一级</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li>

                        
                        <a href="00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%E8%AE%A9Rust%E6%88%90%E4%B8%BA%E4%BD%A0%E7%9A%84%E4%B8%8B%E4%B8%80%E9%97%A8%E4%B8%BB%E5%8A%9B%E8%AF%AD%E8%A8%80.md.html">00 开篇词 让Rust成为你的下一门主力语言.md</a>

                    </li>
                    <li>

                        
                        <a href="01%20%E5%86%85%E5%AD%98%EF%BC%9A%E5%80%BC%E6%94%BE%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%94%BE%E6%A0%88%E4%B8%8A%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98.md.html">01 内存：值放堆上还是放栈上，这是一个问题.md</a>

                    </li>
                    <li>

                        
                        <a href="02%20%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E9%82%A3%E4%BA%9B%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.md.html">02 串讲：编程开发中，那些你需要掌握的基本概念.md</a>

                    </li>
                    <li>

                        
                        <a href="03%20%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%EF%BC%9A%E4%BB%8E%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AARust%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%A7%8B%EF%BC%81.md.html">03 初窥门径：从你的第一个Rust程序开始！.md</a>

                    </li>
                    <li>

                        
                        <a href="04%20get%20hands%20dirty%EF%BC%9A%E6%9D%A5%E5%86%99%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84CLI%E5%B0%8F%E5%B7%A5%E5%85%B7.md.html">04 get hands dirty：来写个实用的CLI小工具.md</a>

                    </li>
                    <li>

                        
                        <a href="05%20get%20hands%20dirty%EF%BC%9A%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E5%A4%9A%E9%9A%BE%EF%BC%9F.md.html">05 get hands dirty：做一个图片服务器有多难？.md</a>

                    </li>
                    <li>

                        
                        <a href="06%20get%20hands%20dirty%EF%BC%9ASQL%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7%E6%80%8E%E4%B9%88%E4%B8%80%E9%B1%BC%E5%A4%9A%E5%90%83%EF%BC%9F.md.html">06 get hands dirty：SQL查询工具怎么一鱼多吃？.md</a>

                    </li>
                    <li>

                        
                        <a href="07%20%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%81%E6%89%8B%E4%B8%8A%EF%BC%9F.md.html">07 所有权：值的生杀大权到底在谁手上？.md</a>

                    </li>
                    <li>

                        
                        <a href="08%20%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E5%80%9F%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F.md.html">08 所有权：值的借用是如何工作的？.md</a>

                    </li>
                    <li>

                        
                        <a href="09%20%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F.md.html">09 所有权：一个值可以有多个所有者么？.md</a>

                    </li>
                    <li>

                        
                        <a href="10%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E4%BD%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%80%BC%E7%A9%B6%E7%AB%9F%E8%83%BD%E6%B4%BB%E5%A4%9A%E4%B9%85%EF%BC%9F.md.html">10 生命周期：你创建的值究竟能活多久？.md</a>

                    </li>
                    <li>

                        
                        <a href="11%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.md.html">11 内存管理：从创建到消亡，值都经历了什么？.md</a>

                    </li>
                    <li>

                        
                        <a href="12%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F.md.html">12 类型系统：Rust的类型系统有什么特点？.md</a>

                    </li>
                    <li>

                        
                        <a href="13%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8trait%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F.md.html">13 类型系统：如何使用trait来定义接口？.md</a>

                    </li>
                    <li>

                        
                        <a href="14%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84trait%EF%BC%9F.md.html">14 类型系统：有哪些必须掌握的trait？.md</a>

                    </li>
                    <li>

                        
                        <a href="15%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%99%E4%BA%9B%E6%B5%93%E7%9C%89%E5%A4%A7%E7%9C%BC%E7%9A%84%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E9%83%BD%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F.md.html">15 数据结构：这些浓眉大眼的结构竟然都是智能指针？.md</a>

                    </li>
                    <li>

                        
                        <a href="16%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVec_T_%E3%80%81&amp;%5BT%5D%E3%80%81Box_%5BT%5D_%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F.md.html">16 数据结构：Vec_T_、&amp;[T]、Box_[T]_ ，你真的了解集合容器么？.md</a>

                    </li>
                    <li>

                        
                        <a href="17%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F.md.html">17 数据结构：软件系统核心部件哈希表，内存如何布局？.md</a>

                    </li>
                    <li>

                        
                        <a href="18%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Rust%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%EF%BC%9F.md.html">18 错误处理：为什么Rust的错误处理与众不同？.md</a>

                    </li>
                    <li>

                        
                        <a href="19%20%E9%97%AD%E5%8C%85%EF%BC%9AFnOnce%E3%80%81FnMut%E5%92%8CFn%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E7%B1%BB%E5%9E%8B%EF%BC%9F.md.html">19 闭包：FnOnce、FnMut和Fn，为什么有这么多类型？.md</a>

                    </li>
                    <li>

                        
                        <a href="20%204%20Steps%20%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E9%98%85%E8%AF%BBRust%E6%BA%90%E7%A0%81%EF%BC%9F.md.html">20 4 Steps ：如何更好地阅读Rust源码？.md</a>

                    </li>
                    <li>

                        
                        <a href="21%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%881%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.md.html">21 阶段实操（1）：构建一个简单的KV server-基本流程.md</a>

                    </li>
                    <li>

                        
                        <a href="22%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%882%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.md.html">22 阶段实操（2）：构建一个简单的KV server-基本流程.md</a>

                    </li>
                    <li>

                        
                        <a href="23%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%9F.md.html">23 类型系统：如何在实战中使用泛型编程？.md</a>

                    </li>
                    <li>

                        
                        <a href="24%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E4%BD%BF%E7%94%A8trait%20object%EF%BC%9F.md.html">24 类型系统：如何在实战中使用trait object？.md</a>

                    </li>
                    <li>

                        
                        <a href="25%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9B%B4%E7%BB%95trait%E6%9D%A5%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%9E%B6%E6%9E%84%E7%B3%BB%E7%BB%9F%EF%BC%9F.md.html">25 类型系统：如何围绕trait来设计和架构系统？.md</a>

                    </li>
                    <li>

                        
                        <a href="26%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%883%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E9%AB%98%E7%BA%A7trait%E6%8A%80%E5%B7%A7.md.html">26 阶段实操（3）：构建一个简单的KV server-高级trait技巧.md</a>

                    </li>
                    <li>

                        
                        <a href="27%20%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E6%9C%89%E7%9A%84Rust%E5%BA%93%E5%8F%AF%E4%BB%A5%E4%B8%BA%E6%88%91%E6%89%80%E7%94%A8%EF%BC%9F.md.html">27 生态系统：有哪些常有的Rust库可以为我所用？.md</a>

                    </li>
                    <li>

                        
                        <a href="28%20%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rust%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%9F.md.html">28 网络开发（上）：如何使用Rust处理网络请求？.md</a>

                    </li>
                    <li>

                        
                        <a href="29%20%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rust%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%9F.md.html">29 网络开发（下）：如何使用Rust处理网络请求？.md</a>

                    </li>
                    <li>

                        
                        <a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%99%88%E5%A4%A9%20%C2%B7%20Rust%20%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/30%20Unsafe%20Rust%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8C++%E7%9A%84%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80Rust%EF%BC%9F.md">30 Unsafe Rust：如何用C++的方式打开Rust？.md</a>

                    </li>
                    <li>

                        
                        <a href="31%20FFI%EF%BC%9ARust%E5%A6%82%E4%BD%95%E5%92%8C%E4%BD%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E6%9E%B6%E8%B5%B7%E6%B2%9F%E9%80%9A%E6%A1%A5%E6%A2%81%EF%BC%9F.md.html">31 FFI：Rust如何和你的语言架起沟通桥梁？.md</a>

                    </li>
                    <li>

                        
                        <a href="32%20%E5%AE%9E%E6%93%8D%E9%A1%B9%E7%9B%AE%EF%BC%9A%E4%BD%BF%E7%94%A8PyO3%E5%BC%80%E5%8F%91Python3%E6%A8%A1%E5%9D%97.md.html">32 实操项目：使用PyO3开发Python3模块.md</a>

                    </li>
                    <li>

                        
                        <a href="33%20%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BB%8Eatomics%E5%88%B0Channel%EF%BC%8CRust%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%EF%BC%9F.md.html">33 并发处理（上）：从atomics到Channel，Rust都提供了什么工具？.md</a>

                    </li>
                    <li>

                        
                        <a href="34%20%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%BB%8Eatomics%E5%88%B0Channel%EF%BC%8CRust%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%EF%BC%9F.md.html">34 并发处理（下）：从atomics到Channel，Rust都提供了什么工具？.md</a>

                    </li>
                    <li>

                        
                        <a href="35%20%E5%AE%9E%E6%93%8D%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84MPSC%20channel%EF%BC%9F.md.html">35 实操项目：如何实现一个基本的MPSC channel？.md</a>

                    </li>
                    <li>

                        
                        <a href="36%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%884%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86.md.html">36 阶段实操（4）：构建一个简单的KV server-网络处理.md</a>

                    </li>
                    <li>

                        
                        <a href="37%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%885%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.md.html">37 阶段实操（5）：构建一个简单的KV server-网络安全.md</a>

                    </li>
                    <li>

                        
                        <a href="38%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9AFuture%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E5%92%8Casync_await%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F.md.html">38 异步处理：Future是什么？它和async_await是什么关系？.md</a>

                    </li>
                    <li>

                        
                        <a href="39%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9Aasync_await%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.md.html">39 异步处理：async_await内部是怎么实现的？.md</a>

                    </li>
                    <li>

                        <a class="current-tab" href="40%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5IO%EF%BC%9F.md.html">40 异步处理：如何处理异步IO？.md</a>
                        

                    </li>
                    <li>

                        
                        <a href="41%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%886%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.md.html">41 阶段实操（6）：构建一个简单的KV server-异步处理.md</a>

                    </li>
                    <li>

                        
                        <a href="42%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%887%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A4%A7%E7%9A%84%E9%87%8D%E6%9E%84%EF%BC%9F.md.html">42 阶段实操（7）：构建一个简单的KV server-如何做大的重构？.md</a>

                    </li>
                    <li>

                        
                        <a href="43%20%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%EF%BC%9A%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E4%B8%8B%E7%9A%84%E4%B8%80%E4%B8%AARust%E9%A1%B9%E7%9B%AE%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E8%A6%81%E7%B4%A0%EF%BC%9F.md.html">43 生产环境：真实世界下的一个Rust项目包含哪些要素？.md</a>

                    </li>
                    <li>

                        
                        <a href="44%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%89%93%E4%BA%A4%E9%81%93%EF%BC%9F.md.html">44 数据处理：应用程序和数据如何打交道？.md</a>

                    </li>
                    <li>

                        
                        <a href="45%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%888%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E9%85%8D%E7%BD%AE_%E6%B5%8B%E8%AF%95_%E7%9B%91%E6%8E%A7_CI_CD.md.html">45 阶段实操（8）：构建一个简单的KV server-配置_测试_监控_CI_CD.md</a>

                    </li>
                    <li>

                        
                        <a href="46%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8Rust%E6%9E%B6%E6%9E%84%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F%EF%BC%9F.md.html">46 软件架构：如何用Rust架构复杂系统？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20Rust2021%E7%89%88%E6%AC%A1%E9%97%AE%E4%B8%96%E4%BA%86%EF%BC%81.md.html">加餐 Rust2021版次问世了！.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E4%BB%A3%E7%A0%81%E5%8D%B3%E6%95%B0%E6%8D%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%AE%8F%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%EF%BC%9F.md.html">加餐 代码即数据：为什么我们需要宏编程能力？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E5%AE%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E7%94%A8%E6%9C%80%E2%80%9C%E7%AC%A8%E2%80%9D%E7%9A%84%E6%96%B9%E5%BC%8F%E6%92%B0%E5%86%99%E5%AE%8F.md.html">加餐 宏编程（上）：用最“笨”的方式撰写宏.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E5%AE%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%94%A8%20syn_quote%20%E4%BC%98%E9%9B%85%E5%9C%B0%E6%9E%84%E5%BB%BA%E5%AE%8F.md.html">加餐 宏编程（下）：用 syn_quote 优雅地构建宏.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E6%84%9A%E6%98%A7%E4%B9%8B%E5%B7%85%EF%BC%9A%E4%BD%A0%E7%9A%84Rust%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.md.html">加餐 愚昧之巅：你的Rust学习常见问题汇总.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E6%9C%9F%E4%B8%AD%E6%B5%8B%E8%AF%95%EF%BC%9A%E5%8F%82%E8%80%83%E5%AE%9E%E7%8E%B0%E8%AE%B2%E8%A7%A3.md.html">加餐 期中测试：参考实现讲解.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E6%9C%9F%E4%B8%AD%E6%B5%8B%E8%AF%95%EF%BC%9A%E6%9D%A5%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84grep%E5%91%BD%E4%BB%A4%E8%A1%8C.md.html">加餐 期中测试：来写一个简单的grep命令行.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E8%BF%99%E4%B8%AA%E4%B8%93%E6%A0%8F%E4%BD%A0%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%AD%A6%EF%BC%8C%E4%BB%A5%E5%8F%8ARust%E6%98%AF%E5%90%A6%E5%80%BC%E5%BE%97%E5%AD%A6%EF%BC%9F.md.html">加餐 这个专栏你可以怎么学，以及Rust是否值得学？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%A4%A7%E5%92%96%E5%8A%A9%E5%9C%BA%20%E5%BC%80%E6%82%9F%E4%B9%8B%E5%9D%A1%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9ARust%E7%9A%84%E7%8E%B0%E7%8A%B6%E3%80%81%E6%9C%BA%E9%81%87%E4%B8%8E%E6%8C%91%E6%88%98.md.html">大咖助场 开悟之坡（上）：Rust的现状、机遇与挑战.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%A4%A7%E5%92%96%E5%8A%A9%E5%9C%BA%20%E5%BC%80%E6%82%9F%E4%B9%8B%E5%9D%A1%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9ARust%E7%9A%84%E7%8E%B0%E7%8A%B6%E3%80%81%E6%9C%BA%E9%81%87%E4%B8%8E%E6%8C%91%E6%88%98.md.html">大咖助场 开悟之坡（下）：Rust的现状、机遇与挑战.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%89%B9%E5%88%AB%E7%AD%96%E5%88%92%20%E5%AD%A6%E4%B9%A0%E9%94%A6%E5%9B%8A%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%90%AC%E5%90%AC%E8%AF%BE%E4%BB%A3%E8%A1%A8%E4%BB%AC%E6%80%8E%E4%B9%88%E8%AF%B4.md.html">特别策划 学习锦囊（一）：听听课代表们怎么说.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%89%B9%E5%88%AB%E7%AD%96%E5%88%92%20%E5%AD%A6%E4%B9%A0%E9%94%A6%E5%9B%8A%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%AC%E5%90%AC%E8%AF%BE%E4%BB%A3%E8%A1%A8%E4%BB%AC%E6%80%8E%E4%B9%88%E8%AF%B4.md.html">特别策划 学习锦囊（三）：听听课代表们怎么说.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%89%B9%E5%88%AB%E7%AD%96%E5%88%92%20%E5%AD%A6%E4%B9%A0%E9%94%A6%E5%9B%8A%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%90%AC%E5%90%AC%E8%AF%BE%E4%BB%A3%E8%A1%A8%E4%BB%AC%E6%80%8E%E4%B9%88%E8%AF%B4.md.html">特别策划 学习锦囊（二）：听听课代表们怎么说.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%20%E7%BB%9D%E6%9C%9B%E4%B9%8B%E8%B0%B7%EF%BC%9A%E6%94%B9%E5%8F%98%E4%BB%8E%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%A7%8B.md.html">用户故事 绝望之谷：改变从学习开始.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%20%E8%AF%AD%E8%A8%80%E4%B8%8D%E4%BB%85%E6%98%AF%E5%B7%A5%E5%85%B7%EF%BC%8C%E8%BF%98%E6%98%AF%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F.md.html">用户故事 语言不仅是工具，还是思维方式.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%BB%93%E6%9D%9F%E8%AF%AD%20%E6%B0%B8%E7%BB%AD%E4%B9%8B%E5%8E%9F%EF%BC%9ARust%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8C%81%E7%BB%AD%E7%B2%BE%E8%BF%9B%EF%BC%9F.md.html">结束语 永续之原：Rust学习，如何持续精进？.md</a>

                    </li>
                </ul>

            </div>
        </div>

        <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
            <div class="sidebar-toggle-inner"></div>
        </div>

        <script>
            function add_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.add('show')
            }

            function remove_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.remove('show')
            }

            function sidebar_toggle() {
                let sidebar_toggle = document.querySelector('.sidebar-toggle')
                let sidebar = document.querySelector('.book-sidebar')
                let content = document.querySelector('.off-canvas-content')
                if (sidebar_toggle.classList.contains('extend')) { // show
                    sidebar_toggle.classList.remove('extend')
                    sidebar.classList.remove('hide')
                    content.classList.remove('extend')
                } else { // hide
                    sidebar_toggle.classList.add('extend')
                    sidebar.classList.add('hide')
                    content.classList.add('extend')
                }
            }


            function open_sidebar() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.add('show')
                overlay.classList.add('show')
            }
            function hide_canvas() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.remove('show')
                overlay.classList.remove('show')
            }

        </script>

        <div class="off-canvas-content">
            <div class="columns">
                <div class="column col-12 col-lg-12">
                    <div class="book-navbar">
                        <!-- For Responsive Layout -->
                        <header class="navbar">
                            <section class="navbar-section">
                                <a onclick="open_sidebar()">
                                    <i class="icon icon-menu"></i>
                                </a>
                            </section>
                        </header>
                    </div>
                    <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                        <div class="book-post">
                            <p id="tip" align="center"></p>
                            <div><h1>40 异步处理：如何处理异步IO？</h1>
<p>你好，我是陈天。</p>
<p>前面两讲我们学习了异步处理基本的功能和原理（Future/async/await），但是还没有正式介绍在具体场合下该用哪些工具来处理异步 IO。不过之前讲 trait 的时候，已经了解和使用过一些处理同步 IO 的结构和 trait。</p>
<p>今天我们就对比同步 IO 来学习异步 IO。毕竟在学习某个新知识的时候，如果能够和头脑中已有的知识联系起来，大脑神经元之间的连接就会被激活，学习的效果会事半功倍。</p>
<p>回忆一下同步环境都有哪些结构和 trait呢？首先，单个的值可以用类型 T 表述，一组值可以用 Iterator trait 表述；同步 IO，我们有标准的 Read/Write/Seek trait。顾名思义，Read/Write 是进行 IO 的读写，而 Seek 是在 IO 中前后移动当前的位置。</p>
<p>那么异步呢？我们已经学习到，对于单个的、在未来某个时刻会得到的值，可以用 Future 来表示：</p>
<p><img src="assets/2371c456d1d7429caea5512f53ec5c43.jpg" alt="图片" /></p>
<p>但还不知道一组未来才能得到的值该用什么 trait 来表述，也不知道异步的 Read/Write 该是什么样子。今天，我们就来聊聊这些重要的异步数据类型。</p>
<h2>Stream trait</h2>
<p>首先来了解一下 Iterator 在异步环境下的表兄弟：Stream。</p>
<p>我们知道，对于 Iterator，可以不断调用其 next() 方法，获得新的值，直到 Iterator 返回 None。Iterator 是阻塞式返回数据的，每次调用 next()，必然独占 CPU 直到得到一个结果，<strong>而异步的 Stream 是非阻塞的，在等待的过程中会空出 CPU 做其他事情</strong>。</p>
<p>不过和 Future 已经在标准库稳定下来不同，Stream trait 目前还只能在 nightly 版本使用。一般跟 Stream 打交道，我们会使用 futures 库。来对比 Iterator 和 Stream的源码定义：</p>
<pre><code>pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { ... }
    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; where F: FnMut(Self::Item) -&gt; B { ... }
    ... // 还有 67 个方法
}

pub trait Stream {
    type Item;
    fn poll_next(self: Pin&lt;&amp;mut Self&gt;,  cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { ... }
}

pub trait StreamExt: Stream {
    fn next(&amp;mut self) -&gt; Next&lt;'_, Self&gt; where Self: Unpin { ... }
    fn map&lt;T, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; where F: FnMut(Self::Item) -&gt; T { ... }
    ... // 还有 41 个方法
}
</code></pre>
<p>可以看到，Iterator 把所有方法都放在 Iterator trait 里，而Stream 把需要开发者实现的基本方法和有缺省实现的衍生方法区别开，放在不同的 trait 里。比如 map。</p>
<p>实现 Stream 的时候，和 Iterator 类似，你需要提供 Item 类型，这是每次拿出一个值时，值的类型；此外，还有 poll_next() 方法，它长得和 Future 的 poll() 方法很像，和 Iterator 版本的 next() 的作用类似。</p>
<p>然而，poll_next() 调用起来不方便，我们需要自己处理 Poll 状态，所以，StreamExt 提供了 next() 方法，返回一个实现了 Future trait 的 Next 结构，这样，我们就可以直接通过 stream.next().await 来获取下一个值了。来看 next() 方法以及 Next 结构的实现（<a href="https://docs.rs/futures-util/0.3.17/src/futures_util/stream/stream/next.rs.html#10-34">源码</a>）：</p>
<pre><code>pub trait StreamExt: Stream {
    fn next(&amp;mut self) -&gt; Next&lt;'_, Self&gt; where Self: Unpin {
        assert_future::&lt;Option&lt;Self::Item&gt;, _&gt;(Next::new(self))
    }
}

// next 返回了 Next 结构
pub struct Next&lt;'a, St: ?Sized&gt; {
    stream: &amp;'a mut St,
}

// 如果 Stream Unpin 那么 Next 也是 Unpin
impl&lt;St: ?Sized + Unpin&gt; Unpin for Next&lt;'_, St&gt; {}

impl&lt;'a, St: ?Sized + Stream + Unpin&gt; Next&lt;'a, St&gt; {
    pub(super) fn new(stream: &amp;'a mut St) -&gt; Self {
        Self { stream }
    }
}

// Next 实现了 Future，每次 poll() 实际上就是从 stream 中 poll_next()
impl&lt;St: ?Sized + Stream + Unpin&gt; Future for Next&lt;'_, St&gt; {
    type Output = Option&lt;St::Item&gt;;

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        self.stream.poll_next_unpin(cx)
    }
}
</code></pre>
<p>看个小例子（<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=4374c885eaf1a386fe6a67d8a54dc37b">代码</a>）：</p>
<pre><code>use futures::prelude::*;

#[tokio::main]
async fn main() {
    let mut st = stream::iter(1..10)
        .filter(|x| future::ready(x % 2 == 0))
        .map(|x| x * x);

    while let Some(x) = st.next().await {
        println!(&quot;Got item: {}&quot;, x);
    }
}
</code></pre>
<p>我们使用 stream::iter 生成了一个 Stream，并对其进行 filter/map 的操作。最后，遍历整个 stream，把获得的数据打印出来。从使用的感受来看，Stream 和 Iterator 也很相似，可以对比着来用。</p>
<h3>生成 Stream</h3>
<p>futures 库提供了一些基本的生成 Stream 的方法，除了上面用到的 iter 方法，还有：</p>
<ul>
<li>empty()：生成一个空的 Stream</li>
<li>once()：生成一个只包含单个值的 Stream</li>
<li>pending()：生成一个不包含任何值，只返回 Poll::Pending 的 Stream</li>
<li>repeat()：生成一个一直返回相同值的 Stream</li>
<li>repeat_with()：通过闭包函数无穷尽地返回数据的 Stream</li>
<li>poll_fn()：通过一个返回 Poll&lt;Option<T>&gt; 的闭包来产生 Stream</li>
<li>unfold()：通过初始值和返回 Future 的闭包来产生 Stream</li>
</ul>
<p>前几种产生 Stream 的方法都很好理解，最后三种引入了闭包复杂一点，我们分别使用它们来实现斐波那契数列，对比一下差异（<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d83d2877d953b381c4f412b5768288ff">代码</a>）：</p>
<pre><code>use futures::{prelude::*, stream::poll_fn};
use std::task::Poll;

#[tokio::main]
async fn main() {
    consume(fib().take(10)).await;
    consume(fib1(10)).await;
    // unfold 产生的 Unfold stream 没有实现 Unpin，
    // 所以我们将其 Pin&lt;Box&lt;T&gt;&gt; 一下，使其满足 consume 的接口
    consume(fib2(10).boxed()).await;
}

async fn consume(mut st: impl Stream&lt;Item = i32&gt; + Unpin) {
    while let Some(v) = st.next().await {
        print!(&quot;{} &quot;, v);
    }
    print!(&quot;\\n&quot;);
}

// 使用 repeat_with 创建 stream，无法控制何时结束
fn fib() -&gt; impl Stream&lt;Item = i32&gt; {
    let mut a = 1;
    let mut b = 1;
    stream::repeat_with(move || {
        let c = a + b;
        a = b;
        b = c;
        b
    })
}

// 使用 poll_fn 创建 stream，可以通过返回 Poll::Ready(None) 来结束
fn fib1(mut n: usize) -&gt; impl Stream&lt;Item = i32&gt; {
    let mut a = 1;
    let mut b = 1;
    poll_fn(move |_cx| -&gt; Poll&lt;Option&lt;i32&gt;&gt; {
        if n == 0 {
            return Poll::Ready(None);
        }
        n -= 1;
        let c = a + b;
        a = b;
        b = c;
        Poll::Ready(Some(b))
    })
}

fn fib2(n: usize) -&gt; impl Stream&lt;Item = i32&gt; {
    stream::unfold((n, (1, 1)), |(mut n, (a, b))| async move {
        if n == 0 {
            None
        } else {
            n -= 1;
            let c = a + b;
            // c 作为 poll_next() 的返回值，(n, (a, b)) 作为 state
            Some((c, (n, (b, c))))
        }
    })
}
</code></pre>
<p>值得注意的是，<strong>使用 unfold 的时候，同时使用了局部变量和 Future，所以生成的 Stream 没有实现 Unpin</strong>，我们在使用的时候，需要将其 pin 住。怎么做呢？</p>
<p>Pin&lt;Box<T>&gt; 是一种很简单的方法，能将数据 Pin 在堆上，我们可以使用 StreamExt 的 boxed() 方法来生成一个 Pin&lt;Box<T>&gt;。</p>
<p>除了上面讲的方法，我们还可以为一个数据结构实现 Stream trait，从而使其支持 Stream。看一个例子（<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=94797b51e031dbde9d81ff04c5ff9f83">代码</a>）：</p>
<pre><code>use futures::prelude::*;
use pin_project::pin_project;
use std::{
    pin::Pin,
    task::{Context, Poll},
};
use tokio::{
    fs,
    io::{AsyncBufReadExt, AsyncRead, BufReader, Lines},
};

/// LineStream 内部使用 tokio::io::Lines
#[pin_project]
struct LineStream&lt;R&gt; {
    #[pin]
    lines: Lines&lt;BufReader&lt;R&gt;&gt;,
}

impl&lt;R: AsyncRead&gt; LineStream&lt;R&gt; {
    /// 从 BufReader 创建一个 LineStream
    pub fn new(reader: BufReader&lt;R&gt;) -&gt; Self {
        Self {
            lines: reader.lines(),
        }
    }
}

/// 为 LineStream 实现 Stream trait
impl&lt;R: AsyncRead&gt; Stream for LineStream&lt;R&gt; {
    type Item = std::io::Result&lt;String&gt;;

    fn poll_next(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt; {
        self.project()
            .lines
            .poll_next_line(cx)
            .map(Result::transpose)
    }
}

#[tokio::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let file = fs::File::open(&quot;Cargo.toml&quot;).await?;
    let reader = BufReader::new(file);
    let mut st = LineStream::new(reader);
    while let Some(Ok(line)) = st.next().await {
        println!(&quot;Got: {}&quot;, line);
    }

    Ok(())
}
</code></pre>
<p>这段代码封装了 <a href="https://docs.rs/tokio/1.14.0/tokio/io/struct.Lines.html">Lines</a> 结构，我们可以通过 <a href="https://docs.rs/tokio/1.14.0/tokio/io/trait.AsyncBufReadExt.html#">AsyncBufReadExt</a> 的 <a href="https://docs.rs/tokio/1.14.0/tokio/io/trait.AsyncBufReadExt.html#method.lines">lines()</a> 方法，把一个实现了 <a href="https://docs.rs/tokio/1.14.0/tokio/io/trait.AsyncBufRead.html">AsyncBufRead</a> trait 的 reader 转换成 Lines。</p>
<p>你也许注意到代码中引入的 <a href="https://docs.rs/pin-project">pin_project</a> 库，它提供了一些便利的宏，方便我们操作数据结构里需要被 pin 住的字段。在数据结构中，<strong>可以使用 #[pin] 来声明某个字段在使用的时候需要被封装为 Pin<T></strong>。这样，调用时，我们就可以使用 self.project().lines 得到一个 Pin&lt;&amp;mut Lines&gt;，以便调用其 <a href="https://docs.rs/tokio/1.14.0/tokio/io/struct.Lines.html#method.poll_next_line">poll_next_line()</a> 方法（这个方法的第一个参数是 Pin&lt;&amp;mut Self&gt;）。</p>
<p>在Lines这个结构内部，异步的 <a href="https://docs.rs/tokio/1.14.0/tokio/io/struct.Lines.html#method.next_line">next_line()</a> 方法可以读取下一行，它实际上就是比较低阶的 <a href="https://docs.rs/tokio/1.14.0/src/tokio/io/util/lines.rs.html#112-134">poll_next_line()</a> 接口的一个封装。</p>
<p><strong>虽然 Lines 结构提供了 next_line()，但并没有实现 Stream</strong>，所以我们无法像其他 Stream 那样统一用 next() 方法获取下一行。于是，我们将其包裹在自己的 LineStream 下，并且为 LineStream 实现了 Stream 方法。</p>
<p>注意，由于 poll_next_line() 的结果是 Result&lt;Option<T>&gt;，而 Stream 的 poll_next() 的结果是 Option&lt;Result<T>&gt;，所以我们需要使用 Result 方法的 <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose">transpose</a> 来将二者对调。这个transpose 方法是一个很基础的方法，非常实用。</p>
<h2>异步 IO 接口</h2>
<p>在实现 LineStream 时，我们遇到了两个异步 I/O 接口：AsyncRead 以及 AsyncBufRead。回到开头的那张表，相信你现在已经有大致答案了吧：<strong>所有同步的 Read/Write/Seek trait，前面加一个 Async，就构成了对应的异步 IO 接口</strong>。</p>
<p>不过，和 Stream 不同的是，如果你对比 futures 下定义的 IO trait 以及 tokio 下定义的 IO trait，会发现它们都有各自的定义，双方并未统一，有些许的差别：</p>
<p><img src="assets/da47e6ae335b4c46719afc64b5a60e28.jpg" alt="图片" /></p>
<p>比如 futures 下 <a href="https://docs.rs/futures/0.3.17/futures/io/trait.AsyncRead.html">AsyncRead</a> 的定义：</p>
<pre><code>pub trait AsyncRead {
    fn poll_read(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;, 
        buf: &amp;mut [u8]
    ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;;

    unsafe fn initializer(&amp;self) -&gt; Initializer { ... }
    fn poll_read_vectored(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;, 
        bufs: &amp;mut [IoSliceMut&lt;'_&gt;]
    ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt; { ... }
}
</code></pre>
<p>而 tokio 下 <a href="https://docs.rs/tokio/1.14.0/tokio/io/trait.AsyncRead.html">AsyncRead</a> 的定义：</p>
<pre><code>pub trait AsyncRead {
    fn poll_read(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;, 
        buf: &amp;mut ReadBuf&lt;'_&gt;
    ) -&gt; Poll&lt;Result&lt;()&gt;&gt;;
}
</code></pre>
<p>我们看不同之处：tokio 的 poll_read() 方法需要 <a href="https://docs.rs/tokio/1.14.0/src/tokio/io/read_buf.rs.html#27-31">ReadBuf</a>，而 futures 的 poll_read() 方法需要 &amp;mut [u8]。此外，futures 的 AsyncRead 还多了两个缺省方法。</p>
<p>再看 AsyncWrite。futures 下的 <a href="https://docs.rs/futures/0.3.17/futures/io/trait.AsyncWrite.html">AsyncWrite</a> 接口如下：</p>
<pre><code>pub trait AsyncWrite {
    fn poll_write(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;, 
        buf: &amp;[u8]
    ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;;
    fn poll_flush(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt;;
    fn poll_close(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt;;

    fn poll_write_vectored(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;, 
        bufs: &amp;[IoSlice&lt;'_&gt;]
    ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt; { ... }
}
</code></pre>
<p>而 tokio 下的 <a href="https://docs.rs/tokio/1.14.0/tokio/io/trait.AsyncWrite.html">AsyncWrite</a> 的定义：</p>
<pre><code>pub trait AsyncWrite {
    fn poll_write(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;, 
        buf: &amp;[u8]
    ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;;
    fn poll_flush(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt;;
    fn poll_shutdown(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt;;

    fn poll_write_vectored(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;, 
        bufs: &amp;[IoSlice&lt;'_&gt;]
    ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt; { ... }
    fn is_write_vectored(&amp;self) -&gt; bool { ... }
}
</code></pre>
<p>可以看到，AsyncWrite 二者的差距就只有 poll_close() 和 poll_shutdown() 命名上的分别。其它的异步 IO 接口我就不一一举例了，你可以自己去看代码对比。</p>
<h3>异步 IO 接口的兼容性处理</h3>
<p>为什么 Rust 的异步 IO trait 会有这样的分裂？这是因为在 tokio/futures 库实现的早期，社区还没有形成比较统一的异步 IO trait，不同的接口背后也有各自不同的考虑，这种分裂就沿袭下来。</p>
<p>所以，如果我们使用 tokio 进行异步开发，那么，代码需要使用 tokio::io 下的异步 IO trait。也许，未来等 Async IO trait 稳定并进入标准库后，tokio 会更新自己的 trait。</p>
<p>虽然 Rust 的异步 IO trait 有这样的分裂，你也不必过分担心。<strong>tokio-util 提供了相应的</strong><a href="https://docs.rs/tokio-util/0.6.9/tokio_util/compat/index.html">Compat</a><strong>功能，可以让你的数据结构在二者之间自如切换</strong>。看一个使用 <a href="https://docs.rs/yamux">yamux</a> 做多路复用的例子，重点位置详细注释了：</p>
<pre><code>use anyhow::Result;
use futures::prelude::*;
use tokio::net::TcpListener;
use tokio_util::{
    codec::{Framed, LinesCodec},
    compat::{FuturesAsyncReadCompatExt, TokioAsyncReadCompatExt},
};
use tracing::info;
use yamux::{Config, Connection, Mode, WindowUpdateMode};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();
    let addr = &quot;0.0.0.0:8080&quot;;
    let listener = TcpListener::bind(addr).await?;
    info!(&quot;Listening on: {:?}&quot;, addr);
    loop {
        let (stream, addr) = listener.accept().await?;
        info!(&quot;Accepted: {:?}&quot;, addr);
        let mut config = Config::default();
        config.set_window_update_mode(WindowUpdateMode::OnRead);
        // 使用 compat() 方法把 tokio AsyncRead/AsyncWrite 转换成 futures 对应的 trait
        let conn = Connection::new(stream.compat(), config, Mode::Server);
        // Yamux ctrl stream 可以用来打开新的 stream
        let _ctrl = conn.control();
        tokio::spawn(
            yamux::into_stream(conn).try_for_each_concurrent(None, move |s| async move {
                // 使用 compat() 方法把 futures AsyncRead/AsyncWrite 转换成 tokio 对应的 trait
                let mut framed = Framed::new(s.compat(), LinesCodec::new());
                while let Some(Ok(line)) = framed.next().await {
                    println!(&quot;Got: {}&quot;, line);
                    framed
                        .send(format!(&quot;Hello! I got '{}'&quot;, line))
                        .await
                        .unwrap();
                }

                Ok(())
            }),
        );
    }
}
</code></pre>
<p>yamux 是一个类似 HTTP/2 内部多路复用机制的协议，可以让你在一个 TCP 连接上打开多个逻辑 yamux stream，而yamux stream 之间并行工作，互不干扰。</p>
<p>yamux crate 在实现的时候，使用了 futures 下的异步 IO 接口。但是当我们使用 tokio Listener 接受一个客户端，得到对应的 TcpStream 时，这个 TcpStream 使用的是 tokio 下的异步 IO 接口。所以我们需要 tokio_util::compat 来协助接口的兼容。</p>
<p>在代码中，首先我用 stream.compat() 生成一个 Compat 结构，供 yamux Connection 使用：</p>
<pre><code>let conn = Connection::new(stream.compat(), config, Mode::Server);
</code></pre>
<p>之后，拿到 yamux connection 下所有 stream 进行处理时，我们想用 tokio 的 Frame 和 Codec 一行行读取和写入，也就需要把使用 futures 异步接口的 yamux stream，转换成使用 tokio 接口的数据结构，这样就可以用在 Framed::new() 中：</p>
<pre><code>let mut framed = Framed::new(s.compat(), LinesCodec::new());
</code></pre>
<p>如果你想运行这段代码，可以看这门课的 <a href="https://github.com/tyrchen/geektime-rust">GitHub repo</a> 下的完整版，包括依赖以及客户端的代码。</p>
<h3>实现异步 IO 接口</h3>
<p>异步 IO 主要应用在文件处理、网络处理等场合，而这些场合的数据结构都已经实现了对应的接口，比如 File 或者 TcpStream，它们也已经实现了 AsyncRead/AsyncWrite。所以基本上，我们不用自己实现异步 IO 接口，只需要会用就可以了。</p>
<p>不过有些情况，我们可能会把已有的数据结构封装在自己的数据结构中，此时，也应该实现相应的异步 IO 接口（<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b53409b4ad26aaf078d4799bfe95f65c">代码</a>）：</p>
<pre><code>use anyhow::Result;
use pin_project::pin_project;
use std::{
    pin::Pin,
    task::{Context, Poll},
};
use tokio::{
    fs::File,
    io::{AsyncRead, AsyncReadExt, ReadBuf},
};

#[pin_project]
struct FileWrapper {
    #[pin]
    file: File,
}

impl FileWrapper {
    pub async fn try_new(name: &amp;str) -&gt; Result&lt;Self&gt; {
        let file = File::open(name).await?;
        Ok(Self { file })
    }
}

impl AsyncRead for FileWrapper {
    fn poll_read(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut Context&lt;'_&gt;,
        buf: &amp;mut ReadBuf&lt;'_&gt;,
    ) -&gt; Poll&lt;std::io::Result&lt;()&gt;&gt; {
        self.project().file.poll_read(cx, buf)
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let mut file = FileWrapper::try_new(&quot;./Cargo.toml&quot;).await?;
    let mut buffer = String::new();
    file.read_to_string(&amp;mut buffer).await?;
    println!(&quot;{}&quot;, buffer);
    Ok(())
}
</code></pre>
<p>这段代码封装了 tokio::fs::File 结构，我们想读取内部的 file 字段，但又不想把 File 暴露出来，因此实现了 AsyncRead trait。</p>
<h2>Sink trait</h2>
<p>在同步环境下往 IO 中发送连续的数据，可以一次性发送，也可以使用 Write trait 多次发送，使用起来并没有什么麻烦；但在异步 IO 下，做同样的事情，我们需要更方便的接口。因此异步IO还有一个比较独特的 Sink trait，它是一个用于发送一系列异步值的接口。</p>
<p>看 Sink trait 的定义：</p>
<pre><code>pub trait Sink&lt;Item&gt; {
    type Error;
    fn poll_ready(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt;;
    fn start_send(self: Pin&lt;&amp;mut Self&gt;, item: Item) -&gt; Result&lt;(), Self::Error&gt;;
    fn poll_flush(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt;;
    fn poll_close(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt;;
}

pub trait SinkExt&lt;Item&gt;: Sink&lt;Item&gt; {
    ...
    fn send(&amp;mut self, item: Item) -&gt; Send&lt;'_, Self, Item&gt; where Self: Unpin { ... }
    ...
}
</code></pre>
<p>和 Stream trait 不同的是，Sink trait 的 Item 是 trait 的泛型参数，而不是关联类型。<strong>一般而言，当 trait 接受某个 input，应该使用泛型参数，比如 Add<Rhs>；当它输出某个 output，那么应该使用关联类型，比如 Future、Stream、Iterator 等</strong>。</p>
<p>Item 对于 Sink 来说是输入，所以使用泛型参数是正确的选择。因为这也意味着，在发送端，可以发送不同类型的数据结构。</p>
<p>看上面的定义源码，Sink trait 有四个方法：</p>
<ul>
<li>poll_ready()：用来准备 Sink 使其可以发送数据。只有 poll_ready() 返回 Poll::Ready(Ok(())) 后，Sink 才会开展后续的动作。poll_ready() 可以用来控制背压。</li>
<li>start_send()：开始发送数据到 Sink。但是start_send() 并不保证数据被发送完毕，所以调用者要调用 poll_flush() 或者 poll_close() 来保证完整发送。</li>
<li>poll_flush()：将任何尚未发送的数据 flush 到这个 Sink。</li>
<li>poll_close()：将任何尚未发送的数据 flush 到这个 Sink，并关闭这个 Sink。</li>
</ul>
<p>其中三个方法和 Item 是无关的，这会导致，如果不同的输入类型有多个实现，Sink的poll_ready、poll_flush 和 poll_close 可能会有重复的代码。所以一般我们在使用 Sink 时，如果确实需要处理不同的数据类型，可以用 enum 将它们统一（感兴趣的话，可以进一步阅读这个<a href="https://github.com/rust-lang/futures-rs/issues/623">讨论</a>）。</p>
<p>我们就用一个简单的 FileSink 的例子，看看如何实现这些方法。tokio::fs 下的 File 结构已经实现了 AsyncRead/AsyncWrite，我们只需要在 Sink 的几个方法中调用 AsyncWrite 的方法即可（<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b3aab166023b7478ccd947703f8f53cd">代码</a>）：</p>
<pre><code>use anyhow::Result;
use bytes::{BufMut, BytesMut};
use futures::{Sink, SinkExt};
use pin_project::pin_project;
use std::{
    pin::Pin,
    task::{Context, Poll},
};
use tokio::{fs::File, io::AsyncWrite};

#[pin_project]
struct FileSink {
    #[pin]
    file: File,
    buf: BytesMut,
}

impl FileSink {
    pub fn new(file: File) -&gt; Self {
        Self {
            file,
            buf: BytesMut::new(),
        }
    }
}

impl Sink&lt;&amp;str&gt; for FileSink {
    type Error = std::io::Error;

    fn poll_ready(self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        Poll::Ready(Ok(()))
    }

    fn start_send(self: Pin&lt;&amp;mut Self&gt;, item: &amp;str) -&gt; Result&lt;(), Self::Error&gt; {
        let this = self.project();
        eprint!(&quot;{}&quot;, item);
        this.buf.put(item.as_bytes());
        Ok(())
    }

    fn poll_flush(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        // 如果想 project() 多次，需要先把 self reborrow 一下
        let this = self.as_mut().project();
        let buf = this.buf.split_to(this.buf.len());
        if buf.is_empty() {
            return Poll::Ready(Ok(()));
        }

        // 写入文件
        if let Err(e) = futures::ready!(this.file.poll_write(cx, &amp;buf[..])) {
            return Poll::Ready(Err(e));
        }
        // 刷新文件
        self.project().file.poll_flush(cx)
    }

    fn poll_close(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        let this = self.project();
        // 结束写入
        this.file.poll_shutdown(cx)
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let file_sink = FileSink::new(File::create(&quot;/tmp/hello&quot;).await?);
    // pin_mut 可以把变量 pin 住
    futures::pin_mut!(file_sink);
    file_sink.send(&quot;hello\\n&quot;).await?;
    file_sink.send(&quot;world!\\n&quot;).await?;
    file_sink.send(&quot;Tyr!\\n&quot;).await?;

    Ok(())
}
</code></pre>
<p>对于 poll_ready() 方法，直接返回 Poll::Ready(Ok(()))。</p>
<p>在 start_send() 方法中，我们把传入的 item，写入 FileSink 的 BytesMut 中。然后在 poll_flush() 时，我们拿到 buf，把已有的内容调用 <a href="https://docs.rs/bytes/1.1.0/bytes/struct.BytesMut.html#method.split_to">split_to()</a>，得到一个包含所有未写入文件的新 buffer。这个 buffer 和 self 无关，所以传入 poll_write() 时，不会有对 self 的引用问题。</p>
<p>在写入文件后，我们再次调用 poll_flush() ，确保写入的内容刷新到磁盘上。最后，在 poll_close() 时调用 poll_shutdown() 关闭文件。</p>
<p>这段代码虽然实现了 Sink trait，也展示了如何实现 Sink 的几个方法，但是这么简单的一个问题，处理起来还是颇为费劲。有没有更简单的方法呢？</p>
<p>有的。futures 里提供了 sink::unfold 方法，类似 stream::unfold，我们来重写上面的 File Sink 的例子（<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=2582cfe2473f615b4e2f021893d738a3">代码</a>）：</p>
<pre><code>use anyhow::Result;
use futures::prelude::*;
use tokio::{fs::File, io::AsyncWriteExt};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let file_sink = writer(File::create(&quot;/tmp/hello&quot;).await?);
    // pin_mut 可以把变量 pin 住
    futures::pin_mut!(file_sink);
    if let Err(_) = file_sink.send(&quot;hello\\n&quot;).await {
        println!(&quot;Error on send&quot;);
    }
    if let Err(_) = file_sink.send(&quot;world!\\n&quot;).await {
        println!(&quot;Error on send&quot;);
    }
    Ok(())
}

/// 使用 unfold 生成一个 Sink 数据结构
fn writer&lt;'a&gt;(file: File) -&gt; impl Sink&lt;&amp;'a str&gt; {
    sink::unfold(file, |mut file, line: &amp;'a str| async move {
        file.write_all(line.as_bytes()).await?;
        eprint!(&quot;Received: {}&quot;, line);
        Ok::&lt;_, std::io::Error&gt;(file)
    })
}
</code></pre>
<p>可以看到，通过 unfold 方法，我们不需要撰写 Sink 的几个方法了，而且可以在一个返回 Future 的闭包中来提供处理逻辑，这就意味着我们可以不使用 poll_xxx 这样的方法，直接在闭包中使用这样的异步函数：</p>
<pre><code>file.write_all(line.as_bytes()).await?
</code></pre>
<p>你看，短短 5 行代码，就实现了刚才五十多行代码要表达的逻辑。</p>
<h2>小结</h2>
<p>今天我们学习了和异步 IO 相关的 Stream/Sink trait，以及和异步读写相关的 AsyncRead/AsyncWrite 等 trait。在学习异步 IO 时，很多内容都可以和同步 IO 的处理对比着学，这样事半功倍。</p>
<p><img src="assets/da47e6ae335b4c46719afc64b5a60e28.jpg" alt="图片" /></p>
<p>在处理异步 IO 时，底层的 poll_xxx() 函数很难写，因为它的约束很多。好在有 pin_project 这个项目，用宏帮我们解决了很多关于 Pin/Unpin 的问题。</p>
<p>一般情况下，我们不太需要直接实现 Stream/Sink/AsyncRead/AsyncWrite trait，如果的确需要，先看看有没有可以使用的辅助函数，比如通过 poll_fn/unfold 创建 Stream、通过 unfold 创建 Sink。</p>
<h3>思考题</h3>
<p>我们知道 tokio:sync::mpsc 下有支持异步的 MPSC channel，生产者可以通过 send() 发送消息，消费者可以通过 recv() 来接收消息。你能不能为其封装 Sink 和 Stream 的实现，让 MPSC channel 可以像 Stream/Sink 一样使用？（提示：tokio-stream 有 ReceiverStream 的实现）。</p>
<p>欢迎在留言区分享你的思考和学习收获，感谢收听，恭喜你已经完成了rust学习的40次打卡，如果觉得有收获，也欢迎分享给你身边的朋友，邀他一起讨论。我们下节课见。</p>
</div>
                        </div>
                        <div>
                            <div style="float: left">
                                <a href="39%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9Aasync_await%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.md.html">上一页</a>
                            </div>
                            <div style="float: right">
                                <a href="41%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%886%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.md.html">下一页</a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="copyright"><p>© 2019 - 2023 <a href="../../cdn-cgi/l/email-protection.html#bdd1d1d184898c8c8d8afddad0dcd4d193ded2d0" target="_blank">Liangliang Lee</a>. Powered by <a href="https://vertx.io/" target="_blank">Vert.x</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p></div>
        </div>

        <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
    </div>
<script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script defer src="https://static.cloudflareinsights.com/beacon.min.js/vb26e4fa9e5134444860be286fd8771851679335129114" integrity="sha512-M3hN/6cva/SjwrOtyXeUa5IuCT0sedyfT+jK/OV+s+D0RnzrTfwjwJHhd+wYfMm9HJSrZ1IKksOdddLuN6KOzw==" data-cf-beacon='{"rayId":"7af4abd43fedce54","version":"2023.3.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }

    hljs.initHighlightingOnLoad()

</script>

</html>
