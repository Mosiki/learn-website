<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>09 所有权：一个值可以有多个所有者么？.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <link rel="stylesheet"
              href="../../static/highlight.min.css">
        <script src="../../static/highlight.min.js"></script>
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5295275829820252"
                crossorigin="anonymous"></script>
        <script async defer data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" src="https://analyze.lianglianglee.com/umami.js"></script>
    </head>

<body>

    <div class="book-container">
        <div class="book-sidebar">
            <div class="book-brand">
                <a href="../../index.html">
                    <img src="../../static/favicon.png">
                    <span>技术文章摘抄</span>
                </a>
            </div>
            <div class="book-menu uncollapsible">
                <ul class="uncollapsible">
                    <li><a href="../../index.html" class="current-tab">首页</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li><a href="../index.html">上一级</a></li>
                </ul>

                <ul class="uncollapsible">
                    <li>

                        
                        <a href="00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%E8%AE%A9Rust%E6%88%90%E4%B8%BA%E4%BD%A0%E7%9A%84%E4%B8%8B%E4%B8%80%E9%97%A8%E4%B8%BB%E5%8A%9B%E8%AF%AD%E8%A8%80.md.html">00 开篇词 让Rust成为你的下一门主力语言.md</a>

                    </li>
                    <li>

                        
                        <a href="01%20%E5%86%85%E5%AD%98%EF%BC%9A%E5%80%BC%E6%94%BE%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%94%BE%E6%A0%88%E4%B8%8A%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98.md.html">01 内存：值放堆上还是放栈上，这是一个问题.md</a>

                    </li>
                    <li>

                        
                        <a href="02%20%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E9%82%A3%E4%BA%9B%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.md.html">02 串讲：编程开发中，那些你需要掌握的基本概念.md</a>

                    </li>
                    <li>

                        
                        <a href="03%20%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%EF%BC%9A%E4%BB%8E%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AARust%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%A7%8B%EF%BC%81.md.html">03 初窥门径：从你的第一个Rust程序开始！.md</a>

                    </li>
                    <li>

                        
                        <a href="04%20get%20hands%20dirty%EF%BC%9A%E6%9D%A5%E5%86%99%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84CLI%E5%B0%8F%E5%B7%A5%E5%85%B7.md.html">04 get hands dirty：来写个实用的CLI小工具.md</a>

                    </li>
                    <li>

                        
                        <a href="05%20get%20hands%20dirty%EF%BC%9A%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E5%A4%9A%E9%9A%BE%EF%BC%9F.md.html">05 get hands dirty：做一个图片服务器有多难？.md</a>

                    </li>
                    <li>

                        
                        <a href="06%20get%20hands%20dirty%EF%BC%9ASQL%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7%E6%80%8E%E4%B9%88%E4%B8%80%E9%B1%BC%E5%A4%9A%E5%90%83%EF%BC%9F.md.html">06 get hands dirty：SQL查询工具怎么一鱼多吃？.md</a>

                    </li>
                    <li>

                        
                        <a href="07%20%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%81%E6%89%8B%E4%B8%8A%EF%BC%9F.md.html">07 所有权：值的生杀大权到底在谁手上？.md</a>

                    </li>
                    <li>

                        
                        <a href="08%20%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E5%80%9F%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F.md.html">08 所有权：值的借用是如何工作的？.md</a>

                    </li>
                    <li>

                        <a class="current-tab" href="09%20%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F.md.html">09 所有权：一个值可以有多个所有者么？.md</a>
                        

                    </li>
                    <li>

                        
                        <a href="10%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E4%BD%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%80%BC%E7%A9%B6%E7%AB%9F%E8%83%BD%E6%B4%BB%E5%A4%9A%E4%B9%85%EF%BC%9F.md.html">10 生命周期：你创建的值究竟能活多久？.md</a>

                    </li>
                    <li>

                        
                        <a href="11%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.md.html">11 内存管理：从创建到消亡，值都经历了什么？.md</a>

                    </li>
                    <li>

                        
                        <a href="12%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F.md.html">12 类型系统：Rust的类型系统有什么特点？.md</a>

                    </li>
                    <li>

                        
                        <a href="13%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8trait%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F.md.html">13 类型系统：如何使用trait来定义接口？.md</a>

                    </li>
                    <li>

                        
                        <a href="14%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84trait%EF%BC%9F.md.html">14 类型系统：有哪些必须掌握的trait？.md</a>

                    </li>
                    <li>

                        
                        <a href="15%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%99%E4%BA%9B%E6%B5%93%E7%9C%89%E5%A4%A7%E7%9C%BC%E7%9A%84%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E9%83%BD%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F.md.html">15 数据结构：这些浓眉大眼的结构竟然都是智能指针？.md</a>

                    </li>
                    <li>

                        
                        <a href="16%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVec_T_%E3%80%81&amp;%5BT%5D%E3%80%81Box_%5BT%5D_%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F.md.html">16 数据结构：Vec_T_、&amp;[T]、Box_[T]_ ，你真的了解集合容器么？.md</a>

                    </li>
                    <li>

                        
                        <a href="17%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F.md.html">17 数据结构：软件系统核心部件哈希表，内存如何布局？.md</a>

                    </li>
                    <li>

                        
                        <a href="18%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Rust%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%EF%BC%9F.md.html">18 错误处理：为什么Rust的错误处理与众不同？.md</a>

                    </li>
                    <li>

                        
                        <a href="19%20%E9%97%AD%E5%8C%85%EF%BC%9AFnOnce%E3%80%81FnMut%E5%92%8CFn%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E7%B1%BB%E5%9E%8B%EF%BC%9F.md.html">19 闭包：FnOnce、FnMut和Fn，为什么有这么多类型？.md</a>

                    </li>
                    <li>

                        
                        <a href="20%204%20Steps%20%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E9%98%85%E8%AF%BBRust%E6%BA%90%E7%A0%81%EF%BC%9F.md.html">20 4 Steps ：如何更好地阅读Rust源码？.md</a>

                    </li>
                    <li>

                        
                        <a href="21%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%881%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.md.html">21 阶段实操（1）：构建一个简单的KV server-基本流程.md</a>

                    </li>
                    <li>

                        
                        <a href="22%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%882%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.md.html">22 阶段实操（2）：构建一个简单的KV server-基本流程.md</a>

                    </li>
                    <li>

                        
                        <a href="23%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%9F.md.html">23 类型系统：如何在实战中使用泛型编程？.md</a>

                    </li>
                    <li>

                        
                        <a href="24%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E4%BD%BF%E7%94%A8trait%20object%EF%BC%9F.md.html">24 类型系统：如何在实战中使用trait object？.md</a>

                    </li>
                    <li>

                        
                        <a href="25%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9B%B4%E7%BB%95trait%E6%9D%A5%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%9E%B6%E6%9E%84%E7%B3%BB%E7%BB%9F%EF%BC%9F.md.html">25 类型系统：如何围绕trait来设计和架构系统？.md</a>

                    </li>
                    <li>

                        
                        <a href="26%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%883%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E9%AB%98%E7%BA%A7trait%E6%8A%80%E5%B7%A7.md.html">26 阶段实操（3）：构建一个简单的KV server-高级trait技巧.md</a>

                    </li>
                    <li>

                        
                        <a href="27%20%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E6%9C%89%E7%9A%84Rust%E5%BA%93%E5%8F%AF%E4%BB%A5%E4%B8%BA%E6%88%91%E6%89%80%E7%94%A8%EF%BC%9F.md.html">27 生态系统：有哪些常有的Rust库可以为我所用？.md</a>

                    </li>
                    <li>

                        
                        <a href="28%20%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rust%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%9F.md.html">28 网络开发（上）：如何使用Rust处理网络请求？.md</a>

                    </li>
                    <li>

                        
                        <a href="29%20%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rust%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%9F.md.html">29 网络开发（下）：如何使用Rust处理网络请求？.md</a>

                    </li>
                    <li>

                        
                        <a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%99%88%E5%A4%A9%20%C2%B7%20Rust%20%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/30%20Unsafe%20Rust%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8C++%E7%9A%84%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80Rust%EF%BC%9F.md">30 Unsafe Rust：如何用C++的方式打开Rust？.md</a>

                    </li>
                    <li>

                        
                        <a href="31%20FFI%EF%BC%9ARust%E5%A6%82%E4%BD%95%E5%92%8C%E4%BD%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E6%9E%B6%E8%B5%B7%E6%B2%9F%E9%80%9A%E6%A1%A5%E6%A2%81%EF%BC%9F.md.html">31 FFI：Rust如何和你的语言架起沟通桥梁？.md</a>

                    </li>
                    <li>

                        
                        <a href="32%20%E5%AE%9E%E6%93%8D%E9%A1%B9%E7%9B%AE%EF%BC%9A%E4%BD%BF%E7%94%A8PyO3%E5%BC%80%E5%8F%91Python3%E6%A8%A1%E5%9D%97.md.html">32 实操项目：使用PyO3开发Python3模块.md</a>

                    </li>
                    <li>

                        
                        <a href="33%20%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BB%8Eatomics%E5%88%B0Channel%EF%BC%8CRust%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%EF%BC%9F.md.html">33 并发处理（上）：从atomics到Channel，Rust都提供了什么工具？.md</a>

                    </li>
                    <li>

                        
                        <a href="34%20%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%BB%8Eatomics%E5%88%B0Channel%EF%BC%8CRust%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%EF%BC%9F.md.html">34 并发处理（下）：从atomics到Channel，Rust都提供了什么工具？.md</a>

                    </li>
                    <li>

                        
                        <a href="35%20%E5%AE%9E%E6%93%8D%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84MPSC%20channel%EF%BC%9F.md.html">35 实操项目：如何实现一个基本的MPSC channel？.md</a>

                    </li>
                    <li>

                        
                        <a href="36%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%884%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86.md.html">36 阶段实操（4）：构建一个简单的KV server-网络处理.md</a>

                    </li>
                    <li>

                        
                        <a href="37%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%885%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.md.html">37 阶段实操（5）：构建一个简单的KV server-网络安全.md</a>

                    </li>
                    <li>

                        
                        <a href="38%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9AFuture%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E5%92%8Casync_await%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F.md.html">38 异步处理：Future是什么？它和async_await是什么关系？.md</a>

                    </li>
                    <li>

                        
                        <a href="39%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9Aasync_await%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.md.html">39 异步处理：async_await内部是怎么实现的？.md</a>

                    </li>
                    <li>

                        
                        <a href="40%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5IO%EF%BC%9F.md.html">40 异步处理：如何处理异步IO？.md</a>

                    </li>
                    <li>

                        
                        <a href="41%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%886%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.md.html">41 阶段实操（6）：构建一个简单的KV server-异步处理.md</a>

                    </li>
                    <li>

                        
                        <a href="42%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%887%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A4%A7%E7%9A%84%E9%87%8D%E6%9E%84%EF%BC%9F.md.html">42 阶段实操（7）：构建一个简单的KV server-如何做大的重构？.md</a>

                    </li>
                    <li>

                        
                        <a href="43%20%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%EF%BC%9A%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E4%B8%8B%E7%9A%84%E4%B8%80%E4%B8%AARust%E9%A1%B9%E7%9B%AE%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E8%A6%81%E7%B4%A0%EF%BC%9F.md.html">43 生产环境：真实世界下的一个Rust项目包含哪些要素？.md</a>

                    </li>
                    <li>

                        
                        <a href="44%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%89%93%E4%BA%A4%E9%81%93%EF%BC%9F.md.html">44 数据处理：应用程序和数据如何打交道？.md</a>

                    </li>
                    <li>

                        
                        <a href="45%20%E9%98%B6%E6%AE%B5%E5%AE%9E%E6%93%8D%EF%BC%888%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84KV%20server-%E9%85%8D%E7%BD%AE_%E6%B5%8B%E8%AF%95_%E7%9B%91%E6%8E%A7_CI_CD.md.html">45 阶段实操（8）：构建一个简单的KV server-配置_测试_监控_CI_CD.md</a>

                    </li>
                    <li>

                        
                        <a href="46%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8Rust%E6%9E%B6%E6%9E%84%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F%EF%BC%9F.md.html">46 软件架构：如何用Rust架构复杂系统？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20Rust2021%E7%89%88%E6%AC%A1%E9%97%AE%E4%B8%96%E4%BA%86%EF%BC%81.md.html">加餐 Rust2021版次问世了！.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E4%BB%A3%E7%A0%81%E5%8D%B3%E6%95%B0%E6%8D%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%AE%8F%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%EF%BC%9F.md.html">加餐 代码即数据：为什么我们需要宏编程能力？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E5%AE%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E7%94%A8%E6%9C%80%E2%80%9C%E7%AC%A8%E2%80%9D%E7%9A%84%E6%96%B9%E5%BC%8F%E6%92%B0%E5%86%99%E5%AE%8F.md.html">加餐 宏编程（上）：用最“笨”的方式撰写宏.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E5%AE%8F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%94%A8%20syn_quote%20%E4%BC%98%E9%9B%85%E5%9C%B0%E6%9E%84%E5%BB%BA%E5%AE%8F.md.html">加餐 宏编程（下）：用 syn_quote 优雅地构建宏.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E6%84%9A%E6%98%A7%E4%B9%8B%E5%B7%85%EF%BC%9A%E4%BD%A0%E7%9A%84Rust%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.md.html">加餐 愚昧之巅：你的Rust学习常见问题汇总.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E6%9C%9F%E4%B8%AD%E6%B5%8B%E8%AF%95%EF%BC%9A%E5%8F%82%E8%80%83%E5%AE%9E%E7%8E%B0%E8%AE%B2%E8%A7%A3.md.html">加餐 期中测试：参考实现讲解.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E6%9C%9F%E4%B8%AD%E6%B5%8B%E8%AF%95%EF%BC%9A%E6%9D%A5%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84grep%E5%91%BD%E4%BB%A4%E8%A1%8C.md.html">加餐 期中测试：来写一个简单的grep命令行.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%8A%A0%E9%A4%90%20%E8%BF%99%E4%B8%AA%E4%B8%93%E6%A0%8F%E4%BD%A0%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%AD%A6%EF%BC%8C%E4%BB%A5%E5%8F%8ARust%E6%98%AF%E5%90%A6%E5%80%BC%E5%BE%97%E5%AD%A6%EF%BC%9F.md.html">加餐 这个专栏你可以怎么学，以及Rust是否值得学？.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%A4%A7%E5%92%96%E5%8A%A9%E5%9C%BA%20%E5%BC%80%E6%82%9F%E4%B9%8B%E5%9D%A1%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9ARust%E7%9A%84%E7%8E%B0%E7%8A%B6%E3%80%81%E6%9C%BA%E9%81%87%E4%B8%8E%E6%8C%91%E6%88%98.md.html">大咖助场 开悟之坡（上）：Rust的现状、机遇与挑战.md</a>

                    </li>
                    <li>

                        
                        <a href="%E5%A4%A7%E5%92%96%E5%8A%A9%E5%9C%BA%20%E5%BC%80%E6%82%9F%E4%B9%8B%E5%9D%A1%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9ARust%E7%9A%84%E7%8E%B0%E7%8A%B6%E3%80%81%E6%9C%BA%E9%81%87%E4%B8%8E%E6%8C%91%E6%88%98.md.html">大咖助场 开悟之坡（下）：Rust的现状、机遇与挑战.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%89%B9%E5%88%AB%E7%AD%96%E5%88%92%20%E5%AD%A6%E4%B9%A0%E9%94%A6%E5%9B%8A%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%90%AC%E5%90%AC%E8%AF%BE%E4%BB%A3%E8%A1%A8%E4%BB%AC%E6%80%8E%E4%B9%88%E8%AF%B4.md.html">特别策划 学习锦囊（一）：听听课代表们怎么说.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%89%B9%E5%88%AB%E7%AD%96%E5%88%92%20%E5%AD%A6%E4%B9%A0%E9%94%A6%E5%9B%8A%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%AC%E5%90%AC%E8%AF%BE%E4%BB%A3%E8%A1%A8%E4%BB%AC%E6%80%8E%E4%B9%88%E8%AF%B4.md.html">特别策划 学习锦囊（三）：听听课代表们怎么说.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%89%B9%E5%88%AB%E7%AD%96%E5%88%92%20%E5%AD%A6%E4%B9%A0%E9%94%A6%E5%9B%8A%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%90%AC%E5%90%AC%E8%AF%BE%E4%BB%A3%E8%A1%A8%E4%BB%AC%E6%80%8E%E4%B9%88%E8%AF%B4.md.html">特别策划 学习锦囊（二）：听听课代表们怎么说.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%20%E7%BB%9D%E6%9C%9B%E4%B9%8B%E8%B0%B7%EF%BC%9A%E6%94%B9%E5%8F%98%E4%BB%8E%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%A7%8B.md.html">用户故事 绝望之谷：改变从学习开始.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%20%E8%AF%AD%E8%A8%80%E4%B8%8D%E4%BB%85%E6%98%AF%E5%B7%A5%E5%85%B7%EF%BC%8C%E8%BF%98%E6%98%AF%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F.md.html">用户故事 语言不仅是工具，还是思维方式.md</a>

                    </li>
                    <li>

                        
                        <a href="%E7%BB%93%E6%9D%9F%E8%AF%AD%20%E6%B0%B8%E7%BB%AD%E4%B9%8B%E5%8E%9F%EF%BC%9ARust%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8C%81%E7%BB%AD%E7%B2%BE%E8%BF%9B%EF%BC%9F.md.html">结束语 永续之原：Rust学习，如何持续精进？.md</a>

                    </li>
                </ul>

            </div>
        </div>

        <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
            <div class="sidebar-toggle-inner"></div>
        </div>

        <script>
            function add_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.add('show')
            }

            function remove_inner() {
                let inner = document.querySelector('.sidebar-toggle-inner')
                inner.classList.remove('show')
            }

            function sidebar_toggle() {
                let sidebar_toggle = document.querySelector('.sidebar-toggle')
                let sidebar = document.querySelector('.book-sidebar')
                let content = document.querySelector('.off-canvas-content')
                if (sidebar_toggle.classList.contains('extend')) { // show
                    sidebar_toggle.classList.remove('extend')
                    sidebar.classList.remove('hide')
                    content.classList.remove('extend')
                } else { // hide
                    sidebar_toggle.classList.add('extend')
                    sidebar.classList.add('hide')
                    content.classList.add('extend')
                }
            }


            function open_sidebar() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.add('show')
                overlay.classList.add('show')
            }
            function hide_canvas() {
                let sidebar = document.querySelector('.book-sidebar')
                let overlay = document.querySelector('.off-canvas-overlay')
                sidebar.classList.remove('show')
                overlay.classList.remove('show')
            }

        </script>

        <div class="off-canvas-content">
            <div class="columns">
                <div class="column col-12 col-lg-12">
                    <div class="book-navbar">
                        <!-- For Responsive Layout -->
                        <header class="navbar">
                            <section class="navbar-section">
                                <a onclick="open_sidebar()">
                                    <i class="icon icon-menu"></i>
                                </a>
                            </section>
                        </header>
                    </div>
                    <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                        <div class="book-post">
                            <p id="tip" align="center"></p>
                            <div><h1>09 所有权：一个值可以有多个所有者么？</h1>
<p>你好，我是陈天。</p>
<p>之前介绍的单一所有权规则，能满足我们大部分场景中分配和使用内存的需求，而且在编译时，通过 Rust 借用检查器就能完成静态检查，不会影响运行时效率。</p>
<p>但是，规则总会有例外，在日常工作中有些特殊情况该怎么处理呢？</p>
<ul>
<li>一个有向无环图（DAG）中，某个节点可能有两个以上的节点指向它，这个按照所有权模型怎么表述？</li>
<li>多个线程要访问同一块共享内存，怎么办？</li>
</ul>
<p>我们知道，这些问题在程序运行过程中才会遇到，在编译期，所有权的静态检查无法处理它们，所以为了更好的灵活性，Rust 提供了<strong>运行时的动态检查</strong>，来满足特殊场景下的需求。</p>
<p>这也是 Rust 处理很多问题的思路：编译时，处理大部分使用场景，保证安全性和效率；运行时，处理无法在编译时处理的场景，会牺牲一部分效率，提高灵活性。后续讲到静态分发和动态分发也会有体现，这个思路很值得我们借鉴。</p>
<p>那具体如何在运行时做动态检查呢？运行时的动态检查又如何与编译时的静态检查自洽呢？</p>
<p>Rust 的答案是使用引用计数的智能指针：<strong>Rc（Reference counter） 和 Arc（Atomic reference counter）</strong>。这里要特别说明一下，Arc 和 ObjC/Swift 里的 ARC（Automatic Reference Counting）不是一个意思，不过它们解决问题的手段类似，都是通过引用计数完成的。</p>
<h2>Rc</h2>
<p>我们先看 Rc。对某个数据结构 T，我们可以创建引用计数 Rc，使其有多个所有者。Rc 会把对应的数据结构创建在堆上，我们在第二讲谈到过，堆是唯一可以让动态创建的数据被到处使用的内存。</p>
<pre><code>use std::rc::Rc;
fn main() {    
  let a = Rc::new(1);
}
</code></pre>
<p>之后，如果想对数据创建更多的所有者，我们可以通过 clone() 来完成。</p>
<p><strong>对一个 Rc 结构进行 clone()，不会将其内部的数据复制，只会增加引用计数</strong>。而当一个 Rc 结构离开作用域被 drop() 时，也只会减少其引用计数，直到引用计数为零，才会真正清除对应的内存。</p>
<pre><code>use std::rc::Rc;
fn main() {
    let a = Rc::new(1);
    let b = a.clone();
    let c = a.clone();
}
</code></pre>
<p>上面的代码我们创建了三个 Rc，分别是 a、b 和 c。它们共同指向堆上相同的数据，也就是说，堆上的数据有了三个共享的所有者。在这段代码结束时，c 先 drop，引用计数变成 2，然后 b drop、a drop，引用计数归零，堆上内存被释放。<img src="assets/a3510f9b565577bc74bc0dcda0b3e78c.jpg" alt="图片" /></p>
<p>你也许会有疑问：为什么我们生成了对同一块内存的多个所有者，但是，编译器不抱怨所有权冲突呢？</p>
<p>仔细看这段代码：首先 a 是 Rc::new(1) 的所有者，这毋庸置疑；然后 b 和 c 都调用了 a.clone()，分别得到了一个新的 Rc，所以从编译器的角度，abc 都各自拥有一个 Rc。如果文字你觉得稍微有点绕，看看 Rc 的 clone() 函数的实现，就很清楚了（<a href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1433-1453">源代码</a>）：</p>
<pre><code>fn clone(&amp;self) -&gt; Rc&lt;T&gt; {
    // 增加引用计数
    self.inner().inc_strong();
    // 通过 self.ptr 生成一个新的 Rc 结构
    Self::from_inner(self.ptr)
}
</code></pre>
<p>所以，Rc 的 clone() 正如我们刚才说的，不复制实际的数据，只是一个引用计数的增加。</p>
<p>你可能继续会疑惑：Rc 是怎么产生在堆上的？并且为什么这段堆内存不受栈内存生命周期的控制呢？</p>
<h3>Box::leak()机制</h3>
<p>上一讲我们讲到，在所有权模型下，堆内存的生命周期，和创建它的栈内存的生命周期保持一致。所以 Rc 的实现似乎与此格格不入。的确，如果完全按照上一讲的单一所有权模型，Rust 是无法处理 Rc 这样的引用计数的。</p>
<p>Rust必须提供一种机制，让代码可以像 C/C++ 那样，<strong>创建不受栈内存控制的堆内存</strong>，从而绕过编译时的所有权规则。Rust 提供的方式是 Box::leak()。</p>
<p>Box 是 Rust 下的智能指针，它可以强制把任何数据结构创建在堆上，然后在栈上放一个指针指向这个数据结构，但此时堆内存的生命周期仍然是受控的，跟栈上的指针一致。我们后续讲到智能指针时会详细介绍 Box。</p>
<p>Box::leak()，顾名思义，它创建的对象，从堆内存上泄漏出去，不受栈内存控制，是一个自由的、生命周期可以大到和整个进程的生命周期一致的对象。<img src="assets/9f1a17dea75f9cae596a56f51d007ccd.jpg" alt="图片" /></p>
<p>所以我们相当于主动撕开了一个口子，允许内存泄漏。注意，在 C/C++ 下，其实你通过 malloc 分配的每一片堆内存，都类似 Rust 下的 Box::leak()。我很喜欢 Rust 这样的设计，它符合最小权限原则（<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">Principle of least privilege</a>），最大程度帮助开发者撰写安全的代码。</p>
<p><strong>有了 Box::leak()，我们就可以跳出 Rust 编译器的静态检查</strong>，保证 Rc 指向的堆内存，有最大的生命周期，然后我们再通过引用计数，在合适的时机，结束这段内存的生命周期。如果你对此感兴趣，可以看 <a href="https://doc.rust-lang.org/src/alloc/rc.rs.html#342-350">Rc::new() 的源码</a>。</p>
<p>插一句，在学习语言的过程中，不要因为觉得自己是个初学者，就不敢翻阅标准库的源码，相反，遇到不懂的地方，如果你去看对应的源码，得到的是第一手的知识，一旦搞明白，就会学得非常扎实，受益无穷。</p>
<p>搞明白了 Rc，我们就进一步理解 Rust 是如何进行所有权的静态检查和动态检查了：</p>
<ul>
<li>静态检查，靠编译器保证代码符合所有权规则；</li>
<li>动态检查，通过 Box::leak 让堆内存拥有不受限的生命周期，然后在运行过程中，通过对引用计数的检查，保证这样的堆内存最终会得到释放。</li>
</ul>
<h3>实现 DAG</h3>
<p>现在我们用 Rc 来实现之前无法实现的 DAG。</p>
<p>假设 Node 就只包含 id 和指向下游（downstream）的指针，因为 DAG 中的一个节点可能被多个其它节点指向，所以我们使用 <code>Rc&lt;Node&gt;</code> 来表述它；一个节点可能没有下游节点，所以我们用 <code>Option&lt;Rc&lt;Node&gt;&gt;</code> 来表述它。<img src="assets/0c5b0ff12963792a55baa43d3b3054ab.jpg" alt="图片" /></p>
<p>要建立这样一个 DAG，我们需要为 Node 提供以下方法：</p>
<ul>
<li>new()：建立一个新的 Node。</li>
<li>update_downstream()：设置 Node 的 downstream。</li>
<li>get_downstream()：clone 一份 Node 里的 downstream。</li>
</ul>
<p>有了这些方法，我们就可以创建出拥有上图关系的 DAG 了（<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=455a14b85949d11a3368019aec7b238b">代码1</a>）：</p>
<pre><code>use std::rc::Rc;

#[derive(Debug)]
struct Node {
    id: usize,
    downstream: Option&lt;Rc&lt;Node&gt;&gt;,
}

impl Node {
    pub fn new(id: usize) -&gt; Self {
        Self {
            id,
            downstream: None,
        }
    }

    pub fn update_downstream(&amp;mut self, downstream: Rc&lt;Node&gt;) {
        self.downstream = Some(downstream);
    }

    pub fn get_downstream(&amp;self) -&gt; Option&lt;Rc&lt;Node&gt;&gt; {
        self.downstream.as_ref().map(|v| v.clone())
    }
}

fn main() {
    let mut node1 = Node::new(1);
    let mut node2 = Node::new(2);
    let mut node3 = Node::new(3);
    let node4 = Node::new(4);
    node3.update_downstream(Rc::new(node4));

    node1.update_downstream(Rc::new(node3));
    node2.update_downstream(node1.get_downstream().unwrap());
    println!(&quot;node1: {:?}, node2: {:?}&quot;, node1, node2);
}
</code></pre>
<h2>RefCell</h2>
<p>在运行上述代码时，细心的你也许会疑惑：整个 DAG 在创建完成后还能修改么？</p>
<p>按最简单的写法，我们可以在上面的代码1的 <code>main()</code> 函数后，加入这段代码（<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5fc82318fefff9f736391aaac84fbf52">代码2</a>），来修改 Node3 使其指向一个新的节点 Node5：</p>
<pre><code>let node5 = Node::new(5);
let node3 = node1.get_downstream().unwrap();
node3.update_downstream(Rc::new(node5));

println!(&quot;node1: {:?}, node2: {:?}&quot;, node1, node2);
</code></pre>
<p>然而，它无法编译通过，编译器会告诉你“node3 cannot borrow as mutable”。</p>
<p>这是因为<strong>Rc 是一个只读的引用计数器</strong>，你无法拿到 Rc 结构内部数据的可变引用，来修改这个数据。这可怎么办？</p>
<p>这里，我们需要使用 RefCell。</p>
<p>和 Rc 类似，RefCell 也绕过了 Rust 编译器的静态检查，允许我们在运行时，对某个只读数据进行可变借用。这就涉及 Rust 另一个比较独特且有点难懂的概念：<a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">内部可变性（interior mutability）</a>。</p>
<h3>内部可变性</h3>
<p>有内部可变性，自然能联想到外部可变性，所以我们先看这个更简单的定义，对比着学。</p>
<p>当我们用 <code>let mut</code> 显式地声明一个可变的值，或者，用 <code>&amp;mut</code> 声明一个可变引用时，编译器可以在编译时进行严格地检查，保证只有可变的值或者可变的引用，才能修改值内部的数据，这被称作外部可变性（exterior mutability），外部可变性通过 <code>mut</code> 关键字声明。</p>
<p>然而，这样不够灵活，有时候我们希望能够绕开这个编译时的检查，对并未声明成 <code>mut</code> 的值或者引用，也想进行修改。也就是说，<strong>在编译器的眼里，值是只读的，但是在运行时，这个值可以得到可变借用，从而修改内部的数据</strong>，这就是 <code>RefCell</code> 的用武之地。</p>
<p>我们看一个简单的例子（<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=99c4faa2e3f3a976d3c61c3f82764e28">代码2</a>）：</p>
<pre><code>use std::cell::RefCell;

fn main() {
    let data = RefCell::new(1);
    {
        // 获得 RefCell 内部数据的可变借用
        let mut v = data.borrow_mut();
        *v += 1;
    }
    println!(&quot;data: {:?}&quot;, data.borrow());
}
</code></pre>
<p>在这个例子里，data 是一个 RefCell，其初始值为 1。可以看到，我们并未将 data 声明为可变变量。之后我们可以通过使用 RefCell 的 <code>borrow_mut()</code> 方法，来获得一个可变的内部引用，然后对它做加 1 的操作。最后，我们可以通过 RefCell 的 <code>borrow()</code> 方法，获得一个不可变的内部引用，因为加了 1，此时它的值为 2。</p>
<p>你也许奇怪，这里为什么要把获取和操作可变借用的两句代码，用花括号分装到一个作用域下？</p>
<p>因为根据所有权规则，在同一个作用域下，我们<strong>不能同时有活跃的可变借用和不可变借用</strong>。通过这对花括号，我们明确地缩小了可变借用的生命周期，不至于和后续的不可变借用冲突。</p>
<p>这里再想一步，如果没有这对花括号，这段代码是无法编译通过？还是运行时会出错（<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0af48f1237504aaadbe7da1f1853a838">代码3</a>）？</p>
<pre><code>use std::cell::RefCell;

fn main() {
    let data = RefCell::new(1);
    
    let mut v = data.borrow_mut();
    *v += 1;
    
    println!(&quot;data: {:?}&quot;, data.borrow());
}
</code></pre>
<p>如果你运行代码3，编译没有任何问题，但在运行到第 9 行时，会得到：“already mutably borrowed: BorrowError” 这样的错误。可以看到，所有权的借用规则在此依旧有效，只不过它在运行时检测。</p>
<p>这就是外部可变性和内部可变性的重要区别，我们用下表来总结一下：<img src="assets/94bd27a93210ea829482663c9138de3c.jpg" alt="" /></p>
<h3>实现可修改DAG</h3>
<p>好，现在我们对 RefCell 有一个直观的印象，看看如何使用它和 Rc 来让之前的 DAG 变得可修改。</p>
<p>首先数据结构的 downstream 需要 Rc 内部嵌套一个 RefCell，这样，就可以利用 RefCell 的内部可变性，来获得数据的可变借用了，同时 Rc 还允许值有多个所有者。<img src="assets/6264d51da5c5e9025abf28d7c0dd2e46.jpg" alt="图片" /></p>
<p>完整的代码我放到这里了（<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=abbb6881ed94a9881ed96ace779d3734">代码4</a>）：</p>
<pre><code>use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    id: usize,
    // 使用 Rc&lt;RefCell&lt;T&gt;&gt; 让节点可以被修改
    downstream: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

impl Node {
    pub fn new(id: usize) -&gt; Self {
        Self {
            id,
            downstream: None,
        }
    }

    pub fn update_downstream(&amp;mut self, downstream: Rc&lt;RefCell&lt;Node&gt;&gt;) {
        self.downstream = Some(downstream);
    }

    pub fn get_downstream(&amp;self) -&gt; Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt; {
        self.downstream.as_ref().map(|v| v.clone())
    }
}

fn main() {
    let mut node1 = Node::new(1);
    let mut node2 = Node::new(2);
    let mut node3 = Node::new(3);
    let node4 = Node::new(4);

    node3.update_downstream(Rc::new(RefCell::new(node4)));
    node1.update_downstream(Rc::new(RefCell::new(node3)));
    node2.update_downstream(node1.get_downstream().unwrap());
    println!(&quot;node1: {:?}, node2: {:?}&quot;, node1, node2);

    let node5 = Node::new(5);
    let node3 = node1.get_downstream().unwrap();
    // 获得可变引用，来修改 downstream
    node3.borrow_mut().downstream = Some(Rc::new(RefCell::new(node5)));

    println!(&quot;node1: {:?}, node2: {:?}&quot;, node1, node2);
}
</code></pre>
<p>可以看到，通过使用 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 这样的嵌套结构，我们的 DAG 也可以正常修改了。</p>
<h2>Arc 和 Mutex/RwLock</h2>
<p>我们用 Rc 和 RefCell 解决了 DAG 的问题，那么，开头提到的多个线程访问同一块内存的问题，是否也可以使用 Rc 来处理呢？</p>
<p>不行。因为 Rc 为了性能，使用的不是线程安全的引用计数器。因此，我们需要另一个引用计数的智能指针：Arc，它实现了线程安全的引用计数器。</p>
<p>Arc 内部的引用计数使用了 <a href="https://doc.rust-lang.org/src/alloc/sync.rs.html#303-312">Atomic Usize</a> ，而非普通的 usize。从名称上也可以感觉出来，Atomic Usize 是 usize 的原子类型，它使用了 CPU 的特殊指令，来保证多线程下的安全。如果你对原子类型感兴趣，可以看 <a href="https://doc.rust-lang.org/std/sync/atomic/index.html">std::sync::atomic 的文档</a>。</p>
<p>Rust 实现两套不同的引用计数数据结构，完全是为了性能考虑，从这里我们也可以感受到 Rust 对性能的极致渴求。<strong>如果不用跨线程访问，可以用效率非常高的 Rc；如果要跨线程访问，那么必须用 Arc</strong>。</p>
<p>同样的，RefCell 也不是线程安全的，如果我们要在多线程中，使用内部可变性，Rust 提供了 Mutex 和 RwLock。</p>
<p>这两个数据结构你应该都不陌生，Mutex是互斥量，获得互斥量的线程对数据独占访问，RwLock是读写锁，获得写锁的线程对数据独占访问，但当没有写锁的时候，允许有多个读锁。读写锁的规则和 Rust 的借用规则非常类似，我们可以类比着学。</p>
<p>Mutex 和 RwLock 都用在多线程环境下，对共享数据访问的保护上。刚才中我们构建的 DAG 如果要用在多线程环境下，需要把 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 替换为 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 或者 <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>。更多有关 Arc/Mutex/RwLock 的知识，我们会在并发篇详细介绍。</p>
<h2>小结</h2>
<p>我们对所有权有了更深入的了解，掌握了 Rc/Arc、RefCell/Mutex/RwLock 这些数据结构的用法。</p>
<p>如果想绕过“一个值只有一个所有者”的限制，我们可以使用 <strong>Rc/Arc 这样带引用计数的智能指针</strong>。其中，Rc 效率很高，但只能使用在单线程环境下；Arc 使用了原子结构，效率略低，但可以安全使用在多线程环境下。</p>
<p>然而，Rc/Arc 是不可变的，如果想要修改内部的数据，<strong>需要引入内部可变性</strong>，在单线程环境下，可以在 Rc 内部使用 RefCell；在多线程环境下，可以使用 Arc 嵌套 Mutex 或者 RwLock 的方法。</p>
<p>你可以看这张表快速回顾：<img src="assets/fc524d667fabeec0a8a22d0e10531086.jpg" alt="" /></p>
<h3>思考题</h3>
<ol>
<li>
<p>运行下面的代码，查看错误，并阅读 <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html">std::thread::spawn</a> 的文档，找到问题的原因后，修改代码使其编译通过。</p>
<p>fn main() {
let arr = vec![1];</p>
<p>std::thread::spawn(|| {
println!(&quot;{:?}&quot;, arr);
});
}</p>
</li>
<li>
<p>你可以写一段代码，在 main() 函数里生成一个字符串，然后通过 <code>std::thread::spawn</code> 创建一个线程，让 main() 函数所在的主线程和新的线程共享这个字符串么？提示：使用 <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">std::sync::Arc</a>。</p>
</li>
<li>
<p>我们看到了 Rc 的 clone() 方法的实现：</p>
<p>fn clone(&amp;self) -&gt; Rc<T> {
// 增加引用计数
self.inner().inc_strong();
// 通过 self.ptr 生成一个新的 Rc 结构
Self::from_inner(self.ptr)
}</p>
</li>
</ol>
<p>你有没有注意到，这个方法传入的参数是 <code>&amp;self</code> ，是个不可变引用，然而它调用了 <code>self.inner().inc_strong()</code> ，光看函数名字，它用来增加 self 的引用计数，可是，为什么这里对 self 的不可变引用可以改变 self 的内部数据呢？</p>
<p>欢迎在留言区分享你的思考。恭喜你完成了 Rust 学习的第九次打卡，如果你觉得有收获，也欢迎分享给你身边的朋友，邀TA一起讨论。</p>
<h2>参考资料</h2>
<ol>
<li>clone() 函数的<a href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1433-1453">实现源码</a></li>
<li><a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">最小权限原则</a></li>
<li>Rc::new() 的<a href="https://doc.rust-lang.org/src/alloc/rc.rs.html#342-350">源码</a></li>
<li>Arc 内部的引用计数使用了 <a href="https://doc.rust-lang.org/src/alloc/sync.rs.html#303-312">Atomic Usize</a></li>
<li>Atomic Usize 是 usize 的原子类型： <a href="https://doc.rust-lang.org/std/sync/atomic/index.html">std::sync::atomic 的文档</a></li>
<li>内部可变性：除了 RefCell 之外，Rust 还提供了 Cell。如果你想对 RefCell 和 Cell 进一步了解，可以看 Rust 标准库里<a href="https://doc.rust-lang.org/std/cell/index.html">cell 的文档</a>。</li>
</ol>
</div>
                        </div>
                        <div>
                            <div style="float: left">
                                <a href="08%20%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E5%80%9F%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F.md.html">上一页</a>
                            </div>
                            <div style="float: right">
                                <a href="10%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E4%BD%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%80%BC%E7%A9%B6%E7%AB%9F%E8%83%BD%E6%B4%BB%E5%A4%9A%E4%B9%85%EF%BC%9F.md.html">下一页</a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="copyright"><p>© 2019 - 2023 <a href="../../cdn-cgi/l/email-protection.html#fa969696c3cecbcbcacdba9d979b9396d4999597" target="_blank">Liangliang Lee</a>. Powered by <a href="https://vertx.io/" target="_blank">Vert.x</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p></div>
        </div>

        <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
    </div>
<script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script defer src="https://static.cloudflareinsights.com/beacon.min.js/vb26e4fa9e5134444860be286fd8771851679335129114" integrity="sha512-M3hN/6cva/SjwrOtyXeUa5IuCT0sedyfT+jK/OV+s+D0RnzrTfwjwJHhd+wYfMm9HJSrZ1IKksOdddLuN6KOzw==" data-cf-beacon='{"rayId":"7af499176d2ece54","version":"2023.3.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }

    hljs.initHighlightingOnLoad()

</script>

</html>
